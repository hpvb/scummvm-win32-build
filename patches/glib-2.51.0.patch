diff -urN glib-2.51.0.org/configure.ac glib-2.51.0/configure.ac
--- glib-2.51.0.org/configure.ac	2016-10-24 12:33:39.000000000 +0200
+++ glib-2.51.0/configure.ac	2016-10-28 22:58:56.885556623 +0200
@@ -140,7 +140,7 @@
     case "$host" in
     x86_64-*-*)
       LIB_EXE_MACHINE_FLAG=X64
-      glib_pollfd_format='%#I64x'
+      glib_pollfd_format='%#llx'
       ;;
     esac
 
@@ -570,7 +570,7 @@
 ])
 fi
 
-AS_IF([test x$glib_native_win32 != xyes && test x$ac_cv_sizeof_long_long = x8], [
+AS_IF([test x$ac_cv_sizeof_long_long = x8], [
 	# long long is a 64 bit integer.
 	AC_MSG_CHECKING(for format to printf and scanf a guint64)
 	AC_CACHE_VAL(glib_cv_long_long_format,[
@@ -592,8 +592,8 @@
 	AS_IF([ test -n "$glib_cv_long_long_format"], [
 	  AC_MSG_RESULT(%${glib_cv_long_long_format}u)
 	  AC_DEFINE(HAVE_LONG_LONG_FORMAT,1,[define if system printf can print long long])
-	  if test x"$glib_cv_long_long_format" = xI64; then
-	    AC_DEFINE(HAVE_INT64_AND_I64,1,[define to support printing 64-bit integers with format I64])
+	  if test x"$glib_cv_long_long_format" = xll; then
+	    AC_DEFINE(HAVE_INT64_AND_I64,1,[define to support printing 64-bit integers with format ll])
           fi
 	], [AC_MSG_RESULT(none)])
 ],[ test x$ac_cv_sizeof___int64 = x8], [
@@ -3059,8 +3059,8 @@
   glib_msize_type='LONG'
   ;;
 "long long"|__int64)
-  gsize_modifier='"I64"'
-  gsize_format='"I64u"'
+  gsize_modifier='"z"'
+  gsize_format='"zu"'
   glib_msize_type='INT64'
   ;;
 esac
@@ -3082,8 +3082,8 @@
   glib_mssize_type='LONG'
   ;;
 "long long"|__int64)
-  gssize_modifier='"I64"'
-  gssize_format='"I64i"'
+  gssize_modifier='"z"'
+  gssize_format='"zi"'
   glib_mssize_type='INT64'
   ;;
 esac
@@ -3112,9 +3112,9 @@
   ;;
 $ac_cv_sizeof_long_long)
   glib_intptr_type_define='long long'
-  gintptr_modifier='"I64"'
-  gintptr_format='"I64i"'
-  guintptr_format='"I64u"'
+  gintptr_modifier='"ll"'
+  gintptr_format='"lli"'
+  guintptr_format='"llu"'
   glib_gpi_cast='(gint64)'
   glib_gpui_cast='(guint64)'
   ;;
diff -urN glib-2.51.0.org/configure.ac.orig glib-2.51.0/configure.ac.orig
--- glib-2.51.0.org/configure.ac.orig	1970-01-01 01:00:00.000000000 +0100
+++ glib-2.51.0/configure.ac.orig	2016-10-24 12:33:39.000000000 +0200
@@ -0,0 +1,3511 @@
+# Process this file with autoconf to produce a configure script.
+AC_PREREQ([2.62])
+
+dnl ***********************************
+dnl *** include special GLib macros ***
+dnl ***********************************
+
+m4_define(glib_configure_ac)
+
+#
+# The following version number definitions apply to GLib, GModule, GObject,
+# GThread and GIO as a whole, so if changes occurred in any of them, they are
+# all treated with the same interface and binary age.
+#
+# Making releases:
+#   glib_micro_version += 1;
+#   glib_interface_age += 1;
+#   glib_binary_age += 1;
+# if any functions have been added, set glib_interface_age to 0.
+# if backwards compatibility has been broken,
+# set glib_binary_age _and_ glib_interface_age to 0.
+#
+# remember to add a GLIB_VERSION_2_xx macro every time the minor version is
+# bumped, as well as the GLIB_DEPRECATED_IN and GLIB_AVAILABLE_IN macros
+# for that version - see gversion.h for further information.
+#
+# in easier to understand terms:
+#
+# <mclasen> on the stable branch, interface age == micro
+# <mclasen> on the unstable (ie master), interface age = 0
+
+m4_define([glib_major_version], [2])
+m4_define([glib_minor_version], [51])
+m4_define([glib_micro_version], [0])
+m4_define([glib_interface_age], [0])
+m4_define([glib_binary_age],
+          [m4_eval(100 * glib_minor_version + glib_micro_version)])
+m4_define([glib_version],
+          [glib_major_version.glib_minor_version.glib_micro_version])
+
+# libtool version related macros
+m4_define([glib_lt_release], [glib_major_version.glib_minor_version])
+m4_define([glib_lt_current],
+          [m4_eval(100 * glib_minor_version + glib_micro_version - glib_interface_age)])
+m4_define([glib_lt_revision], [glib_interface_age])
+m4_define([glib_lt_age], [m4_eval(glib_binary_age - glib_interface_age)])
+m4_define([glib_lt_current_minus_age],
+          [m4_eval(glib_lt_current - glib_lt_age)])
+
+# if the minor version number is odd, then we want debugging.  Otherwise
+# we only want minimal debugging support.
+m4_define([glib_debug_default],
+          [m4_if(m4_eval(glib_minor_version % 2), [1], [yes], [minimum])])dnl
+
+
+AC_INIT(glib, [glib_version],
+        [http://bugzilla.gnome.org/enter_bug.cgi?product=glib])
+
+AC_CONFIG_HEADERS([config.h])
+AC_CONFIG_SRCDIR([glib/glib.h])
+AC_CONFIG_MACRO_DIR([m4macros])
+
+# Save this value here, since automake will set cflags later
+cflags_set=${CFLAGS:+set}
+
+AM_INIT_AUTOMAKE([1.11 -Wno-portability no-define no-dist-gzip dist-xz tar-ustar])
+AM_MAINTAINER_MODE([enable])
+
+# Support silent build rules. Disable
+# by either passing --disable-silent-rules to configure or passing V=1
+# to make
+AM_SILENT_RULES([yes])
+
+GLIB_MAJOR_VERSION=glib_major_version
+GLIB_MINOR_VERSION=glib_minor_version
+GLIB_MICRO_VERSION=glib_micro_version
+GLIB_INTERFACE_AGE=glib_interface_age
+GLIB_BINARY_AGE=glib_binary_age
+GLIB_VERSION=glib_version
+
+AC_SUBST(GLIB_MAJOR_VERSION)
+AC_SUBST(GLIB_MINOR_VERSION)
+AC_SUBST(GLIB_MICRO_VERSION)
+AC_SUBST(GLIB_VERSION)
+AC_SUBST(GLIB_INTERFACE_AGE)
+AC_SUBST(GLIB_BINARY_AGE)
+
+AC_DEFINE(GLIB_MAJOR_VERSION, [glib_major_version],
+	  [Define to the GLIB major version])
+AC_DEFINE(GLIB_MINOR_VERSION, [glib_minor_version],
+	  [Define to the GLIB minor version])
+AC_DEFINE(GLIB_MICRO_VERSION, [glib_micro_version],
+	  [Define to the GLIB micro version])
+AC_DEFINE(GLIB_INTERFACE_AGE, [glib_interface_age],
+	  [Define to the GLIB interface age])
+AC_DEFINE(GLIB_BINARY_AGE, [glib_binary_age],
+	  [Define to the GLIB binary age])
+
+# libtool versioning
+LT_RELEASE=glib_lt_release
+LT_CURRENT=glib_lt_current
+LT_REVISION=glib_lt_revision
+LT_AGE=glib_lt_age
+LT_CURRENT_MINUS_AGE=glib_lt_current_minus_age
+AC_SUBST(LT_RELEASE)
+AC_SUBST(LT_CURRENT)
+AC_SUBST(LT_REVISION)
+AC_SUBST(LT_AGE)
+AC_SUBST(LT_CURRENT_MINUS_AGE)
+
+dnl Checks for programs.
+AC_PROG_CC
+AC_PROG_CPP
+AC_USE_SYSTEM_EXTENSIONS
+
+AM_CONDITIONAL(HAVE_GCC, [test "$GCC" = "yes"])
+
+AC_CANONICAL_HOST
+
+dnl
+
+AC_MSG_CHECKING([for Win32])
+LIB_EXE_MACHINE_FLAG=X86
+case "$host" in
+  *-*-mingw*)
+    glib_native_win32=yes
+    glib_pid_type='void *'
+    glib_pid_format='p'
+    glib_pollfd_format='%#x'
+    glib_cv_stack_grows=no
+    # Unfortunately the mingw implementations of C99-style snprintf and vsnprintf
+    # don't seem to be quite good enough, at least not in mingw-runtime-3.14.
+    # (Sorry, I don't know exactly what is the problem, but it is related to
+    # floating point formatting and decimal point vs. comma.)
+    # The simple tests in AC_FUNC_VSNPRINTF_C99 and AC_FUNC_SNPRINTF_C99 aren't
+    # rigorous enough to notice, though.
+    # So preset the autoconf cache variables.
+    ac_cv_func_vsnprintf_c99=no
+    ac_cv_func_snprintf_c99=no
+    case "$host" in
+    x86_64-*-*)
+      LIB_EXE_MACHINE_FLAG=X64
+      glib_pollfd_format='%#I64x'
+      ;;
+    esac
+
+    AC_DEFINE([_WIN32_WINNT], [0x0501], [Target the Windows XP API])
+    ;;
+  *)
+    glib_native_win32=no
+    glib_pid_type=int
+    glib_pid_format='i'
+    glib_pollfd_format='%d'
+    ;;
+esac
+case $host in
+  *-*-linux*)
+    glib_os_linux=yes
+    ;;
+esac
+
+AC_MSG_RESULT([$glib_native_win32])
+
+AC_MSG_CHECKING([for the Android])
+case $host in
+  *android*)
+    glib_native_android="yes"
+    ;;
+  *)
+    glib_native_android="no"
+    ;;
+esac
+AC_MSG_RESULT([$glib_native_android])
+
+AC_SUBST(LIB_EXE_MACHINE_FLAG)
+
+glib_have_carbon=no
+AC_MSG_CHECKING([for Mac OS X Carbon support])
+AC_TRY_CPP([
+#include <Carbon/Carbon.h>
+#include <CoreServices/CoreServices.h>
+], glib_have_carbon=yes)
+
+AC_MSG_RESULT([$glib_have_carbon])
+
+glib_have_cocoa=no
+AC_MSG_CHECKING([for Mac OS X Cocoa support])
+AC_TRY_CPP([
+#include <Cocoa/Cocoa.h>
+#ifdef GNUSTEP_BASE_VERSION
+#error "Detected GNUstep, not Cocoa"
+#endif
+], glib_have_cocoa=yes)
+
+AC_MSG_RESULT([$glib_have_cocoa])
+
+AM_CONDITIONAL(OS_WIN32, [test "$glib_native_win32" = "yes"])
+AM_CONDITIONAL(OS_WIN32_X64, [test "$LIB_EXE_MACHINE_FLAG" = "X64"])
+AM_CONDITIONAL(OS_UNIX, [test "$glib_native_win32" != "yes"])
+AM_CONDITIONAL(OS_LINUX, [test "$glib_os_linux" = "yes"])
+AM_CONDITIONAL(OS_CARBON, [test "$glib_have_carbon" = "yes"])
+AM_CONDITIONAL(OS_COCOA, [test "$glib_have_cocoa" = "yes"])
+
+AS_IF([test "$glib_native_win32" = "yes"], [
+  AC_CHECK_TOOL(WINDRES, windres, no)
+  if test "$WINDRES" = no; then
+    AC_MSG_ERROR([*** Could not find an implementation of windres in your PATH.])
+  fi
+  AC_CHECK_TOOL(NM, nm, no)
+  if test "$NM" = no; then
+    AC_MSG_ERROR([*** Could not find an implementation of nm in your PATH.])
+  fi
+  AC_CHECK_TOOL(RANLIB, ranlib, :)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, :)
+  AC_CHECK_PROG(ms_librarian, [lib.exe], [yes], [no])
+])
+AM_CONDITIONAL(MS_LIB_AVAILABLE, [test x$ms_librarian = xyes])
+
+AS_IF([test "x$glib_have_carbon" = "xyes"], [
+  AC_DEFINE(HAVE_CARBON, 1, [define to 1 if Carbon is available])
+  CARBON_LIBS="-Wl,-framework,Carbon"
+  LDFLAGS="$LDFLAGS $CARBON_LIBS"
+], [CARBON_LIBS=""])
+
+AC_SUBST([CARBON_LIBS])
+
+AS_IF([test "x$glib_have_cocoa" = "xyes"], [
+  AC_DEFINE(HAVE_COCOA, 1, [define to 1 if Cocoa is available])
+  COCOA_LIBS="-Wl,-framework,Foundation"
+  LDFLAGS="$LDFLAGS $COCOA_LIBS"
+
+  osx_version=`sw_vers -productVersion`
+  osx_min_version="10.9.0"
+  AC_MSG_CHECKING([OSX version >= $osx_min_version])
+  AS_VERSION_COMPARE([$osx_version], [$osx_min_version], [
+    AC_MSG_RESULT([no])
+    AC_MSG_ERROR([OSX version is too old!])
+  ])
+  AC_MSG_RESULT([yes])
+], [COCOA_LIBS=""])
+
+AC_SUBST([COCOA_LIBS])
+
+dnl declare --enable-* args and collect ac_help strings
+AC_ARG_ENABLE(debug,
+              AS_HELP_STRING([--enable-debug=@<:@no/minimum/yes@:>@],
+                             [turn on debugging @<:@default=glib_debug_default@:>@]),,
+              enable_debug=glib_debug_default)
+
+AC_ARG_ENABLE(gc_friendly,
+              [AS_HELP_STRING([--enable-gc-friendly],
+                              [turn on garbage collector friendliness [default=no]])],,
+              [enable_gc_friendly=no])
+AC_ARG_ENABLE(mem_pools,
+              [AS_HELP_STRING([--disable-mem-pools],
+			      [disable all glib memory pools])],,
+	      [disable_mem_pools=no])
+AC_ARG_ENABLE(rebuilds,
+              [AS_HELP_STRING([--disable-rebuilds],
+                              [disable all source autogeneration rules])],,
+              [enable_rebuilds=yes])
+
+GLIB_TESTS
+
+AC_MSG_CHECKING([whether to enable garbage collector friendliness])
+AS_IF([test "x$enable_gc_friendly" = "xyes"], [
+  AC_DEFINE(ENABLE_GC_FRIENDLY_DEFAULT, 1, [Whether to enable GC friendliness by default])
+  AC_MSG_RESULT([yes])
+], [ AC_MSG_RESULT([no]) ])
+
+AC_MSG_CHECKING([whether to disable memory pools])
+AS_IF([test "x$disable_mem_pools" = "xno"], [
+  AC_MSG_RESULT([no])
+], [
+  AC_DEFINE(DISABLE_MEM_POOLS, [1], [Whether to disable memory pools])
+  AC_MSG_RESULT([yes])
+])
+
+dnl location to install runtime libraries, e.g. ../../lib to install
+dnl to /lib if libdir is /usr/lib
+AC_ARG_WITH(runtime-libdir,
+           [AS_HELP_STRING([--with-runtime-libdir=RELPATH],
+                           [install runtime libraries relative to libdir])],
+           [],
+	   [with_runtime_libdir=""])
+GLIB_RUNTIME_LIBDIR="$with_runtime_libdir"
+AC_SUBST(GLIB_RUNTIME_LIBDIR)
+AM_CONDITIONAL(HAVE_GLIB_RUNTIME_LIBDIR, [test "x$with_runtime_libdir" != "x"])
+
+dnl Check for a working C++ compiler, but do not bail out, if none is found.
+AC_CHECK_TOOLS(CXX, [$CCC c++ g++ gcc CC cxx cc++ cl], [gcc])
+AC_LANG_SAVE
+AC_LANG_CPLUSPLUS
+AC_TRY_COMPILE(,[class a { int b; } c;], ,CXX=)
+AM_CONDITIONAL(HAVE_CXX, [test "$CXX" != ""])
+AC_LANG_RESTORE
+
+AM_PROG_CC_C_O
+AC_PROG_INSTALL
+
+AC_SYS_LARGEFILE
+
+PKG_PROG_PKG_CONFIG(0.16)
+
+if test "x$enable_debug" = "xyes"; then
+  if test "x$cflags_set" != "x" ; then
+      case " $CFLAGS " in
+      *[[\ \	]]-g[[\ \	]]*) ;;
+      *) CFLAGS="$CFLAGS -g" ;;
+      esac
+  fi
+  GLIB_DEBUG_FLAGS="-DG_ENABLE_DEBUG"
+else
+  GLIB_DEBUG_FLAGS="-DG_DISABLE_CAST_CHECKS"
+
+  if test "x$enable_debug" = "xno"; then
+    GLIB_DEBUG_FLAGS="$GLIB_DEBUG_FLAGS -DG_DISABLE_ASSERT -DG_DISABLE_CHECKS"
+  fi
+fi
+
+# Ensure MSVC-compatible struct packing convention is used when
+# compiling for Win32 with gcc.
+# What flag to depends on gcc version: gcc3 uses "-mms-bitfields", while
+# gcc2 uses "-fnative-struct".
+if test x"$glib_native_win32" = xyes; then
+  if test x"$GCC" = xyes; then
+    msnative_struct=''
+    AC_MSG_CHECKING([how to get MSVC-compatible struct packing])
+    if test -z "$ac_cv_prog_CC"; then
+      our_gcc="$CC"
+    else
+      our_gcc="$ac_cv_prog_CC"
+    fi
+    case `$our_gcc --version | sed -e 's,\..*,.,' -e q` in
+      2.)
+	if $our_gcc -v --help 2>/dev/null | grep fnative-struct >/dev/null; then
+	  msnative_struct='-fnative-struct'
+	fi
+	;;
+      *)
+	if $our_gcc -v --help 2>/dev/null | grep ms-bitfields >/dev/null; then
+	  msnative_struct='-mms-bitfields'
+	fi
+	;;
+    esac
+    if test x"$msnative_struct" = x ; then
+      AC_MSG_RESULT([no way])
+      AC_MSG_WARN([produced libraries might be incompatible with MSVC-compiled code])
+    else
+      CFLAGS="$CFLAGS $msnative_struct"
+      AC_MSG_RESULT([${msnative_struct}])
+    fi
+  fi
+fi
+GLIB_EXTRA_CFLAGS="${msnative_struct}"
+AC_SUBST(GLIB_EXTRA_CFLAGS)
+
+AC_EXEEXT
+
+# define a MAINT-like variable REBUILD which is set if Perl
+# and awk are found, so autogenerated sources can be rebuilt
+AC_PROG_AWK
+AC_CHECK_PROGS(PERL, [perl5 perl])
+# We would like indent, but don't require it.
+AC_CHECK_PROG(INDENT, indent, indent)
+REBUILD=\#
+if test "x$enable_rebuilds" = "xyes" && \
+     test -n "$PERL" && \
+     $PERL -e 'exit !($] >= 5.002)' > /dev/null 2>&1 && \
+     test -n "$AWK" ; then
+  REBUILD=
+fi
+AC_SUBST(REBUILD)
+
+# Need full path to Perl for glib-mkenums
+#
+if test "x$PERL" != x ; then
+  AC_PATH_PROG(PERL_PATH, [$PERL])
+fi
+if test "x$PERL_PATH" = x ; then
+  PERL_PATH="/usr/bin/env perl"
+fi
+AC_SUBST(PERL_PATH)
+
+# option to specify python interpreter to use; this just sets $PYTHON, so that
+# we will fallback to reading $PYTHON if --with-python is not given, and
+# python.m4 will get the expected input
+AC_ARG_WITH(python,
+            AS_HELP_STRING([--with-python=PATH],
+                           [Path to Python interpreter; searches $PATH if only a program name is given; if not given, searches for a few standard names such as "python3" or "python2"]),
+            [PYTHON="$withval"], [])
+if test x"$PYTHON" = xyes; then
+  AC_MSG_ERROR([--with-python option requires a path or program argument])
+fi
+AM_PATH_PYTHON(2.5,,PYTHON="/usr/bin/env python2.5")
+
+
+dnl ***********************
+dnl *** Tests for iconv ***
+dnl ***********************
+dnl
+dnl We do this before the gettext checks, to avoid distortion
+
+dnl On Windows we use a native implementation
+
+AS_IF([ test x"$glib_native_win32" = xyes], [
+  with_libiconv=native
+], [
+  AC_ARG_WITH(libiconv,
+	      [AS_HELP_STRING([--with-libiconv=@<:@no/gnu/native@:>@],
+			      [use the libiconv library])],,
+	      [with_libiconv=maybe])
+
+  found_iconv=no
+  case $with_libiconv in
+    maybe)
+      # Check in the C library first
+      AC_CHECK_FUNC(iconv_open, [with_libiconv=no; found_iconv=yes])
+      # Check if we have GNU libiconv
+      if test $found_iconv = "no"; then
+	AC_CHECK_LIB(iconv, libiconv_open, [with_libiconv=gnu; found_iconv=yes])
+      fi
+      # Check if we have a iconv in -liconv, possibly from vendor
+      if test $found_iconv = "no"; then
+	AC_CHECK_LIB(iconv, iconv_open, [with_libiconv=native; found_iconv=yes])
+      fi
+      ;;
+    no)
+      AC_CHECK_FUNC(iconv_open, [with_libiconv=no; found_iconv=yes])
+      ;;
+    gnu|yes)
+      AC_CHECK_LIB(iconv, libiconv_open, [with_libiconv=gnu; found_iconv=yes])
+      ;;
+    native)
+      AC_CHECK_LIB(iconv, iconv_open, [with_libiconv=native; found_iconv=yes])
+      ;;
+  esac
+
+  if test "x$found_iconv" = "xno" ; then
+     AC_MSG_ERROR([*** No iconv() implementation found in C library or libiconv])
+  fi
+])
+
+dnl
+dnl zlib support
+dnl
+PKG_CHECK_MODULES([ZLIB], [zlib], [found_zlib=yes], [found_zlib=no])
+AS_IF([test "x$found_zlib" = "xno"], [
+  AC_CHECK_LIB(z, inflate, [AC_CHECK_HEADER(zlib.h, found_zlib=yes)])
+  if test "x$found_zlib" = "xno" ; then
+    AC_MSG_ERROR([*** Working zlib library and headers not found ***])
+  fi
+  ZLIB_LIBS='-lz'
+  AC_SUBST(ZLIB_LIBS)
+])
+
+PKG_CHECK_MODULES(LIBFFI, [libffi >= 3.0.0])
+AC_SUBST(LIBFFI_CFLAGS)
+AC_SUBST(LIBFFI_LIBS)
+
+dnl
+dnl gettext support
+dnl
+
+ALL_LINGUAS="`grep -v '^#' "$srcdir/po/LINGUAS" | tr '\n' ' '`"
+AC_SUBST([CONFIG_STATUS_DEPENDENCIES],['$(top_srcdir)/po/LINGUAS'])
+GLIB_GNU_GETTEXT
+
+if test "$gt_cv_have_gettext" != "yes" ; then
+  AC_MSG_ERROR([
+*** You must have either have gettext support in your C library, or use the 
+*** GNU gettext library. (http://www.gnu.org/software/gettext/gettext.html
+])
+fi
+
+LIBS="$INTLLIBS $LIBS"
+
+GETTEXT_PACKAGE=glib20
+AC_SUBST(GETTEXT_PACKAGE)
+AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE, ["$GETTEXT_PACKAGE"], 
+  [Define the gettext package to be used])
+
+GLIB_DEFINE_LOCALEDIR(GLIB_LOCALE_DIR)
+
+dnl
+dnl Now we are done with gettext checks, figure out ICONV_LIBS
+dnl
+
+AS_IF([test x"$glib_native_win32" != xyes], [
+  if test x$with_libiconv != xno ; then
+    case " $INTLLIBS " in
+    *[[\ \	]]-liconv[[\ \	]]*) ;;
+    *) ICONV_LIBS="-liconv" ;;
+    esac
+  fi
+])
+AC_SUBST(ICONV_LIBS)
+
+case $with_libiconv in
+  gnu)
+    AC_DEFINE(USE_LIBICONV_GNU, 1, [Using GNU libiconv])
+    ;;
+  native)
+    AC_DEFINE(USE_LIBICONV_NATIVE, 1, [Using a native implementation of iconv in a separate library])
+    ;;
+esac
+
+dnl Initialize libtool
+LT_PREREQ([2.2])
+LT_INIT([disable-static win32-dll])
+dnl when using libtool 2.x create libtool early, because it's used in configure
+m4_ifdef([LT_OUTPUT], [LT_OUTPUT])
+
+
+AS_IF([test "$glib_native_win32" = "yes"], [
+  if test x$enable_static = xyes -a x$enable_shared = xyes; then
+    AC_MSG_ERROR([Can not build both shared and static at the same time on Windows.])
+  fi
+  if test x$enable_static = xyes; then
+    glib_win32_static_compilation=yes
+    GLIB_WIN32_STATIC_COMPILATION_DEFINE="#define GLIB_STATIC_COMPILATION 1
+#define GOBJECT_STATIC_COMPILATION 1"
+    AC_SUBST(GLIB_WIN32_STATIC_COMPILATION_DEFINE)
+  fi
+])
+AM_CONDITIONAL(OS_WIN32_AND_DLL_COMPILATION, [test x$glib_native_win32 = xyes -a x$glib_win32_static_compilation != xyes])
+
+# Checks for library functions.
+AC_FUNC_ALLOCA
+AC_CHECK_FUNCS(mmap posix_memalign memalign valloc fsync pipe2 issetugid)
+AC_CHECK_FUNCS(timegm gmtime_r strerror_r)
+
+AC_CACHE_CHECK([for __libc_enable_secure], glib_cv_have_libc_enable_secure,
+  [AC_TRY_LINK([#include <unistd.h>
+    extern int __libc_enable_secure;],
+    [return __libc_enable_secure;],
+   glib_cv_have_libc_enable_secure=yes,
+   glib_cv_have_libc_enable_secure=no)])
+AS_IF([test x$glib_cv_have_libc_enable_secure = xyes], [
+   AC_DEFINE(HAVE_LIBC_ENABLE_SECURE, 1,
+     [Define if you have the __libc_enable_secure variable (GNU libc, eglibc)])
+])
+
+AC_CHECK_SIZEOF(char)
+AC_CHECK_SIZEOF(short)
+AC_CHECK_SIZEOF(long)
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(void *)
+AC_CHECK_SIZEOF(long long)
+AC_CHECK_SIZEOF(__int64)
+
+AC_CACHE_CHECK([for sig_atomic_t], ac_cv_type_sig_atomic_t,
+  [AC_TRY_LINK([#include <signal.h>
+     #include <sys/types.h>
+     sig_atomic_t val = 42;],
+    [return val == 42 ? 0 : 1],
+   ac_cv_type_sig_atomic_t=yes,
+   ac_cv_type_sig_atomic_t=no)])
+if test x$ac_cv_type_sig_atomic_t = xyes; then
+   AC_DEFINE(HAVE_SIG_ATOMIC_T, 1,
+     [Define if you have the 'sig_atomic_t' type.])
+fi
+
+if test x$ac_cv_sizeof_long = x8 || test x$ac_cv_sizeof_long_long = x8 || test x$ac_cv_sizeof___int64 = x8 ; then
+  :
+else
+  AC_MSG_ERROR([
+*** GLib requires a 64 bit type. You might want to consider
+*** using the GNU C compiler.
+])
+fi
+
+AS_IF([test x$glib_native_win32 != xyes && test x$ac_cv_sizeof_long_long = x8], [
+	# long long is a 64 bit integer.
+	AC_MSG_CHECKING(for format to printf and scanf a guint64)
+	AC_CACHE_VAL(glib_cv_long_long_format,[
+		for format in ll q I64; do
+		  AC_TRY_RUN([#include <stdio.h>  
+			int main()
+			{
+			  long long b, a = -0x3AFAFAFAFAFAFAFALL;
+			  char buffer[1000];
+			  sprintf (buffer, "%${format}u", a);
+  			  sscanf (buffer, "%${format}u", &b);
+			  exit (b!=a);
+			}
+			],
+			[glib_cv_long_long_format=${format}
+			break],
+			[],[:])
+		done])
+	AS_IF([ test -n "$glib_cv_long_long_format"], [
+	  AC_MSG_RESULT(%${glib_cv_long_long_format}u)
+	  AC_DEFINE(HAVE_LONG_LONG_FORMAT,1,[define if system printf can print long long])
+	  if test x"$glib_cv_long_long_format" = xI64; then
+	    AC_DEFINE(HAVE_INT64_AND_I64,1,[define to support printing 64-bit integers with format I64])
+          fi
+	], [AC_MSG_RESULT(none)])
+],[ test x$ac_cv_sizeof___int64 = x8], [
+	# __int64 is a 64 bit integer.
+	AC_MSG_CHECKING(for format to printf and scanf a guint64)
+	# We know this is MSVCRT.DLL, and what the formats are
+	glib_cv_long_long_format=I64
+	AC_MSG_RESULT(%${glib_cv_long_long_format}u)
+        AC_DEFINE(HAVE_LONG_LONG_FORMAT,1,[define if system printf can print long long])
+	AC_DEFINE(HAVE_INT64_AND_I64,1,[define to support printing 64-bit integers with format I64])
+])
+
+AC_C_CONST
+
+dnl
+dnl check in which direction the stack grows
+dnl
+AC_CACHE_CHECK([for growing stack pointer],glib_cv_stack_grows,[
+        AC_TRY_RUN([
+	volatile int *a = 0, *b = 0;
+	void f (int i) { volatile int x = 5; if (i == 0) b = &x; else f (i - 1); }
+	int main () { volatile int y = 7; a = &y; f (100); return b > a ? 0 : 1; }
+       	],
+	glib_cv_stack_grows=yes
+        ,
+	glib_cv_stack_grows=no
+        ,)
+])
+
+# check for flavours of varargs macros
+AC_MSG_CHECKING(for ISO C99 varargs macros in C)
+AC_TRY_COMPILE([],[
+int a(int p1, int p2, int p3);
+#define call_a(...) a(1,__VA_ARGS__)
+call_a(2,3);
+],g_have_iso_c_varargs=yes,g_have_iso_c_varargs=no)
+AC_MSG_RESULT($g_have_iso_c_varargs)
+
+AC_MSG_CHECKING(for ISO C99 varargs macros in C++)
+AS_IF([test "$CXX" = ""], [
+dnl No C++ compiler
+  g_have_iso_cxx_varargs=no
+else
+  AC_LANG_CPLUSPLUS
+  AC_TRY_COMPILE([],[
+int a(int p1, int p2, int p3);
+#define call_a(...) a(1,__VA_ARGS__)
+call_a(2,3);
+],g_have_iso_cxx_varargs=yes,g_have_iso_cxx_varargs=no)
+  AC_LANG_C
+])
+AC_MSG_RESULT($g_have_iso_cxx_varargs)
+
+AC_MSG_CHECKING(for GNUC varargs macros)
+AC_TRY_COMPILE([],[
+int a(int p1, int p2, int p3);
+#define call_a(params...) a(1,params)
+call_a(2,3);
+],g_have_gnuc_varargs=yes,g_have_gnuc_varargs=no)
+AC_MSG_RESULT($g_have_gnuc_varargs)
+
+# check for GNUC visibility support
+AC_MSG_CHECKING(for GNUC visibility attribute)
+GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[
+void
+__attribute__ ((visibility ("hidden")))
+     f_hidden (void)
+{
+}
+void
+__attribute__ ((visibility ("internal")))
+     f_internal (void)
+{
+}
+void
+__attribute__ ((visibility ("protected")))
+     f_protected (void)
+{
+}
+void
+__attribute__ ((visibility ("default")))
+     f_default (void)
+{
+}
+int main (void)
+{
+	f_hidden();
+	f_internal();
+	f_protected();
+	f_default();
+	return 0;
+}
+]])],g_have_gnuc_visibility=yes,g_have_gnuc_visibility=no)
+AC_MSG_RESULT($g_have_gnuc_visibility)
+AM_CONDITIONAL(HAVE_GNUC_VISIBILITY, [test x$g_have_gnuc_visibility = xyes])
+
+AC_MSG_CHECKING([whether using Sun Studio C compiler])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#if defined(__SUNPRO_C) || (__SUNPRO_C >= 0x550)
+#else
+# include "error: this is not Sun Studio."
+#endif
+]], [[]])], [ g_have_sunstudio_visibility=yes ], [ g_have_sunstudio_visibility=no ])
+AC_MSG_RESULT($g_have_sunstudio_visibility)
+AM_CONDITIONAL(HAVE_SUNSTUDIO_VISIBILITY, [test x$g_have_sunstudio_visibility = xyes])
+
+# check for bytesex stuff
+AC_C_BIGENDIAN
+if test x$ac_cv_c_bigendian = xuniversal ; then
+  AC_MSG_ERROR([Universal builds not supported: see https://bugs.gnome.org/742548])
+fi
+
+
+# check for header files
+AC_CHECK_HEADERS([sys/param.h sys/resource.h mach/mach_time.h])
+AC_CHECK_HEADERS([sys/select.h stdint.h inttypes.h sched.h malloc.h])
+AC_CHECK_HEADERS([sys/vfs.h sys/vmount.h sys/statfs.h sys/statvfs.h sys/filio.h])
+AC_CHECK_HEADERS([mntent.h sys/mnttab.h sys/vfstab.h sys/mntctl.h fstab.h])
+AC_CHECK_HEADERS([linux/magic.h])
+
+# Some versions of MSC lack these
+AC_CHECK_HEADERS([dirent.h sys/time.h])
+
+# We don't care about this, but we need to keep including it in
+# glibconfig.h for backward compatibility
+AC_CHECK_HEADERS([values.h])
+
+AC_CHECK_HEADERS([sys/mount.h sys/sysctl.h], [], [],
+[#if HAVE_SYS_PARAM_H
+ #include <sys/param.h>
+ #endif
+])
+AC_CHECK_FUNCS(sysctlbyname)
+
+AC_HEADER_MAJOR
+AC_CHECK_HEADERS([xlocale.h])
+
+# check for structure fields
+AC_CHECK_MEMBERS([struct stat.st_mtimensec, struct stat.st_mtim.tv_nsec, struct stat.st_atimensec, struct stat.st_atim.tv_nsec, struct stat.st_ctimensec, struct stat.st_ctim.tv_nsec, struct stat.st_birthtime, struct stat.st_birthtimensec, struct stat.st_birthtim, struct stat.st_birthtim.tv_nsec])
+AC_CHECK_MEMBERS([struct stat.st_blksize, struct stat.st_blocks, struct statfs.f_fstypename, struct statfs.f_bavail],,, [#include <sys/types.h>
+#include <sys/stat.h>
+#ifdef G_OS_UNIX
+#include <unistd.h>
+#endif
+#ifdef HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif])
+# struct statvfs.f_basetype is available on Solaris but not for Linux. 
+AC_CHECK_MEMBERS([struct statvfs.f_basetype],,, [#include <sys/statvfs.h>])
+AC_CHECK_MEMBERS([struct statvfs.f_fstypename],,, [#include <sys/statvfs.h>])
+AC_CHECK_MEMBERS([struct tm.tm_gmtoff, struct tm.__tm_gmtoff],,,[#include <time.h>])
+
+AC_STRUCT_DIRENT_D_TYPE
+
+# Checks for libcharset
+AM_LANGINFO_CODESET
+gl_GLIBC21
+
+# check additional type sizes
+AC_CHECK_SIZEOF(size_t)
+
+dnl Try to figure out whether gsize should be long or int
+AC_MSG_CHECKING([for the appropriate definition for size_t])
+
+case $ac_cv_sizeof_size_t in
+  $ac_cv_sizeof_short) 
+      glib_size_type=short
+      ;;
+  $ac_cv_sizeof_int) 
+      glib_size_type=int
+      ;;
+  $ac_cv_sizeof_long) 
+      glib_size_type=long
+      ;;
+  $ac_cv_sizeof_long_long)
+      glib_size_type='long long'
+      ;;
+  $ac_cv_sizeof__int64)
+      glib_size_type='__int64'
+      ;;
+  *)  AC_MSG_ERROR([No type matching size_t in size])
+      ;;
+esac
+
+dnl If int/long are the same size, we see which one produces
+dnl warnings when used in the location as size_t. (This matters
+dnl on AIX with xlc)
+dnl
+AS_IF([test $ac_cv_sizeof_size_t = $ac_cv_sizeof_int &&
+       test $ac_cv_sizeof_size_t = $ac_cv_sizeof_long], [
+  GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[
+#if defined(_AIX) && !defined(__GNUC__)
+#pragma options langlvl=stdc89
+#endif
+#include <stddef.h> 
+int main ()
+{
+  size_t s = 1;
+  unsigned int *size_int = &s;
+  return (int)*size_int;
+}
+    ]])],glib_size_type=int,
+      [GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[
+#if defined(_AIX) && !defined(__GNUC__)
+#pragma options langlvl=stdc89
+#endif
+#include <stddef.h> 
+int main ()
+{
+   size_t s = 1;
+   unsigned long *size_long = &s;
+   return (int)*size_long;
+}
+        ]])],glib_size_type=long)])
+])
+
+AC_MSG_RESULT(unsigned $glib_size_type)
+
+AC_CHECK_SIZEOF(ssize_t)
+
+dnl Try to figure out whether gssize should be long or int
+AC_MSG_CHECKING([for the appropriate definition for ssize_t])
+
+case $ac_cv_sizeof_ssize_t in
+  $ac_cv_sizeof_short) 
+      glib_ssize_type=short
+      ;;
+  $ac_cv_sizeof_int) 
+      glib_ssize_type=int
+      ;;
+  $ac_cv_sizeof_long) 
+      glib_ssize_type=long
+      ;;
+  $ac_cv_sizeof_long_long)
+      glib_ssize_type='long long'
+      ;;
+  $ac_cv_sizeof__int64)
+      glib_ssize_type='__int64'
+      ;;
+  *)  AC_MSG_ERROR([No type matching ssize_t in size])
+      ;;
+esac
+
+dnl If int/long are the same size, we see which one produces
+dnl warnings when used in the location as ssize_t. (This matters
+dnl on Android where ssize_t is long and size_t is unsigned int)
+dnl
+AS_IF([test $ac_cv_sizeof_ssize_t = $ac_cv_sizeof_int &&
+       test $ac_cv_sizeof_ssize_t = $ac_cv_sizeof_long], [
+  GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[
+#if defined(_AIX) && !defined(__GNUC__)
+#pragma options langlvl=stdc89
+#endif
+#include <stddef.h>
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#include <sys/types.h>
+int main ()
+{
+  ssize_t s = 1;
+  int *size_int = &s;
+  return (int)*size_int;
+}
+    ]])],glib_ssize_type=int,
+      [GLIB_CHECK_COMPILE_WARNINGS([AC_LANG_SOURCE([[
+#if defined(_AIX) && !defined(__GNUC__)
+#pragma options langlvl=stdc89
+#endif
+#include <stddef.h> 
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#include <sys/types.h>
+int main ()
+{
+   ssize_t s = 1;
+   long *size_long = &s;
+   return (int)*size_long;
+}
+        ]])],glib_ssize_type=long)])
+])
+
+AC_MSG_RESULT($glib_ssize_type)
+
+# Check for some functions
+AC_CHECK_FUNCS(lstat strsignal vsnprintf stpcpy strcasecmp strncasecmp poll vasprintf setenv unsetenv getc_unlocked readlink symlink fdwalk memmem)
+AC_CHECK_FUNCS(lchmod lchown fchmod fchown utimes getresuid)
+AC_CHECK_FUNCS(getmntent_r setmntent endmntent hasmntopt getfsstat getvfsstat fallocate)
+case $host_os in aix*) ac_cv_func_splice=no ;; esac # AIX splice() is something else
+AC_CHECK_FUNCS(splice)
+AC_CHECK_FUNCS(prlimit)
+
+# To avoid finding a compatibility unusable statfs, which typically
+# successfully compiles, but warns to use the newer statvfs interface:
+AS_IF([test $ac_cv_header_sys_statvfs_h = yes], [AC_CHECK_FUNCS([statvfs])])
+AS_IF([test $ac_cv_header_sys_statfs_h  = yes -o $ac_cv_header_sys_mount_h = yes], [AC_CHECK_FUNCS([statfs])])
+
+AC_MSG_CHECKING([whether to use statfs or statvfs])
+# Some systems have both statfs and statvfs, pick the most "native" for these
+AS_IF([test x$ac_cv_func_statfs = xyes && test x$ac_cv_func_statvfs = xyes],
+   [
+   # on solaris and irix, statfs doesn't even have the f_bavail field
+   AS_IF([test x$ac_cv_member_struct_statfs_f_bavail = xno],
+      [ac_cv_func_statfs=no],
+   # else, at least on linux, statfs is the actual syscall
+      [ac_cv_func_statvfs=no])
+   ])
+
+AS_IF([test x$ac_cv_func_statfs = xyes],
+      [
+         AC_DEFINE([USE_STATFS], [1], [Define to use statfs()])
+         AC_MSG_RESULT([statfs])
+      ],
+      [test x$ac_cv_func_statvfs = xyes],
+      [
+         AC_DEFINE([USE_STATVFS], [1], [Define to use statvfs()])
+         AC_MSG_RESULT([statvfs])
+      ],
+      [  AC_MSG_RESULT([neither])])
+
+AC_CHECK_HEADERS(crt_externs.h)
+AC_CHECK_FUNCS(_NSGetEnviron)
+
+AC_CHECK_FUNCS(newlocale uselocale strtod_l strtoll_l strtoull_l)
+
+# Internet address families
+if test $glib_native_win32 = yes; then
+  glib_inet_includes=["
+#include <winsock2.h>
+  "]
+else
+  glib_inet_includes=["
+#include <sys/types.h>
+#include <sys/socket.h>
+  "]
+fi
+
+glib_failed=false
+GLIB_CHECK_VALUE(AF_INET, $glib_inet_includes, glib_failed=true)
+GLIB_CHECK_VALUE(AF_INET6, $glib_inet_includes, glib_failed=true)
+# winsock defines this even though it doesn't support it
+GLIB_CHECK_VALUE(AF_UNIX, $glib_inet_includes, glib_failed=true)
+if $glib_failed ; then
+  AC_MSG_ERROR([Could not determine values for AF_INET* constants])
+fi
+
+glib_failed=false
+GLIB_CHECK_VALUE(MSG_PEEK, $glib_inet_includes, glib_failed=true)
+GLIB_CHECK_VALUE(MSG_OOB, $glib_inet_includes, glib_failed=true)
+GLIB_CHECK_VALUE(MSG_DONTROUTE, $glib_inet_includes, glib_failed=true)
+if $glib_failed ; then
+  AC_MSG_ERROR([Could not determine values for MSG_* constants])
+fi
+
+AC_CHECK_FUNCS(getprotobyname_r endservent if_nametoindex if_indextoname sendmmsg recvmmsg)
+
+AS_IF([test $glib_native_win32 = yes], [
+  # <wspiapi.h> in the Windows SDK and in mingw-w64 has wrappers for
+  # inline workarounds for getaddrinfo, getnameinfo and freeaddrinfo if
+  # they aren't present at run-time (on Windows 2000).
+  AC_CHECK_HEADER([wspiapi.h], [WSPIAPI_INCLUDE="#include <wspiapi.h>"])
+  AC_SUBST(WSPIAPI_INCLUDE)
+], [
+  # Android does not have C_IN in public headers, we define it wherever necessary
+  AS_IF([test $glib_native_android != yes], [
+    AC_MSG_CHECKING([if arpa/nameser_compat.h is needed])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>
+                                        #include <arpa/nameser.h>],
+                                       [int qclass = C_IN;])],
+                      [AC_MSG_RESULT([no])],
+                      [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>
+                                                           #include <arpa/nameser.h>
+                                                           #include <arpa/nameser_compat.h>],
+                                                          [int qclass = C_IN;])],
+                                         [AC_MSG_RESULT([yes])
+                                          NAMESER_COMPAT_INCLUDE="#include <arpa/nameser_compat.h>"],
+                                         [AC_MSG_ERROR([could not compile test program either way])])])])
+  AC_SUBST(NAMESER_COMPAT_INCLUDE)
+
+  # We can't just use AC_CHECK_FUNC/AC_CHECK_LIB here. Bug 586150
+  NETWORK_LIBS=""
+  AC_MSG_CHECKING([for res_query])
+  AC_TRY_LINK([#include <sys/types.h>
+	       #include <netinet/in.h>
+	       #include <arpa/nameser.h>
+	       #include <resolv.h>
+              ],[
+	       res_query("test", 0, 0, (void *)0, 0);
+              ],[AC_MSG_RESULT([yes])],
+              [save_libs="$LIBS"
+               LIBS="-lresolv $LIBS"
+               AC_TRY_LINK([#include <sys/types.h>
+			    #include <netinet/in.h>
+			    #include <arpa/nameser.h>
+			    #include <resolv.h>
+			   ],[
+			    res_query("test", 0, 0, (void *)0, 0);
+			   ],[AC_MSG_RESULT([in -lresolv])
+                              NETWORK_LIBS="-lresolv $NETWORK_LIBS"],
+                           [LIBS="-lbind $save_libs"
+                            AC_TRY_LINK([#include <resolv.h>],
+                                        [res_query("test", 0, 0, (void *)0, 0);],
+                                        [AC_MSG_RESULT([in -lbind])
+                                         NETWORK_LIBS="-lbind $NETWORK_LIBS"],
+                                        [AC_MSG_ERROR(not found)])])
+               LIBS="$save_libs"])
+  AC_CHECK_FUNC(socket, :, AC_CHECK_LIB(socket, socket,
+				        [NETWORK_LIBS="-lsocket $NETWORK_LIBS"],
+				        [AC_MSG_ERROR(Could not find socket())]))
+  save_libs="$LIBS"
+  LIBS="$LIBS $NETWORK_LIBS"
+  AC_MSG_CHECKING([for res_init])
+  AC_TRY_LINK([#include <sys/types.h>
+	       #include <netinet/in.h>
+	       #include <arpa/nameser.h>
+	       #include <resolv.h>
+              ],[
+	       res_init();
+              ],[AC_MSG_RESULT([yes])
+	         AC_DEFINE(HAVE_RES_INIT, 1, [Define to 1 if you have the 'res_init' function.])
+	      ],[AC_MSG_RESULT([no])])
+  LIBS="$save_libs"
+])
+AC_SUBST(NETWORK_LIBS)
+
+AC_CHECK_HEADER([linux/netlink.h],
+		[AC_DEFINE(HAVE_NETLINK, 1, [We have AF_NETLINK sockets])],,
+		[#include <sys/socket.h>])
+AM_CONDITIONAL(HAVE_NETLINK, [test "$ac_cv_header_linux_netlink_h" = "yes"])
+
+AC_CHECK_TYPE([struct ip_mreqn], [
+              AC_DEFINE(HAVE_IP_MREQN,, [Define if we have struct ip_mreqn])],,
+              [#include <netinet/in.h>])
+
+case $host in
+  *-*-solaris* )
+     AC_DEFINE(_XOPEN_SOURCE_EXTENDED, 1, Needed to get declarations for msg_control and msg_controllen on Solaris)
+     AC_DEFINE(_XOPEN_SOURCE,          2, Needed to get declarations for msg_control and msg_controllen on Solaris)
+     AC_DEFINE(__EXTENSIONS__,         1, Needed to get declarations for msg_control and msg_controllen on Solaris)
+     ;;
+esac
+
+dnl
+dnl if statfs() takes 2 arguments (Posix) or 4 (Solaris)
+dnl
+AS_IF([test "$ac_cv_func_statfs" = yes], [
+  AC_MSG_CHECKING([number of arguments to statfs()])
+  AC_TRY_COMPILE([#include <unistd.h>
+  #ifdef HAVE_SYS_PARAM_H
+  #include <sys/param.h>
+  #endif
+  #ifdef HAVE_SYS_VFS_H
+  #include <sys/vfs.h>
+  #endif
+  #ifdef HAVE_SYS_MOUNT_H
+  #include <sys/mount.h>
+  #endif
+  #ifdef HAVE_SYS_STATFS_H
+  #include <sys/statfs.h>
+  #endif], [struct statfs st;
+  statfs("/", &st);],[
+    AC_MSG_RESULT([2])
+    AC_DEFINE(STATFS_ARGS, 2, [Number of arguments to statfs()])],[
+    AC_TRY_COMPILE([#include <unistd.h>
+  #ifdef HAVE_SYS_PARAM_H
+  #include <sys/param.h>
+  #endif
+  #ifdef HAVE_SYS_VFS_H
+  #include <sys/vfs.h>
+  #endif
+  #ifdef HAVE_SYS_MOUNT_H
+  #include <sys/mount.h>
+  #endif
+  #ifdef HAVE_SYS_STATFS_H
+  #include <sys/statfs.h>
+  #endif], [struct statfs st;
+  statfs("/", &st, sizeof (st), 0);],[
+      AC_MSG_RESULT([4])
+      AC_DEFINE(STATFS_ARGS, 4, [Number of arguments to statfs()])],[
+      AC_MSG_RESULT(unknown)
+      AC_MSG_ERROR([unable to determine number of arguments to statfs()])])])
+])
+
+dnl
+dnl open takes O_DIRECTORY as an option
+dnl
+AC_MSG_CHECKING([open() option O_DIRECTORY])
+AC_TRY_COMPILE([#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>],
+[open(0, O_DIRECTORY, 0);],[
+	AC_MSG_RESULT([yes])
+	AC_DEFINE(HAVE_OPEN_O_DIRECTORY, 1, [open option O_DIRECTORY])],[
+	AC_MSG_RESULT([no])])
+
+#
+# Check whether to use an included printf
+#
+AC_FUNC_VSNPRINTF_C99
+AC_FUNC_PRINTF_UNIX98
+
+AC_ARG_ENABLE(included-printf,
+              [AS_HELP_STRING([--enable-included-printf],
+                              [use included printf [default=auto]])],
+              enable_included_printf="$enableval")
+
+need_included_printf=no
+if test "x$enable_included_printf" = "xyes" ; then
+  need_included_printf=yes
+fi
+if test "$ac_cv_func_vsnprintf_c99" != "yes" ; then
+  need_included_printf=yes
+fi
+if test "$ac_cv_func_printf_unix98" != "yes" ; then
+  need_included_printf=yes
+fi
+if test "x$ac_cv_sizeof_long_long" = "x8" &&
+   test -z "$glib_cv_long_long_format" ; then
+  need_included_printf=yes
+fi
+
+if test "x$enable_included_printf" = "xno" && 
+   test "x$need_included_printf" = "xyes" ; then
+  AC_MSG_ERROR([
+*** Your C library's printf doesn't appear to have the features that
+*** GLib needs, but you specified --enable-included-printf=no.])
+fi
+
+enable_included_printf=$need_included_printf
+
+AM_CONDITIONAL(HAVE_GOOD_PRINTF, test "$enable_included_printf" != "yes")
+AS_IF([test "$enable_included_printf" != "yes"], [
+  AC_DEFINE(HAVE_GOOD_PRINTF,1,[define to use system printf])
+], [
+  if test -z "$glib_cv_long_long_format" ; then
+    glib_cv_long_long_format="ll"
+  fi
+  AC_DEFINE(HAVE_VASPRINTF,1)
+])
+
+# Checks needed for gnulib vasnprintf
+bh_C_SIGNED
+jm_AC_TYPE_LONG_LONG
+gt_TYPE_LONGDOUBLE
+gt_TYPE_WCHAR_T
+gt_TYPE_WINT_T
+AC_TYPE_SIZE_T
+AC_CHECK_TYPES(ptrdiff_t)
+jm_AC_TYPE_INTMAX_T
+AC_CHECK_FUNCS([snprintf strnlen wcslen wcsnlen mbrtowc wcrtomb])
+AC_FUNC_SNPRINTF_C99
+
+# Check if <sys/select.h> needs to be included for fd_set
+AC_MSG_CHECKING([for fd_set])
+AC_TRY_COMPILE([#include <sys/types.h>],
+        [fd_set readMask, writeMask;], gtk_ok=yes, gtk_ok=no)
+AS_IF([test "$gtk_ok" = "yes"], [
+    AC_MSG_RESULT([yes, found in sys/types.h])
+], [
+    AC_EGREP_HEADER(fd_set, sys/select.h, gtk_ok=yes)
+    if test "$gtk_ok" = "yes"; then
+	# *** FIXME: give it a different name
+        AC_DEFINE(HAVE_SYS_SELECT_H,1,[found fd_set in sys/select.h])
+        AC_MSG_RESULT([yes, found in sys/select.h])
+    else
+	AC_DEFINE(NO_FD_SET,1,[didn't find fd_set])
+	AC_MSG_RESULT(no)
+    fi
+])
+
+dnl Check for nl_langinfo and CODESET
+AC_LANG_SAVE
+AC_LANG_C
+AC_CACHE_CHECK([for nl_langinfo (CODESET)],glib_cv_langinfo_codeset,[
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],
+                       [char *codeset = nl_langinfo (CODESET);])],
+                [glib_cv_langinfo_codeset=yes],
+                [glib_cv_langinfo_codeset=no])])
+if test x$glib_cv_langinfo_codeset = xyes; then
+  AC_DEFINE(HAVE_CODESET,1,[Have nl_langinfo (CODESET)])
+fi
+
+dnl Check for nl_langinfo and LC_TIME parts that are needed in gdatetime.c
+AC_CACHE_CHECK([for nl_langinfo (PM_STR)],glib_cv_langinfo_time,[
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],
+                 [char *str;
+                 str = nl_langinfo (PM_STR);
+                 str = nl_langinfo (D_T_FMT);
+                 str = nl_langinfo (D_FMT);
+                 str = nl_langinfo (T_FMT);
+                 str = nl_langinfo (T_FMT_AMPM);
+                 str = nl_langinfo (MON_1);
+                 str = nl_langinfo (ABMON_12);
+                 str = nl_langinfo (DAY_1);
+                 str = nl_langinfo (ABDAY_7);])],
+                [glib_cv_langinfo_time=yes],
+                [glib_cv_langinfo_time=no])])
+if test x$glib_cv_langinfo_time = xyes; then
+  AC_DEFINE(HAVE_LANGINFO_TIME,1,[Have nl_langinfo (PM_STR)])
+fi
+
+dnl Check for nl_langinfo and _NL_CTYPE_OUTDIGITn_MB
+AC_CACHE_CHECK([for nl_langinfo (_NL_CTYPE_OUTDIGITn_MB)], glib_cv_langinfo_outdigit,[
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <langinfo.h>],
+                [char *str;
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT1_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT2_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT3_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT4_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT5_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT6_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT7_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT8_MB);
+                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT9_MB);])],
+                [glib_cv_langinfo_outdigit=yes],
+                [glib_cv_langinfo_outdigit=no])])
+if test x$glib_cv_langinfo_outdigit = xyes; then
+  AC_DEFINE(HAVE_LANGINFO_OUTDIGIT,1,[Have nl_langinfo (_NL_CTYPE_OUTDIGITn_MB)])
+fi
+AC_LANG_RESTORE
+
+dnl ****************************************
+dnl *** posix_memalign                   ***
+dnl ****************************************
+AC_MSG_CHECKING(for a compliant posix_memalign() implementation)
+AC_CACHE_VAL(glib_cv_compliant_posix_memalign,[
+    glib_cv_compliant_posix_memalign=0
+    if test "$ac_cv_func_posix_memalign" = "yes" ; then
+	AC_TRY_RUN([
+                #define _XOPEN_SOURCE 600
+                #include <stdlib.h> /* posix_memalign() should be defined here */
+                /* some systems break if #include <malloc.h> used */
+		static void test_memalign (size_t boundary, size_t size) {
+		    void *mem = 0;
+		    if (posix_memalign (&mem, boundary, size) != 0 || !mem)
+			exit (1);
+                    else
+                      free (mem);
+		}
+		int main() {
+		    test_memalign (  128,   128 - 2 * sizeof (void*));
+		    test_memalign (  256,   256 - 2 * sizeof (void*));
+		    test_memalign (  512,   512 - 2 * sizeof (void*));
+		    test_memalign ( 1024,  1024 - 2 * sizeof (void*));
+		    test_memalign ( 2048,  2048 - 2 * sizeof (void*));
+		    test_memalign ( 4096,  4096 - 2 * sizeof (void*));
+		    test_memalign ( 8192,  8192 - 2 * sizeof (void*));
+		    test_memalign (16384, 16384 - 2 * sizeof (void*));
+		    test_memalign (32768, 32768 - 2 * sizeof (void*));
+		    exit (0); /* success */
+		}
+		],
+	    [glib_cv_compliant_posix_memalign=1], [], [:])
+      :
+    fi
+    ])
+AS_IF([test "$glib_cv_compliant_posix_memalign" = "1"], [
+    AC_MSG_RESULT(yes)
+    AC_DEFINE(POSIX_MEMALIGN_WITH_COMPLIANT_ALLOCS, 1, [define if posix_memalign() can allocate any size])
+], [
+    AC_MSG_RESULT(no)
+])
+
+
+dnl ****************************************
+dnl *** strlcpy/strlcat                  ***
+dnl ****************************************
+# Check for strlcpy
+AC_CACHE_CHECK([for OpenBSD strlcpy/strlcat],glib_cv_have_strlcpy,[
+AC_TRY_RUN([#include <stdlib.h>
+#include <string.h>
+int main() {
+  char p[10];
+  (void) strlcpy (p, "hi", 10);
+  if (strlcat (p, "bye", 0) != 3) 
+    return 1;
+  return 0;
+}], glib_cv_have_strlcpy=yes, 
+    glib_cv_have_strlcpy=no,
+    glib_cv_have_strlcpy=no)])
+if test "$glib_cv_have_strlcpy" = "yes"; then
+    AC_DEFINE(HAVE_STRLCPY,1,[Have functions strlcpy and strlcat])
+fi
+  
+
+dnl **********************
+dnl *** va_copy checks ***
+dnl **********************
+dnl we currently check for all three va_copy possibilities, so we get
+dnl all results in config.log for bug reports.
+AC_CACHE_CHECK([for an implementation of va_copy()],glib_cv_va_copy,[
+	AC_LINK_IFELSE([AC_LANG_SOURCE([[#include <stdarg.h>
+#include <stdlib.h>
+	void f (int i, ...) {
+	va_list args1, args2;
+	va_start (args1, i);
+	va_copy (args2, args1);
+	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+	  exit (1);
+	va_end (args1); va_end (args2);
+	}
+	int main() {
+	  f (0, 42);
+	  return 0;
+	}]])],
+	[glib_cv_va_copy=yes],
+	[glib_cv_va_copy=no])
+])
+AC_CACHE_CHECK([for an implementation of __va_copy()],glib_cv___va_copy,[
+	AC_LINK_IFELSE([AC_LANG_SOURCE([[#include <stdarg.h>
+#include <stdlib.h>
+	void f (int i, ...) {
+	va_list args1, args2;
+	va_start (args1, i);
+	__va_copy (args2, args1);
+	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+	  exit (1);
+	va_end (args1); va_end (args2);
+	}
+	int main() {
+	  f (0, 42);
+	  return 0;
+	}]])],
+	[glib_cv___va_copy=yes],
+	[glib_cv___va_copy=no])
+])
+
+if test "x$glib_cv_va_copy" = "xyes"; then
+  g_va_copy_func=va_copy
+else if test "x$glib_cv___va_copy" = "xyes"; then
+  g_va_copy_func=__va_copy
+fi
+fi
+
+if test -n "$g_va_copy_func"; then
+  AC_DEFINE_UNQUOTED(G_VA_COPY,$g_va_copy_func,[A 'va_copy' style function])
+fi
+
+AC_CACHE_CHECK([whether va_lists can be copied by value],glib_cv_va_val_copy,[
+	AC_TRY_RUN([#include <stdarg.h>
+#include <stdlib.h> 
+	void f (int i, ...) {
+	va_list args1, args2;
+	va_start (args1, i);
+	args2 = args1;
+	if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+	  exit (1);
+	va_end (args1); va_end (args2);
+	}
+	int main() {
+	  f (0, 42);
+	  return 0;
+	}],
+	[glib_cv_va_val_copy=yes],
+	[glib_cv_va_val_copy=no],
+	[glib_cv_va_val_copy=yes])
+])
+
+AS_IF([ test "x$glib_cv_va_val_copy" = "xno"], [
+  AC_DEFINE(G_VA_COPY_AS_ARRAY,1, ['va_lists' cannot be copies as values])
+])
+
+dnl ***********************
+dnl *** g_module checks ***
+dnl ***********************
+G_MODULE_LIBS=
+G_MODULE_LIBS_EXTRA=
+G_MODULE_PLUGIN_LIBS=
+if test x"$glib_native_win32" = xyes; then
+  dnl No use for this on Win32
+  G_MODULE_LDFLAGS=
+else
+  export SED
+  G_MODULE_LDFLAGS=`(./libtool --config; echo eval echo \\$export_dynamic_flag_spec) | sh`
+fi
+dnl G_MODULE_IMPL= don't reset, so cmd-line can override
+G_MODULE_NEED_USCORE=0
+G_MODULE_BROKEN_RTLD_GLOBAL=0
+G_MODULE_HAVE_DLERROR=0
+dnl *** force native WIN32 shared lib loader 
+if test -z "$G_MODULE_IMPL"; then
+  case "$host" in
+  *-*-mingw*|*-*-cygwin*) G_MODULE_IMPL=G_MODULE_IMPL_WIN32 ;;
+  esac
+fi
+dnl *** force native AIX library loader
+dnl *** dlopen() filepath must be of the form /path/libname.a(libname.so)
+if test -z "$G_MODULE_IMPL"; then
+  case "$host" in
+  *-*-aix*) G_MODULE_IMPL=G_MODULE_IMPL_AR ;;
+  esac
+fi
+dnl *** dlopen() and dlsym() in system libraries
+AS_IF([ test -z "$G_MODULE_IMPL"], [
+	AC_CHECK_FUNC(dlopen,
+		      [AC_CHECK_FUNC(dlsym,
+			             [G_MODULE_IMPL=G_MODULE_IMPL_DL],[])],
+		      [])
+])
+dnl *** NSLinkModule (dyld) in system libraries (Darwin)
+AS_IF([ test -z "$G_MODULE_IMPL" ], [
+ 	AC_CHECK_FUNC(NSLinkModule,
+		      [G_MODULE_IMPL=G_MODULE_IMPL_DYLD
+		       G_MODULE_NEED_USCORE=1],
+		      [])
+])
+dnl *** dlopen() and dlsym() in libdl
+AS_IF([ test -z "$G_MODULE_IMPL"], [
+	AC_CHECK_LIB(dl, dlopen,
+		     [AC_CHECK_LIB(dl, dlsym,
+			           [G_MODULE_LIBS=-ldl
+		                   G_MODULE_IMPL=G_MODULE_IMPL_DL],[])],
+		     [])
+])
+dnl *** additional checks for G_MODULE_IMPL_DL
+AS_IF([ test "$G_MODULE_IMPL" = "G_MODULE_IMPL_DL" ], [
+	LIBS_orig="$LIBS"
+	LDFLAGS_orig="$LDFLAGS"
+	LIBS="$G_MODULE_LIBS $LIBS"
+	LDFLAGS="$LDFLAGS $G_MODULE_LDFLAGS"
+dnl *** check for OSF1/5.0 RTLD_GLOBAL brokenness
+	echo "void glib_plugin_test(void) { }" > plugin.c
+	${SHELL} ./libtool --mode=compile --tag=CC ${CC} ${CFLAGS} \
+		${CPPFLAGS} -c -o plugin.lo plugin.c >/dev/null 2>&1
+	${SHELL} ./libtool --mode=link --tag=CC ${CC} ${CFLAGS} \
+		${LDFLAGS} -module -o plugin.la -export-dynamic \
+		-shrext ".o" -avoid-version plugin.lo \
+		-rpath /dont/care >/dev/null 2>&1
+	eval `./libtool --config | grep ^objdir`
+	AC_CACHE_CHECK([for RTLD_GLOBAL brokenness],
+		glib_cv_rtldglobal_broken,[
+		AC_TRY_RUN([
+#include <dlfcn.h>
+#ifndef RTLD_GLOBAL
+#  define RTLD_GLOBAL 0
+#endif
+#ifndef RTLD_LAZY
+#  define RTLD_LAZY 0
+#endif
+int glib_plugin_test;
+int main () {
+    void *handle, *global, *local;
+    global = &glib_plugin_test;
+    handle = dlopen ("./$objdir/plugin.o", RTLD_GLOBAL | RTLD_LAZY);
+    if (!handle) return 0;
+    local = dlsym (handle, "glib_plugin_test");
+    return global == local;
+}                       ],
+			[glib_cv_rtldglobal_broken=no],
+			[glib_cv_rtldglobal_broken=yes],
+			[glib_cv_rtldglobal_broken=no])
+		rm -f plugin.c plugin.o plugin.lo plugin.la ${objdir}/plugin.*
+		rmdir ${objdir} 2>/dev/null
+	])
+	if test "x$glib_cv_rtldglobal_broken" = "xyes"; then
+  		G_MODULE_BROKEN_RTLD_GLOBAL=1
+	else
+  		G_MODULE_BROKEN_RTLD_GLOBAL=0
+	fi
+dnl *** check whether we need preceeding underscores
+	AC_CACHE_CHECK([for preceeding underscore in symbols],
+		glib_cv_uscore,[
+		AC_TRY_RUN([#include <dlfcn.h>
+                int glib_underscore_test (void) { return 42; }
+		int main() {
+		  void *f1 = (void*)0, *f2 = (void*)0, *handle;
+		  handle = dlopen ((void*)0, 0);
+		  if (handle) {
+		    f1 = dlsym (handle, "glib_underscore_test");
+		    f2 = dlsym (handle, "_glib_underscore_test");
+		  } return (!f2 || f1);
+		}],
+			[glib_cv_uscore=yes],
+			[glib_cv_uscore=no],
+			[])
+		rm -f plugin.c plugin.$ac_objext plugin.lo
+	])
+        GLIB_ASSERT_SET(glib_cv_uscore)
+	if test "x$glib_cv_uscore" = "xyes"; then
+  		G_MODULE_NEED_USCORE=1
+	else
+  		G_MODULE_NEED_USCORE=0
+	fi
+
+	LDFLAGS="$LDFLAGS_orig"
+dnl *** check for having dlerror()
+	AC_CHECK_FUNC(dlerror,
+		[G_MODULE_HAVE_DLERROR=1],
+		[G_MODULE_HAVE_DLERROR=0])
+	LIBS="$LIBS_orig"
+])
+dnl *** done, have we got an implementation?
+if test -z "$G_MODULE_IMPL"; then
+	G_MODULE_IMPL=0
+        G_MODULE_SUPPORTED=false
+else
+        G_MODULE_SUPPORTED=true
+fi
+
+AC_MSG_CHECKING(for the suffix of module shared libraries)
+export SED
+shrext_cmds=`./libtool --config | grep '^shrext_cmds='`
+eval $shrext_cmds
+module=yes eval std_shrext=$shrext_cmds
+# chop the initial dot
+glib_gmodule_suffix=`echo $std_shrext | sed 's/^\.//'`
+AC_MSG_RESULT(.$glib_gmodule_suffix)
+# any reason it may fail?
+if test "x$glib_gmodule_suffix" = x; then
+	AC_MSG_ERROR(Cannot determine shared library suffix from libtool)
+fi
+ 
+AC_SUBST(G_MODULE_SUPPORTED)
+AC_SUBST(G_MODULE_IMPL)
+AC_SUBST(G_MODULE_LIBS)
+AC_SUBST(G_MODULE_LIBS_EXTRA)
+AC_SUBST(G_MODULE_PLUGIN_LIBS)
+AC_SUBST(G_MODULE_LDFLAGS)
+AC_SUBST(G_MODULE_HAVE_DLERROR)
+AC_SUBST(G_MODULE_BROKEN_RTLD_GLOBAL)
+AC_SUBST(G_MODULE_NEED_USCORE)
+AC_SUBST(GLIB_DEBUG_FLAGS)
+
+dnl **********************
+dnl *** g_spawn checks ***
+dnl **********************
+
+AC_MSG_CHECKING(for gspawn implementation)
+case "$host" in
+  *-*-mingw*)
+    GSPAWN=gspawn-win32.lo
+    ;;
+  *)
+    GSPAWN=gspawn.lo
+    ;;    
+esac
+AC_MSG_RESULT($GSPAWN)
+AC_SUBST(GSPAWN)
+
+dnl *************************
+dnl *** GIOChannel checks ***
+dnl *************************
+
+AC_MSG_CHECKING(for GIOChannel implementation)
+case "$host" in
+  *-*-mingw*)
+    GIO=giowin32.lo
+    ;;
+  *)
+    GIO=giounix.lo
+    ;;    
+esac
+AC_MSG_RESULT($GIO)
+AC_SUBST(GIO)
+
+dnl *********************************
+dnl *** Directory for GIO modules ***
+dnl *********************************
+
+AC_ARG_WITH(gio-module-dir,
+           [AS_HELP_STRING([--with-gio-module-dir=DIR],
+                           [load gio modules from this directory [LIBDIR/gio/modules]])],
+           [],
+	   [with_gio_module_dir='${libdir}/gio/modules'])
+GIO_MODULE_DIR=$with_gio_module_dir
+AC_SUBST(GIO_MODULE_DIR)
+
+dnl **********************************
+dnl *** Check for libselinux (GIO) ***
+dnl **********************************
+AC_ARG_ENABLE(selinux,
+              AS_HELP_STRING([--disable-selinux],
+                             [build without selinux support]))
+msg_selinux=no
+SELINUX_LIBS=
+AS_IF([ test "x$enable_selinux" != "xno"], [
+
+ AC_CHECK_LIB(selinux, is_selinux_enabled,
+   [AC_CHECK_HEADERS(selinux/selinux.h,
+     [AC_CHECK_LIB(selinux, lgetfilecon_raw, 
+       [AC_DEFINE(HAVE_SELINUX, 1, [Define to 1 if libselinux is available])
+        SELINUX_LIBS="-lselinux"
+        msg_selinux=yes])
+     ])
+   ])
+])
+AC_SUBST(SELINUX_LIBS)
+
+dnl *****************************
+dnl ** Check for inotify (GIO) **
+dnl *****************************
+inotify_support=no
+AC_CHECK_HEADERS([sys/inotify.h],
+[
+  AC_CHECK_FUNCS(inotify_init1, [inotify_support=yes], [inotify_support=no])
+])
+
+AM_CONDITIONAL(HAVE_INOTIFY, [test "$inotify_support" = "yes"])
+
+dnl ****************************
+dnl ** Check for kqueue (GIO) **
+dnl ****************************
+kqueue_support=no
+AC_CHECK_HEADERS([sys/event.h],
+[
+	AC_CHECK_FUNCS(kqueue kevent, [kqueue_support=yes])
+])
+
+AM_CONDITIONAL(HAVE_KQUEUE, [test "$kqueue_support" = "yes"])
+
+dnl ****************************
+dnl *** Checks for FAM (GIO) ***
+dnl ****************************
+
+should_disable_fam=no
+
+AC_ARG_ENABLE(fam,
+              AS_HELP_STRING([--disable-fam],
+                             [don't use fam for file system monitoring]),
+                         [
+                                if test "x$enable_fam" = "xno"; then
+                                        should_disable_fam=yes
+                                fi
+                         ]
+                         )
+fam_support=no
+FAM_LIBS=
+if test "x$should_disable_fam" = "xno"; then
+AC_CHECK_LIB(fam, FAMOpen,
+  [AC_CHECK_HEADERS(fam.h,
+    [AC_DEFINE(HAVE_FAM, [], [Define if we have FAM])
+     AC_CHECK_LIB(fam, FAMNoExists,
+     		  AC_DEFINE(HAVE_FAM_NO_EXISTS, [], [Define if we have FAMNoExists in fam]))
+     FAM_LIBS="-lfam"]
+     fam_support=yes,
+    AC_MSG_WARN(*** FAM support will not be built (header files not found) ***))],
+  AC_MSG_WARN(*** FAM support will not be built (FAM library not found) ***))
+AC_SUBST(FAM_LIBS)
+fi
+AM_CONDITIONAL(HAVE_FAM, [test "$fam_support" = "yes"])
+
+
+dnl *****************************
+dnl *** Check for xattr (GIO) ***
+dnl *****************************
+AC_ARG_ENABLE(xattr,
+              AS_HELP_STRING([--disable-xattr], [build without xattr support]))
+msg_xattr=no
+XATTR_LIBS=
+AS_IF([ test "x$enable_xattr" != "xno"], [
+
+dnl either glibc or libattr can provide xattr support
+
+dnl for both of them, we check for getxattr being in
+dnl the library and a valid xattr header.
+
+dnl try glibc
+ AC_CHECK_LIB(c, getxattr,
+   [AC_CHECK_HEADERS(sys/xattr.h,
+     [AC_DEFINE(HAVE_XATTR, 1, [Define to 1 if xattr is available])
+      msg_xattr=yes])
+   ])
+
+  AS_IF([ test "x$msg_xattr" != "xyes"], [
+dnl   failure. try libattr
+   AC_CHECK_LIB(attr, getxattr,
+      [AC_CHECK_HEADERS(attr/xattr.h,
+       [AC_DEFINE(HAVE_XATTR, 1, [Define to 1 if xattr is available])
+        XATTR_LIBS="-lattr"
+        msg_xattr=yes])
+      ])
+  ])
+
+  AS_IF([ test "x$msg_xattr" = "xyes"], [
+    AC_MSG_CHECKING([for XATTR_NOFOLLOW])
+    AC_TRY_COMPILE([
+      #include <stdio.h>
+      #ifdef HAVE_SYS_TYPES_H
+      #include <sys/types.h>
+      #endif
+      #ifdef HAVE_SYS_XATTR_H
+      #include <sys/xattr.h>
+      #elif HAVE_ATTR_XATTR_H
+      #include <attr/xattr.h>
+      #endif
+    ],
+    [ssize_t len = getxattr("", "", NULL, 0, 0, XATTR_NOFOLLOW);],
+    [
+      AC_DEFINE([HAVE_XATTR_NOFOLLOW], [1], [Define to 1 if xattr API uses XATTR_NOFOLLOW])
+      AC_MSG_RESULT([yes])
+    ],
+    [AC_MSG_RESULT([no])]
+    )
+  ])
+])
+AC_SUBST(XATTR_LIBS)
+
+dnl ************************
+dnl *** check for libelf ***
+dnl ************************
+AC_ARG_ENABLE(libelf,
+              AS_HELP_STRING([--disable-libelf], [build without libelf support]))
+AS_IF([ test "x$enable_libelf" != "xno"],[
+PKG_CHECK_MODULES([LIBELF], [libelf >= 0.8.12], [have_libelf=yes], [have_libelf=maybe])
+AS_IF([ test $have_libelf = maybe ], [
+  glib_save_LIBS=$LIBS
+  AC_CHECK_LIB([elf], [elf_begin], [:], [have_libelf=no])
+  AC_CHECK_LIB([elf], [elf_getshdrstrndx], [:], [have_libelf=no])
+  AC_CHECK_LIB([elf], [elf_getshdrnum], [:], [have_libelf=no])
+  AC_CHECK_HEADER([libelf.h], [:], [have_libelf=no])
+  LIBS=$glib_save_LIBS
+
+  if test $have_libelf != no; then
+    LIBELF_LIBS=-lelf
+    have_libelf=yes
+  fi
+])
+])
+
+if test x$have_libelf = xyes; then
+  AC_DEFINE(HAVE_LIBELF, 1, [Define if libelf is available])
+fi
+
+dnl ************************
+dnl *** check for libmount ***
+dnl ************************
+
+dnl The fallback code doesn't really implement the same behaviors - e.g.
+dnl so on linux we want to require libmount unless specifically disabled
+dnl
+enable_libmount_default=${glib_os_linux:-no}
+AC_ARG_ENABLE(libmount,
+              [AS_HELP_STRING([--enable-libmount],
+                              [build with libmount support [default for Linux]])],,
+              [enable_libmount=$enable_libmount_default])
+AS_IF([ test "x$enable_libmount" = "xyes"],[
+PKG_CHECK_MODULES([LIBMOUNT], [mount >= 2.28], [have_libmount=yes], [have_libmount=maybe])
+AS_IF([ test $have_libmount = maybe ], [
+  glib_save_LIBS=$LIBS
+  AC_CHECK_HEADER([libmount/libmount.h], [:], [have_libmount=no])
+  LIBS=$glib_save_LIBS
+
+  if test $have_libmount != no; then
+    LIBMOUNT_LIBS=-lmount
+    have_libmount=yes
+  fi
+])
+if test $have_libmount = no ; then
+   AC_MSG_ERROR([*** Could not find libmount])
+fi
+])
+
+if test x$have_libmount = xyes; then
+  AC_DEFINE(HAVE_LIBMOUNT, 1, [Define if libmount is available])
+fi
+AM_CONDITIONAL(HAVE_LIBMOUNT, [test x$have_libmount = xyes])
+
+dnl ****************************************
+dnl *** platform dependent source checks ***
+dnl ****************************************
+
+AC_MSG_CHECKING(for platform-dependent source)
+case "$host" in
+  *-*-cygwin*|*-*-mingw*)
+    PLATFORMDEP=gwin32.lo
+    ;;
+  *)
+    PLATFORMDEP=
+    ;;    
+esac
+AC_MSG_RESULT($PLATFORMDEP)
+AC_SUBST(PLATFORMDEP)
+
+AC_MSG_CHECKING([whether to compile timeloop])
+case "$host" in
+  *-*-cygwin*|*-*-mingw*|*-*-minix)
+    enable_timeloop=no
+    ;;
+  *)
+    enable_timeloop=yes
+    ;;    
+esac
+AC_MSG_RESULT($enable_timeloop)
+AM_CONDITIONAL(ENABLE_TIMELOOP, test x$enable_timeloop = xyes)
+
+AC_MSG_CHECKING([if building for some Win32 platform])
+case "$host" in
+  *-*-mingw*|*-*-cygwin*)
+    platform_win32=yes
+    ;;
+  *)
+    platform_win32=no
+    ;;
+esac
+AC_MSG_RESULT($platform_win32)
+AM_CONDITIONAL(PLATFORM_WIN32, test x$platform_win32 = xyes)
+
+dnl ***********************
+dnl *** g_thread checks ***
+dnl ***********************
+
+AC_ARG_WITH(threads,
+           [AS_HELP_STRING([--with-threads=@<:@posix/win32@:>@],
+                           [specify a thread implementation to use])],
+           [],
+           [with_threads=yes])
+
+dnl error and warning message
+dnl *************************
+
+THREAD_NO_IMPLEMENTATION="No thread implementation found."
+
+FLAG_DOES_NOT_WORK="I can't find the MACRO to enable thread safety on your
+                platform (normally it's "_REENTRANT"). I'll not use any flag on
+                compilation now, but then your programs might not work.
+                Please provide information on how it is done on your system."
+
+LIBS_NOT_FOUND_1="I can't find the libraries for the thread implementation
+                 "
+
+LIBS_NOT_FOUND_2=". Please choose another thread implementation or
+                  provide information on your thread implementation."
+
+FUNC_NO_GETPWUID_R="the 'g_get_(user_name|real_name|home_dir|tmp_dir)'
+		functions will not be MT-safe during their first call because
+		there is no working 'getpwuid_r' on your system."
+
+FUNC_NO_LOCALTIME_R="the 'g_date_set_time' function will not be MT-safe
+		because there is no 'localtime_r' on your system."
+
+AIX_COMPILE_INFO="AIX's C compiler needs to be called by a different name, when
+		linking threaded applications. As GLib cannot do that 
+		automatically, you will get an linkg error everytime you are 
+		not using the right compiler. In that case you have to relink 
+		with the right compiler. Ususally just '_r' is appended 
+		to the compiler name."
+
+dnl determination of thread implementation
+dnl ***************************************
+
+AC_MSG_CHECKING(for thread implementation)
+
+have_threads=no
+AS_IF([ test "x$with_threads" = xyes || test "x$with_threads" = xposix], [
+        AS_IF([ test "x$have_threads" = xno], [
+                AC_TRY_COMPILE([#include <pthread.h>],
+			[pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;],
+			have_threads=posix)
+	])
+	# Tru64Unix requires -pthread to find pthread.h. See #103020
+	if test "x$have_threads" = xno; then
+		glib_save_CPPFLAGS="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS -pthread"
+		AC_TRY_COMPILE([#include <pthread.h>],
+		       [pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;],
+		       have_threads=posix)
+		CPPFLAGS="$glib_save_CPPFLAGS"
+        fi
+])
+if test "x$with_threads" = xyes || test "x$with_threads" = xwin32; then
+        case $host in
+                *-*-mingw*)
+                have_threads=win32
+                ;;
+        esac
+fi
+
+if test "x$have_threads" = xno; then
+        AC_MSG_RESULT(none available)
+        AC_MSG_ERROR($THREAD_NO_IMPLEMENTATION)
+else
+        AC_MSG_RESULT($have_threads)
+fi
+
+
+dnl determination of G_THREAD_CFLAGS
+dnl ********************************
+
+G_THREAD_LIBS=
+G_THREAD_LIBS_EXTRA=
+G_THREAD_CFLAGS=
+
+dnl
+dnl Test program for basic POSIX threads functionality
+dnl
+m4_define([glib_thread_test],[
+#include <pthread.h> 
+int check_me = 0;
+void* func(void* data) {check_me = 42; return &check_me;}
+int main()
+ { pthread_t t; 
+   void *ret;
+   pthread_create (&t, $1, func, 0);
+   pthread_join (t, &ret);
+   return (check_me != 42 || ret != &check_me);
+}])
+
+AS_IF([ test x"$have_threads" = xposix], [
+  # First we test for posix, whether -pthread or -pthreads do the trick as 
+  # both CPPFLAG and LIBS. 
+  # One of them does for most gcc versions and some other platforms/compilers
+  # too and could be considered as the canonical way to go. 
+  case $host in
+    *-*-cygwin*|*-*-darwin*)
+       # skip cygwin and darwin -pthread or -pthreads test
+       ;;
+    *-solaris*)
+      # These compiler/linker flags work with both Sun Studio and gcc
+      # Sun Studio expands -mt to -D_REENTRANT and -lthread
+      # gcc expands -pthreads to -D_REENTRANT -D_PTHREADS -lpthread
+      G_THREAD_CFLAGS="-D_REENTRANT -D_PTHREADS"
+      G_THREAD_LIBS="-lpthread -lthread"
+      ;;
+    *)
+      for flag in pthread pthreads mt; do
+        glib_save_CFLAGS="$CFLAGS"
+        CFLAGS="$CFLAGS -$flag"
+        AC_TRY_RUN(glib_thread_test(0),
+                   glib_flag_works=yes,
+                   glib_flag_works=no,
+                   [AC_LINK_IFELSE([AC_LANG_SOURCE(glib_thread_test(0))],
+                                   glib_flag_works=yes,
+                                   glib_flag_works=no)])
+        CFLAGS="$glib_save_CFLAGS"
+        if test $glib_flag_works = yes ; then
+           G_THREAD_CFLAGS=-$flag
+        G_THREAD_LIBS=-$flag
+        break;
+        fi
+      done
+       ;;
+  esac
+])
+
+AS_IF([ test x"$G_THREAD_CFLAGS" = x], [
+
+  # The canonical -pthread[s] does not work. Try something different.
+
+  case $host in
+	*-aix*)
+		if test x"$GCC" = xyes; then
+			# GCC 3.0 and above needs -pthread. 
+			# Should be coverd by the case above.
+			# GCC 2.x and below needs -mthreads
+			G_THREAD_CFLAGS="-mthreads"		
+			G_THREAD_LIBS=$G_THREAD_CFLAGS
+		else 
+			# We are probably using the aix compiler. Normaly a 
+			# program would have to be compiled with the _r variant
+			# of the corresponding compiler, but we as GLib cannot 
+			# do that: but the good news is that for compiling the
+			# only difference is the added -D_THREAD_SAFE compile 
+			# option. This is according to the "C for AIX User's 
+			# Guide".
+			G_THREAD_CFLAGS="-D_THREAD_SAFE"
+		fi
+		;;
+	*-sysv5uw7*) # UnixWare 7 
+		# We are not using gcc with -pthread. Catched above.
+		G_THREAD_CFLAGS="-Kthread"
+		G_THREAD_LIBS=$G_THREAD_CFLAGS
+		;;
+	*-mingw*)
+		# No flag needed when using MSVCRT.DLL
+		G_THREAD_CFLAGS=""
+		;;
+	*)
+		G_THREAD_CFLAGS="-D_REENTRANT" # good default guess otherwise
+		;;
+  esac
+])
+
+# if we are not finding the localtime_r function, then we probably are
+# not using the proper multithread flag
+
+glib_save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $G_THREAD_CFLAGS"
+
+# First we test, whether localtime_r is declared in time.h
+# directly. Then we test whether a macro localtime_r exists, in
+# which case localtime_r in the test program is replaced and thus
+# if we still find localtime_r in the output, it is not defined as 
+# a macro.
+
+AC_EGREP_CPP([[^a-zA-Z1-9_]localtime_r[^a-zA-Z1-9_]], [#include <time.h>], ,
+  [AC_EGREP_CPP([[^a-zA-Z1-9_]localtime_r[^a-zA-Z1-9_]], [#include <time.h> 
+							   localtime_r(a,b)],
+  		   AC_MSG_WARN($FLAG_DOES_NOT_WORK))])
+
+CPPFLAGS="$glib_save_CPPFLAGS"
+
+AC_MSG_CHECKING(thread related cflags)
+AC_MSG_RESULT($G_THREAD_CFLAGS)
+CPPFLAGS="$CPPFLAGS $G_THREAD_CFLAGS"
+
+dnl determination of G_THREAD_LIBS
+dnl ******************************
+
+AS_IF([test x$have_threads = xposix], [
+	  glib_save_CPPFLAGS="$CPPFLAGS"
+	  CPPFLAGS="$CPPFLAGS $GTHREAD_COMPILE_IMPL_DEFINES"
+          AS_IF([ test x"$G_THREAD_LIBS" = x ], [
+            case $host in
+              *-aix*)
+                # We are not using gcc (would have set G_THREAD_LIBS) and thus 
+                # probably using the aix compiler.
+		AC_MSG_WARN($AIX_COMPILE_INFO)
+                ;;
+              *)
+                G_THREAD_LIBS=error
+	        glib_save_LIBS="$LIBS"
+	        for thread_lib in "" pthread pthread32 pthreads thread; do
+			if test x"$thread_lib" = x; then
+				add_thread_lib=""
+				IN=""
+			else
+				add_thread_lib="-l$thread_lib"
+				IN=" in -l$thread_lib"
+			fi
+			if test x"$have_threads" = xposix; then
+				defattr=0
+			else
+				defattr=pthread_attr_default
+			fi
+			
+			LIBS="$add_thread_lib $glib_save_LIBS"
+			
+			AC_MSG_CHECKING(for pthread_create/pthread_join$IN)
+			AC_TRY_RUN(glib_thread_test($defattr),
+                                   glib_result=yes,
+                                   glib_result=no,
+                                   [AC_LINK_IFELSE([AC_LANG_SOURCE(glib_thread_test($defattr))],
+                                                   glib_result=yes,
+                                                   glib_result=no)])
+                        AC_MSG_RESULT($glib_result)
+			
+                        if test "$glib_result" = "yes" ; then
+			  G_THREAD_LIBS="$add_thread_lib"
+                          break
+                        fi
+		done
+		if test "x$G_THREAD_LIBS" = xerror; then
+		  AC_MSG_ERROR($LIBS_NOT_FOUND_1$have_threads$LIBS_NOT_FOUND_2)
+		fi 
+		LIBS="$glib_save_LIBS"
+                ;;
+            esac
+	  ])
+
+	  g_threads_impl="POSIX"
+          AC_DEFINE([THREADS_POSIX], [1], [Use pthreads])
+	  AC_SUBST(GTHREAD_COMPILE_IMPL_DEFINES)
+          CPPFLAGS="$glib_save_CPPFLAGS"
+], [test x$have_threads = xwin32], [
+           AC_DEFINE([THREADS_WIN32], [1], [Use w32 threads])
+	   g_threads_impl="WIN32"
+], [
+           AC_DEFINE([THREADS_NONE], [1], [Use no threads])
+	   g_threads_impl="NONE"
+           G_THREAD_LIBS=error
+])
+AM_CONDITIONAL(THREADS_POSIX, [test "$g_threads_impl" = "POSIX"])
+AM_CONDITIONAL(THREADS_WIN32, [test "$g_threads_impl" = "WIN32"])
+AM_CONDITIONAL(THREADS_NONE, [test "$g_threads_impl" = "NONE"])
+
+if test "x$G_THREAD_LIBS" = xerror; then
+        AC_MSG_ERROR($LIBS_NOT_FOUND_1$have_threads$LIBS_NOT_FOUND_2)
+fi
+
+AC_MSG_CHECKING(thread related libraries)
+AC_MSG_RESULT($G_THREAD_LIBS)
+
+dnl check for mt safe function variants and some posix functions
+dnl ************************************************************
+
+glib_save_LIBS="$LIBS"
+# we are not doing the following for now, as this might require glib 
+# to always be linked with the thread libs on some platforms. 
+# LIBS="$LIBS $G_THREAD_LIBS"
+AC_CHECK_FUNCS(localtime_r gmtime_r getpwuid_r getgrgid_r)
+
+LIBS="$G_THREAD_LIBS $LIBS"
+AS_IF([ test x"$have_threads" = xposix], [
+        glib_save_CPPFLAGS="$CPPFLAGS"
+        CPPFLAGS="$CPPFLAGS $GTHREAD_COMPILE_IMPL_DEFINES"
+        # This is not AC_CHECK_FUNC to also work with function
+        # name mangling in header files.
+        AC_MSG_CHECKING(for pthread_attr_setstacksize)
+        AC_LINK_IFELSE(
+            [AC_LANG_PROGRAM(
+                [#include <pthread.h>],
+                [pthread_attr_t t; pthread_attr_setstacksize(&t,0)])],
+            [AC_MSG_RESULT(yes)
+             AC_DEFINE(HAVE_PTHREAD_ATTR_SETSTACKSIZE,1,
+                [Have function pthread_attr_setstacksize])],
+            [AC_MSG_RESULT(no)])
+        AC_MSG_CHECKING(for pthread_condattr_setclock)
+        AC_LINK_IFELSE(
+            [AC_LANG_PROGRAM(
+                [#include <pthread.h>],
+                [pthread_condattr_t a; pthread_condattr_setclock(&a,0)])],
+            [AC_MSG_RESULT(yes)
+             AC_DEFINE(HAVE_PTHREAD_CONDATTR_SETCLOCK,1,
+                [Have function pthread_condattr_setclock])],
+            [AC_MSG_RESULT(no)])
+        AC_MSG_CHECKING(for pthread_cond_timedwait_relative_np)
+        AC_LINK_IFELSE(
+            [AC_LANG_PROGRAM(
+                [#include <pthread.h>],
+                [pthread_cond_timedwait_relative_np(NULL, NULL, NULL)])],
+            [AC_MSG_RESULT(yes)
+             AC_DEFINE(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP,1,
+                [Have function pthread_cond_timedwait_relative_np])],
+            [AC_MSG_RESULT(no)])
+        dnl Sets thread names on OS X 10.6, iOS 3.2 (and higher)
+        AC_MSG_CHECKING(for pthread_setname_np(const char*))
+        AC_LINK_IFELSE(
+            [AC_LANG_PROGRAM(
+                [#include <pthread.h>],
+                [pthread_setname_np("example")])],
+            [AC_MSG_RESULT(yes)
+             AC_DEFINE(HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID,1,
+                [Have function pthread_setname_np(const char*)])],
+            [AC_MSG_RESULT(no)])
+        dnl Sets thread names on Solaris 11.3 & higher
+        AC_MSG_CHECKING(for pthread_setname_np(pthread_t, const char*))
+        AC_LINK_IFELSE(
+            [AC_LANG_PROGRAM(
+                [#include <pthread.h>],
+                [pthread_setname_np(pthread_self(), "example")])],
+            [AC_MSG_RESULT(yes)
+             AC_DEFINE(HAVE_PTHREAD_SETNAME_NP_WITH_TID,1,
+                [Have function pthread_setname_np(pthread_t, const char*)])],
+            [AC_MSG_RESULT(no)])
+        CPPFLAGS="$glib_save_CPPFLAGS"
+])
+
+LIBS="$glib_save_LIBS"
+
+# now spit out all the warnings.
+if test "$ac_cv_func_getpwuid_r" != "yes"; then
+	AC_MSG_WARN($FUNC_NO_GETPWUID_R)
+fi
+if test "$ac_cv_func_localtime_r" != "yes"; then
+	AC_MSG_WARN($FUNC_NO_LOCALTIME_R)
+fi
+
+#
+# Hack to deal with:
+# 
+#  a) GCC < 3.3 for Linux doesn't include -lpthread when
+#     building shared libraries with linux.
+#  b) FreeBSD doesn't do this either.
+#
+case $host in
+  *android*)
+    G_THREAD_LIBS_FOR_GTHREAD="$G_THREAD_LIBS"
+    ;;
+  *-*-freebsd*|*-*-linux*)
+    G_THREAD_LIBS_FOR_GTHREAD="`echo $G_THREAD_LIBS | sed s/-pthread/-lpthread/`"
+    ;;
+  *)
+    G_THREAD_LIBS_FOR_GTHREAD="$G_THREAD_LIBS"
+    ;;
+esac
+
+AC_SUBST(G_THREAD_CFLAGS)
+AC_SUBST(G_THREAD_LIBS)
+AC_SUBST(G_THREAD_LIBS_FOR_GTHREAD)
+AC_SUBST(G_THREAD_LIBS_EXTRA)
+
+AC_CHECK_FUNCS(clock_gettime, [], [
+  AC_CHECK_LIB(rt, clock_gettime, [
+    G_THREAD_LIBS="$G_THREAD_LIBS -lrt"
+    G_THREAD_LIBS_FOR_GTHREAD="$G_THREAD_LIBS_FOR_GTHREAD -lrt"
+  ])
+])
+
+
+dnl ************************
+dnl *** g_atomic_* tests ***
+dnl ************************
+
+dnl We need to decide at configure time if GLib will use real atomic
+dnl operations ("lock free") or emulated ones with a mutex.  This is
+dnl because we must put this information in glibconfig.h so we know if
+dnl it is safe or not to inline using compiler intrinsics directly from
+dnl the header.
+dnl
+dnl We also publish the information via G_ATOMIC_LOCK_FREE in case the
+dnl user is interested in knowing if they can use the atomic ops across
+dnl processes.
+dnl
+dnl We can currently support the atomic ops natively when building GLib
+dnl with recent versions of GCC or MSVC.  MSVC doesn't run ./configure,
+dnl so we skip that case here and define G_ATOMIC_LOCK_FREE exactly when
+dnl we are using GCC (and not mingw*).
+dnl
+dnl Note that the atomic ops are only available with GCC on x86 when
+dnl using -march=i486 or higher.  If we detect that the atomic ops are
+dnl not available but would be available given the right flags, we want
+dnl to abort and advise the user to fix their CFLAGS.  It's better to do
+dnl that then to silently fall back on emulated atomic ops just because
+dnl the user had the wrong build environment.
+
+dnl We may add other compilers here in the future...
+
+AC_CACHE_CHECK([for lock-free atomic intrinsics], glib_cv_g_atomic_lock_free, [
+  case $host in
+    *-*-mingw*)
+      glib_cv_g_atomic_lock_free=yes
+      ;;
+    *)
+      AC_TRY_LINK([],
+                     [volatile int atomic = 2;\
+                      __sync_bool_compare_and_swap (&atomic, 2, 3);],
+                     [glib_cv_g_atomic_lock_free=yes],
+                     [glib_cv_g_atomic_lock_free=no])
+      if test "$glib_cv_g_atomic_lock_free" = "no"; then
+        SAVE_CFLAGS="${CFLAGS}"
+        CFLAGS="-march=i486"
+        AC_TRY_LINK([],
+                       [volatile int atomic = 2;\
+                        __sync_bool_compare_and_swap (&atomic, 2, 3);],
+                       [AC_MSG_ERROR([GLib must be build with -march=i486 or later.])],
+                       [])
+        CFLAGS="${SAVE_CFLAGS}"
+      fi
+      ;;
+  esac])
+
+
+case $host in
+  *-*-mingw*)
+    ;;
+  *)
+    # Some compilers support atomic operations but do not define
+    # __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4, like clang
+    if test x"$glib_cv_g_atomic_lock_free" = xyes; then
+      AC_TRY_LINK([],
+                     [__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4;],
+                     [],
+                     [AC_DEFINE(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4, 1, [ compiler supports atomic operations])])
+    fi
+    ;;
+ esac
+
+dnl We need a more robust approach here...
+case $host_cpu in
+  i?86|x86_64|s390|s390x|arm*|crisv32*|etrax*)
+    glib_memory_barrier_needed=no
+    ;;
+  sparc*|alpha*|powerpc*|ia64)
+    glib_memory_barrier_needed=yes
+    ;;
+  *)
+    glib_memory_barrier_needed=yes
+    ;;
+esac
+
+dnl ************************
+dnl ** Check for futex(2) **
+dnl ************************
+AC_CACHE_CHECK(for futex(2) system call,
+    glib_cv_futex,AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+#include <linux/futex.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+],[
+  syscall (__NR_futex, NULL, FUTEX_WAKE, FUTEX_WAIT);
+])],glib_cv_futex=yes,glib_cv_futex=no))
+if test x"$glib_cv_futex" = xyes; then
+  AC_DEFINE(HAVE_FUTEX, 1, [we have the futex(2) system call])
+fi
+
+AC_CACHE_CHECK(for eventfd(2) system call,
+    glib_cv_eventfd,AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+#include <sys/eventfd.h>
+#include <unistd.h>
+],[
+  eventfd (0, EFD_CLOEXEC);
+])],glib_cv_eventfd=yes,glib_cv_eventfd=no))
+if test x"$glib_cv_eventfd" = x"yes"; then
+  AC_DEFINE(HAVE_EVENTFD, 1, [we have the eventfd(2) system call])
+fi
+AM_CONDITIONAL(HAVE_EVENTFD, [test "$glib_cv_eventfd" = "yes"])
+
+dnl ****************************************
+dnl *** GLib POLL* compatibility defines ***
+dnl ****************************************
+
+glib_poll_includes=["
+#include <sys/types.h>
+#include <poll.h>
+"]
+
+AS_IF([ test $ac_cv_header_sys_types_h = yes &&
+   test $ac_cv_func_poll = yes ], [
+  glib_failed=false
+  GLIB_CHECK_VALUE(POLLIN, $glib_poll_includes, glib_failed=true)
+  GLIB_CHECK_VALUE(POLLOUT, $glib_poll_includes, glib_failed=true)
+  GLIB_CHECK_VALUE(POLLPRI, $glib_poll_includes, glib_failed=true)
+  GLIB_CHECK_VALUE(POLLERR, $glib_poll_includes, glib_failed=true)
+  GLIB_CHECK_VALUE(POLLHUP, $glib_poll_includes, glib_failed=true)
+  GLIB_CHECK_VALUE(POLLNVAL, $glib_poll_includes, glib_failed=true)
+  if $glib_failed ; then
+    AC_MSG_ERROR([Could not determine values for POLL* constants])
+  fi
+], [
+  glib_cv_value_POLLIN=1
+  glib_cv_value_POLLOUT=4
+  glib_cv_value_POLLPRI=2
+  glib_cv_value_POLLERR=8
+  glib_cv_value_POLLHUP=16
+  glib_cv_value_POLLNVAL=32
+])
+
+AC_MSG_CHECKING([for broken poll])
+AC_RUN_IFELSE([AC_LANG_SOURCE([[
+	#include <stdlib.h>
+	#include <fcntl.h>
+	#include <poll.h>
+	int main(void) {
+	  struct pollfd fds[1];
+	  int fd;
+	  fd = open("/dev/null", 1);
+	  fds[0].fd = fd;
+	  fds[0].events = POLLIN;
+	  fds[0].revents = 0;
+	  if (poll(fds, 1, 0) < 0 || (fds[0].revents & POLLNVAL) != 0) {
+		exit(1);  /* Does not work for devices -- fail */
+	  }
+	  exit(0);
+	}]])],
+  [broken_poll=no],
+  [broken_poll=yes
+   AC_DEFINE(BROKEN_POLL,1,[poll doesn't work on devices])],
+  [broken_poll="no (cross compiling)"])
+AC_MSG_RESULT($broken_poll)
+
+dnl *********************
+dnl *** GRegex checks ***
+dnl *********************
+
+PCRE_REQUIRED_VERSION=8.13
+
+# Check if we should use the internal or the system-supplied pcre
+AC_ARG_WITH(pcre,
+            [AS_HELP_STRING([--with-pcre=@<:@internal/system@:>@],
+                            [whether to use system PCRE [default=system]])],
+            [],
+            [with_pcre=system])
+
+AM_CONDITIONAL(USE_SYSTEM_PCRE, [test "x$with_pcre" = xsystem])
+
+AS_IF([ test "x$with_pcre" = xsystem], [
+  PKG_CHECK_MODULES(PCRE,
+                    libpcre >= $PCRE_REQUIRED_VERSION)
+  AC_CACHE_CHECK([for Unicode support in PCRE],glib_cv_pcre_has_unicode,[
+                  glib_save_CFLAGS="$CFLAGS"
+                  glib_save_LIBS="$LIBS"
+                  CFLAGS="$CFLAGS $PCRE_CFLAGS" LIBS="$PCRE_LIBS"
+                  AC_TRY_RUN([#include <pcre.h>
+                              int main () {
+                                int support;
+                                pcre_config (PCRE_CONFIG_UTF8, &support);
+                                if (!support)
+                                  return 1;
+                                pcre_config (PCRE_CONFIG_UNICODE_PROPERTIES, &support);
+                                if (!support)
+                                  return 1;
+                                return 0;
+                              }],
+                  glib_cv_pcre_has_unicode=yes,
+                  glib_cv_pcre_has_unicode=no,
+                  glib_cv_pcre_has_unicode=yes)
+                  CFLAGS="$glib_save_CFLAGS"
+                  LIBS="$glib_save_LIBS"
+      ])
+  if test "$glib_cv_pcre_has_unicode" = "no"; then
+    AC_MSG_ERROR([*** The system-supplied PCRE does not support Unicode properties or UTF-8.])
+  fi
+  AC_SUBST(PCRE_CFLAGS)
+  AC_SUBST(PCRE_LIBS)
+  AC_DEFINE(USE_SYSTEM_PCRE, [], [using the system-supplied PCRE library])
+  PCRE_REQUIRES=libpcre
+  AC_SUBST(PCRE_REQUIRES)
+], [
+  # If using gcc 4 pass -Wno-pointer-sign when compiling the internal PCRE
+  AS_IF([ test x"$GCC" = xyes], [
+    AC_MSG_CHECKING([whether compiler understands -Wno-pointer-sign])
+    save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Wno-pointer-sign"
+    AC_TRY_COMPILE([],[],[PCRE_WARN_CFLAGS="$PCRE_WARN_CFLAGS -Wno-pointer-sign"
+                          AC_MSG_RESULT(yes)],[AC_MSG_RESULT(no)])
+    CFLAGS="$save_CFLAGS"
+  ])
+])
+AC_SUBST(PCRE_WARN_CFLAGS)
+
+dnl **********************
+dnl *** Win32 API libs ***
+dnl **********************
+
+case $host in
+  *-*-cygwin*)
+	G_LIBS_EXTRA="-luser32 -lkernel32"
+    ;;
+  *-*-mingw*)
+	G_LIBS_EXTRA="-lws2_32 -lole32 -lwinmm -lshlwapi"
+    ;;
+  *)
+	G_LIBS_EXTRA=""
+    ;;
+esac
+AC_SUBST(G_LIBS_EXTRA)
+
+dnl If the system doesn't define EILSEQ, we should define EILSEQ ourselves
+dnl since we need it for g_iconv()
+
+AC_MSG_CHECKING([for EILSEQ])
+AC_TRY_COMPILE([
+#include <errno.h>
+],
+[
+int error = EILSEQ;
+], have_eilseq=yes, have_eilseq=no);
+AC_MSG_RESULT($have_eilseq)
+
+dnl Add a conditional we can use when cross-compiling, so we avoid running
+dnl binaries
+AM_CONDITIONAL(CROSS_COMPILING, test $cross_compiling = yes)
+
+dnl **************************
+dnl *** Checks for gtk-doc ***
+dnl **************************
+# gtkdocize greps for ^GTK_DOC_CHECK and parses it, so you need to have
+# it on it's own line.
+m4_ifdef([GTK_DOC_CHECK], [
+GTK_DOC_CHECK([1.20], [--flavour no-tmpl])
+],[
+AM_CONDITIONAL([ENABLE_GTK_DOC],[false])
+])
+
+AC_ARG_ENABLE(man,
+              [AS_HELP_STRING([--enable-man],
+                              [generate man pages [default=auto]])],,
+              enable_man=maybe)
+
+AS_IF([test "$enable_man" != no], [
+  AC_PATH_PROG([XSLTPROC], [xsltproc])
+  AS_IF([test -z "$XSLTPROC"], [
+    AS_IF([test "$enable_man" = yes], [
+      AC_MSG_ERROR([xsltproc is required for --enable-man])
+    ])
+    enable_man=no
+  ])
+])
+
+AS_IF([ test "$enable_man" != no ], [
+  dnl check for DocBook DTD in the local catalog
+  JH_CHECK_XML_CATALOG([-//OASIS//DTD DocBook XML V4.1.2//EN],
+     [DocBook XML DTD V4.1.2], [have_docbook_dtd=yes], [have_docbook_dtd=no])
+  AS_IF([test "$have_docbook_dtd" != yes], [
+    AS_IF([test "$enable_man" = yes ], [
+      AC_MSG_ERROR([DocBook DTD is required for --enable-man])
+    ])
+    enable_man=no
+  ])
+])
+
+AS_IF([test "$enable_man" != no], [
+  dnl check for DocBook XSL stylesheets in the local catalog
+  JH_CHECK_XML_CATALOG([http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl],
+     [DocBook XSL Stylesheets], [have_docbook_style=yes],[have_docbook_style=no])
+  AS_IF([ test "$have_docbook_style" != yes ], [
+    AS_IF([ test "$enable_man" = yes ], [
+      AC_MSG_ERROR([DocBook XSL Stylesheets are required for --enable-man])
+    ])
+    enable_man=no
+  ])
+])
+
+AM_CONDITIONAL(ENABLE_MAN, test "$enable_man" != no)
+
+AC_MSG_CHECKING([whether to generate man pages])
+AS_IF([ test "$enable_man" != no ], [
+  AC_MSG_RESULT([yes])
+], [
+  AC_MSG_RESULT([no])
+])
+
+dnl
+dnl Tracing
+dnl
+
+AC_ARG_ENABLE([dtrace],
+             [AS_HELP_STRING([--enable-dtrace],
+                              [include tracing support for dtrace])])
+have_dtrace=no
+AC_MSG_CHECKING([whether to include dtrace tracing support])
+AS_IF([ test "x$enable_dtrace" != xno], [
+  if test x$glib_have_carbon = xyes; then
+    AC_MSG_RESULT([no (not yet compatible with MacOS dtrace)])
+  else 
+    AC_MSG_RESULT([yes])
+    AC_CHECK_PROGS(DTRACE, dtrace)
+    if test -z "$DTRACE"; then
+      if test "x$enable_dtrace" = xyes; then
+        AC_MSG_ERROR([dtrace not found])
+      fi
+    else
+      AC_CHECK_HEADER([sys/sdt.h],have_dtrace=yes,
+                      [if test "x$enable_dtrace" = xyes; then
+                        AC_MSG_ERROR([dtrace support needs sys/sdt.h header])
+                       fi])
+    fi
+  fi
+], [
+  AC_MSG_RESULT([no])
+])
+if test "x$have_dtrace" = xyes; then
+  AC_DEFINE([HAVE_DTRACE], [1], [Define to 1 if using dtrace probes.])
+fi
+AM_CONDITIONAL([ENABLE_DTRACE], [test x$have_dtrace = xyes ])
+
+AC_MSG_CHECKING([whether to include systemtap tracing support])
+AC_ARG_ENABLE([systemtap],
+             [AS_HELP_STRING([--enable-systemtap],
+                              [include tracing support for systemtap])])
+have_systemtap=no
+if test "x$enable_systemtap" != xno -a "x$have_dtrace" = xyes; then
+  have_systemtap=yes
+fi
+AC_MSG_RESULT(${have_systemtap})
+
+AM_CONDITIONAL([ENABLE_SYSTEMTAP], [test x$have_systemtap = xyes])
+
+AC_ARG_WITH([tapset-install-dir],
+            AS_HELP_STRING([--with-tapset-install-dir=DIR],
+                            [path where systemtap tapsets are installed [DATADIR/systemtap/tapset]]),
+            [if test "x${withval}" = x; then
+	       ABS_TAPSET_DIR="\$(datadir)/systemtap/tapset"
+	     else
+	       ABS_TAPSET_DIR="${withval}"
+	      fi],
+	    [ABS_TAPSET_DIR="\$(datadir)/systemtap/tapset"])
+AC_SUBST(ABS_TAPSET_DIR)
+
+dnl ************************************
+dnl *** Enable lcov coverage reports ***
+dnl ************************************
+
+AC_ARG_ENABLE(coverage,
+  AS_HELP_STRING([--enable-coverage],
+		 [enable coverage testing with gcov]),
+  [use_gcov=$enableval], [use_gcov=no])
+
+AS_IF([ test "x$use_gcov" = "xyes"], [
+  dnl we need gcc:
+  if test "$GCC" != "yes"; then
+    AC_MSG_ERROR([GCC is required for --enable-coverage])
+  fi
+
+  dnl Check if ccache is being used
+  AC_CHECK_PROG(SHTOOL, shtool, shtool)
+  case `$SHTOOL path $CC` in
+    *ccache*[)] gcc_ccache=yes;;
+    *[)] gcc_ccache=no;;
+  esac
+
+  if test "$gcc_ccache" = "yes" && (test -z "$CCACHE_DISABLE" || test "$CCACHE_DISABLE" != "1"); then
+    AC_MSG_ERROR([ccache must be disabled when --enable-coverage option is used. You can disable ccache by setting environment variable CCACHE_DISABLE=1.])
+  fi
+
+  ltp_version_list="1.6 1.7 1.8 1.9 1.10"
+  AC_CHECK_PROG(LTP, lcov, lcov)
+  AC_CHECK_PROG(LTP_GENHTML, genhtml, genhtml)
+
+  AS_IF([ test "$LTP" ], [
+    AC_CACHE_CHECK([for ltp version], glib_cv_ltp_version, [
+      glib_cv_ltp_version=invalid
+      ltp_version=`$LTP -v 2>/dev/null | $SED -e 's/^.* //'`
+      for ltp_check_version in $ltp_version_list; do
+        if test "$ltp_version" = "$ltp_check_version"; then
+          glib_cv_ltp_version="$ltp_check_version (ok)"
+        fi
+      done
+    ])
+  ], [
+    ltp_msg="To enable code coverage reporting you must have one of the following LTP versions installed: $ltp_version_list"
+    AC_MSG_ERROR([$ltp_msg])
+  ])
+
+  case $glib_cv_ltp_version in
+    ""|invalid[)]
+      ltp_msg="You must have one of the following versions of LTP: $ltp_version_list (found: $ltp_version)."
+      AC_MSG_ERROR([$ltp_msg])
+      LTP="exit 0;"
+      ;;
+  esac
+
+  if test -z "$LTP_GENHTML"; then
+    AC_MSG_ERROR([Could not find genhtml from the LTP package])
+  fi
+
+  dnl Remove all optimization flags from CFLAGS
+  changequote({,})
+  CFLAGS=`echo "$CFLAGS" | $SED -e 's/-O[0-9]*//g'`
+  changequote([,])
+
+  dnl Add the special gcc flags
+  CFLAGS="$CFLAGS -O0 -fprofile-arcs -ftest-coverage"
+  LDFLAGS="$LDFLAGS -lgcov"
+])
+
+dnl ******************************
+dnl *** output the whole stuff ***
+dnl ******************************
+
+dnl this section will only be run if config.status is invoked with no
+dnl arguments, or with "glib/glibconfig.h" as an argument.
+AC_CONFIG_COMMANDS([glib/glibconfig.h],
+[
+	outfile=glib/glibconfig.h-tmp
+	cat > $outfile <<\_______EOF
+/* glibconfig.h
+ *
+ * This is a generated file.  Please modify 'configure.ac'
+ */
+
+#ifndef __GLIBCONFIG_H__
+#define __GLIBCONFIG_H__
+
+#include <glib/gmacros.h>
+
+_______EOF
+
+	echo '#include <limits.h>' >> $outfile
+	echo '#include <float.h>' >> $outfile
+	if test x$glib_values_h = xyes; then
+	  echo '#include <values.h>' >> $outfile
+	fi
+	if test "$glib_header_alloca_h" = "yes"; then
+	  echo '#define GLIB_HAVE_ALLOCA_H' >> $outfile
+	fi
+	if test x$glib_included_printf != xyes; then
+          echo "
+/* Specifies that GLib's g_print*() functions wrap the
+ * system printf functions.  This is useful to know, for example,
+ * when using glibc's register_printf_function().
+ */" >> $outfile
+	  echo '#define GLIB_USING_SYSTEM_PRINTF' >> $outfile
+	fi
+
+	cat >> $outfile <<_______EOF
+
+G_BEGIN_DECLS
+
+#define G_MINFLOAT	FLT_MIN
+#define G_MAXFLOAT	FLT_MAX
+#define G_MINDOUBLE	DBL_MIN
+#define G_MAXDOUBLE	DBL_MAX
+#define G_MINSHORT	SHRT_MIN
+#define G_MAXSHORT	SHRT_MAX
+#define G_MAXUSHORT	USHRT_MAX
+#define G_MININT	INT_MIN
+#define G_MAXINT	INT_MAX
+#define G_MAXUINT	UINT_MAX
+#define G_MINLONG	LONG_MIN
+#define G_MAXLONG	LONG_MAX
+#define G_MAXULONG	ULONG_MAX
+
+_______EOF
+
+
+	### this should always be true in a modern C/C++ compiler
+	### and is statically asserted by glib-init.c
+	cat >>$outfile <<_______EOF
+typedef signed char gint8;
+typedef unsigned char guint8;
+_______EOF
+
+
+	if test -n "$gint16"; then
+	  cat >>$outfile <<_______EOF
+typedef signed $gint16 gint16;
+typedef unsigned $gint16 guint16;
+#define G_GINT16_MODIFIER $gint16_modifier
+#define G_GINT16_FORMAT $gint16_format
+#define G_GUINT16_FORMAT $guint16_format
+_______EOF
+	fi
+
+
+	if test -n "$gint32"; then
+	  cat >>$outfile <<_______EOF
+typedef signed $gint32 gint32;
+typedef unsigned $gint32 guint32;
+#define G_GINT32_MODIFIER $gint32_modifier
+#define G_GINT32_FORMAT $gint32_format
+#define G_GUINT32_FORMAT $guint32_format
+_______EOF
+	fi
+
+	cat >>$outfile <<_______EOF
+#define G_HAVE_GINT64 1          /* deprecated, always true */
+
+${glib_extension}typedef signed $gint64 gint64;
+${glib_extension}typedef unsigned $gint64 guint64;
+
+#define G_GINT64_CONSTANT(val)	$gint64_constant
+#define G_GUINT64_CONSTANT(val)	$guint64_constant
+_______EOF
+
+	if test x$gint64_format != x ; then
+	  cat >>$outfile <<_______EOF
+#define G_GINT64_MODIFIER $gint64_modifier
+#define G_GINT64_FORMAT $gint64_format
+#define G_GUINT64_FORMAT $guint64_format
+_______EOF
+        else
+	  cat >>$outfile <<_______EOF
+#undef G_GINT64_MODIFIER
+#undef G_GINT64_FORMAT
+#undef G_GUINT64_FORMAT
+_______EOF
+        fi           
+
+        cat >>$outfile <<_______EOF
+
+#define GLIB_SIZEOF_VOID_P $glib_void_p
+#define GLIB_SIZEOF_LONG   $glib_long
+#define GLIB_SIZEOF_SIZE_T $glib_size_t
+#define GLIB_SIZEOF_SSIZE_T $glib_ssize_t
+
+_______EOF
+
+        cat >>$outfile <<_______EOF
+typedef signed $glib_ssize_type_define gssize;
+typedef unsigned $glib_size_type_define gsize;
+#define G_GSIZE_MODIFIER $gsize_modifier
+#define G_GSSIZE_MODIFIER $gssize_modifier
+#define G_GSIZE_FORMAT $gsize_format
+#define G_GSSIZE_FORMAT $gssize_format
+
+#define G_MAXSIZE	G_MAXU$glib_msize_type
+#define G_MINSSIZE	G_MIN$glib_mssize_type
+#define G_MAXSSIZE	G_MAX$glib_mssize_type
+
+typedef gint64 goffset;
+#define G_MINOFFSET	G_MININT64
+#define G_MAXOFFSET	G_MAXINT64
+
+#define G_GOFFSET_MODIFIER      G_GINT64_MODIFIER
+#define G_GOFFSET_FORMAT        G_GINT64_FORMAT
+#define G_GOFFSET_CONSTANT(val) G_GINT64_CONSTANT(val)
+
+#define G_POLLFD_FORMAT $g_pollfd_format
+
+_______EOF
+
+	if test -z "$glib_unknown_void_p"; then
+	  cat >>$outfile <<_______EOF
+
+#define GPOINTER_TO_INT(p)	((gint)  ${glib_gpi_cast} (p))
+#define GPOINTER_TO_UINT(p)	((guint) ${glib_gpui_cast} (p))
+
+#define GINT_TO_POINTER(i)	((gpointer) ${glib_gpi_cast} (i))
+#define GUINT_TO_POINTER(u)	((gpointer) ${glib_gpui_cast} (u))
+
+typedef signed $glib_intptr_type_define gintptr;
+typedef unsigned $glib_intptr_type_define guintptr;
+
+#define G_GINTPTR_MODIFIER      $gintptr_modifier
+#define G_GINTPTR_FORMAT        $gintptr_format
+#define G_GUINTPTR_FORMAT       $guintptr_format
+_______EOF
+	else
+	  echo '#error SIZEOF_VOID_P unknown - This should never happen' >>$outfile
+	fi
+
+
+
+	cat >>$outfile <<_______EOF
+#ifndef G_DISABLE_DEPRECATED
+#define g_ATEXIT(proc)	(atexit (proc))
+#define g_memmove(dest,src,len) G_STMT_START { memmove ((dest), (src), (len)); } G_STMT_END
+#endif
+$glib_defines
+$glib_os
+$glib_static_compilation
+
+$glib_vacopy
+
+_______EOF
+
+	if test x$g_have_iso_c_varargs = xyes ; then
+		cat >>$outfile <<_______EOF
+#ifndef __cplusplus
+# define G_HAVE_ISO_VARARGS 1
+#endif
+_______EOF
+	fi
+	if test x$g_have_iso_cxx_varargs = xyes ; then
+		cat >>$outfile <<_______EOF
+#ifdef __cplusplus
+# define G_HAVE_ISO_VARARGS 1
+#endif
+_______EOF
+	fi
+	if test x$g_have_gnuc_varargs = xyes ; then
+		cat >>$outfile <<_______EOF
+
+/* gcc-2.95.x supports both gnu style and ISO varargs, but if -ansi
+ * is passed ISO vararg support is turned off, and there is no work
+ * around to turn it on, so we unconditionally turn it off.
+ */
+#if __GNUC__ == 2 && __GNUC_MINOR__ == 95
+#  undef G_HAVE_ISO_VARARGS
+#endif
+
+#define G_HAVE_GNUC_VARARGS 1
+_______EOF
+	fi
+
+	case x$g_stack_grows in
+	xyes) echo "#define G_HAVE_GROWING_STACK 1" >>$outfile ;;
+	*)    echo "#define G_HAVE_GROWING_STACK 0" >>$outfile ;;
+	esac
+
+
+	echo >>$outfile
+	if test x$g_have_eilseq = xno; then
+		cat >>$outfile <<_______EOF
+#ifndef EILSEQ
+/* On some pre-C99 systems, EILSEQ is not defined.
+ * The correspondence between this and the corresponding definition
+ * in libiconv is essential.
+ */
+#  define EILSEQ ENOENT
+#endif
+_______EOF
+
+	fi
+
+	if test x$g_have_gnuc_visibility = xyes; then
+		cat >>$outfile <<_______EOF
+#define G_HAVE_GNUC_VISIBILITY 1
+_______EOF
+	fi
+		cat >>$outfile <<_______EOF
+#if defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)
+#define G_GNUC_INTERNAL __attribute__((visibility("hidden")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define G_GNUC_INTERNAL __hidden
+#elif defined (__GNUC__) && defined (G_HAVE_GNUC_VISIBILITY)
+#define G_GNUC_INTERNAL __attribute__((visibility("hidden")))
+#else
+#define G_GNUC_INTERNAL
+#endif 
+_______EOF
+
+	echo >>$outfile
+	cat >>$outfile <<_______EOF
+#define G_THREADS_ENABLED
+#define G_THREADS_IMPL_$g_threads_impl_def
+_______EOF
+
+	if test x"$g_memory_barrier_needed" != xno; then
+	  echo >>$outfile
+	  echo "#define G_ATOMIC_OP_MEMORY_BARRIER_NEEDED 1" >>$outfile
+	fi
+	if test x"$g_atomic_lock_free" = xyes; then
+          echo >>$outfile
+          echo "#define G_ATOMIC_LOCK_FREE" >>$outfile
+        fi
+	echo >>$outfile
+	g_bit_sizes="16 32 64"
+	for bits in $g_bit_sizes; do
+	  cat >>$outfile <<_______EOF
+#define GINT${bits}_TO_${g_bs_native}(val)	((gint${bits}) (val))
+#define GUINT${bits}_TO_${g_bs_native}(val)	((guint${bits}) (val))
+#define GINT${bits}_TO_${g_bs_alien}(val)	((gint${bits}) GUINT${bits}_SWAP_LE_BE (val))
+#define GUINT${bits}_TO_${g_bs_alien}(val)	(GUINT${bits}_SWAP_LE_BE (val))
+_______EOF
+	done
+
+	cat >>$outfile <<_______EOF
+#define GLONG_TO_LE(val)	((glong) GINT${glongbits}_TO_LE (val))
+#define GULONG_TO_LE(val)	((gulong) GUINT${glongbits}_TO_LE (val))
+#define GLONG_TO_BE(val)	((glong) GINT${glongbits}_TO_BE (val))
+#define GULONG_TO_BE(val)	((gulong) GUINT${glongbits}_TO_BE (val))
+#define GINT_TO_LE(val)		((gint) GINT${gintbits}_TO_LE (val))
+#define GUINT_TO_LE(val)	((guint) GUINT${gintbits}_TO_LE (val))
+#define GINT_TO_BE(val)		((gint) GINT${gintbits}_TO_BE (val))
+#define GUINT_TO_BE(val)	((guint) GUINT${gintbits}_TO_BE (val))
+#define GSIZE_TO_LE(val)	((gsize) GUINT${gsizebits}_TO_LE (val))
+#define GSSIZE_TO_LE(val)	((gssize) GINT${gssizebits}_TO_LE (val))
+#define GSIZE_TO_BE(val)	((gsize) GUINT${gsizebits}_TO_BE (val))
+#define GSSIZE_TO_BE(val)	((gssize) GINT${gssizebits}_TO_BE (val))
+#define G_BYTE_ORDER $g_byte_order
+
+#define GLIB_SYSDEF_POLLIN =$g_pollin
+#define GLIB_SYSDEF_POLLOUT =$g_pollout
+#define GLIB_SYSDEF_POLLPRI =$g_pollpri
+#define GLIB_SYSDEF_POLLHUP =$g_pollhup
+#define GLIB_SYSDEF_POLLERR =$g_pollerr
+#define GLIB_SYSDEF_POLLNVAL =$g_pollnval
+
+#define G_MODULE_SUFFIX "$g_module_suffix"
+
+typedef $g_pid_type GPid;
+#define G_PID_FORMAT $g_pid_format
+
+#define GLIB_SYSDEF_AF_UNIX $g_af_unix
+#define GLIB_SYSDEF_AF_INET $g_af_inet
+#define GLIB_SYSDEF_AF_INET6 $g_af_inet6
+
+#define GLIB_SYSDEF_MSG_OOB $g_msg_oob
+#define GLIB_SYSDEF_MSG_PEEK $g_msg_peek
+#define GLIB_SYSDEF_MSG_DONTROUTE $g_msg_dontroute
+
+G_END_DECLS
+
+#endif /* __GLIBCONFIG_H__ */
+_______EOF
+
+
+	if cmp -s $outfile glib/glibconfig.h; then
+	  AC_MSG_NOTICE([glib/glibconfig.h is unchanged])
+	  rm -f $outfile
+	else
+	  mv $outfile glib/glibconfig.h
+	fi
+],[
+
+# Note that if two cases are the same, case goes with the first one.
+# Note also that this is inside an AC_OUTPUT_COMMAND.  We do not depend
+# on variable expansion in case labels.  Look at the generated config.status
+# for a hint.
+
+if test "x${ac_cv_working_alloca_h+set}" = xset ; then
+  glib_header_alloca_h="$ac_cv_working_alloca_h"
+else
+  glib_header_alloca_h="$ac_cv_header_alloca_h"
+fi
+
+if test x$enable_included_printf = xyes ; then
+  glib_included_printf=yes
+fi
+
+case 2 in
+$ac_cv_sizeof_short)		
+  gint16=short
+  gint16_modifier='"h"'
+  gint16_format='"hi"'
+  guint16_format='"hu"'
+  ;;
+$ac_cv_sizeof_int)		
+  gint16=int
+  gint16_modifier='""'
+  gint16_format='"i"'
+  guint16_format='"u"'
+  ;;
+esac
+case 4 in
+$ac_cv_sizeof_short)		
+  gint32=short
+  gint32_modifier='"h"'
+  gint32_format='"hi"'
+  guint32_format='"hu"'
+  ;;
+$ac_cv_sizeof_int)		
+  gint32=int
+  gint32_modifier='""'
+  gint32_format='"i"'
+  guint32_format='"u"'
+  ;;
+$ac_cv_sizeof_long)		
+  gint32=long
+  gint32_modifier='"l"'
+  gint32_format='"li"'
+  guint32_format='"lu"'
+  ;;
+esac
+case 8 in
+$ac_cv_sizeof_int)
+  gint64=int
+  gint64_modifier='""'
+  gint64_format='"i"'
+  guint64_format='"u"'
+  glib_extension=
+  gint64_constant='(val)'
+  guint64_constant='(val)'
+  ;;
+$ac_cv_sizeof_long)
+  gint64=long
+  gint64_modifier='"l"'
+  gint64_format='"li"'
+  guint64_format='"lu"'
+  glib_extension=
+  gint64_constant='(val##L)'
+  guint64_constant='(val##UL)'
+  ;;
+$ac_cv_sizeof_long_long)
+  gint64='long long'
+  if test -n "$glib_cv_long_long_format"; then
+    gint64_modifier='"'$glib_cv_long_long_format'"'
+    gint64_format='"'$glib_cv_long_long_format'i"'
+    guint64_format='"'$glib_cv_long_long_format'u"'
+  fi
+  glib_extension='G_GNUC_EXTENSION '
+  gint64_constant='(G_GNUC_EXTENSION (val##LL))'
+  guint64_constant='(G_GNUC_EXTENSION (val##ULL))'
+  ;;
+$ac_cv_sizeof___int64)
+  gint64='__int64'
+  if test -n "$glib_cv_long_long_format"; then
+    gint64_modifier='"'$glib_cv_long_long_format'"'
+    gint64_format='"'$glib_cv_long_long_format'i"'
+    guint64_format='"'$glib_cv_long_long_format'u"'
+  fi
+  glib_extension=
+  gint64_constant='(val##i64)'
+  guint64_constant='(val##ui64)'
+  ;;
+esac
+glib_size_t=$ac_cv_sizeof_size_t
+glib_ssize_t=$ac_cv_sizeof_ssize_t
+glib_size_type_define="$glib_size_type"
+glib_ssize_type_define="$glib_ssize_type"
+glib_void_p=$ac_cv_sizeof_void_p
+glib_long=$ac_cv_sizeof_long
+
+case "$glib_size_type" in
+short)
+  gsize_modifier='"h"'
+  gsize_format='"hu"'
+  glib_msize_type='SHRT'
+  ;;
+int)
+  gsize_modifier='""'
+  gsize_format='"u"'
+  glib_msize_type='INT'
+  ;;
+long)
+  gsize_modifier='"l"'
+  gsize_format='"lu"'
+  glib_msize_type='LONG'
+  ;;
+"long long"|__int64)
+  gsize_modifier='"I64"'
+  gsize_format='"I64u"'
+  glib_msize_type='INT64'
+  ;;
+esac
+
+case "$glib_ssize_type" in
+short)
+  gssize_modifier='"h"'
+  gssize_format='"hi"'
+  glib_mssize_type='SHRT'
+  ;;
+int)
+  gssize_modifier='""'
+  gssize_format='"i"'
+  glib_mssize_type='INT'
+  ;;
+long)
+  gssize_modifier='"l"'
+  gssize_format='"li"'
+  glib_mssize_type='LONG'
+  ;;
+"long long"|__int64)
+  gssize_modifier='"I64"'
+  gssize_format='"I64i"'
+  glib_mssize_type='INT64'
+  ;;
+esac
+
+gintbits=`expr $ac_cv_sizeof_int \* 8`
+glongbits=`expr $ac_cv_sizeof_long \* 8`
+gsizebits=`expr $ac_cv_sizeof_size_t \* 8`
+gssizebits=`expr $ac_cv_sizeof_ssize_t \* 8`
+
+case $ac_cv_sizeof_void_p in
+$ac_cv_sizeof_int)
+  glib_intptr_type_define=int
+  gintptr_modifier='""'
+  gintptr_format='"i"'
+  guintptr_format='"u"'
+  glib_gpi_cast='(gint)'
+  glib_gpui_cast='(guint)'
+  ;;
+$ac_cv_sizeof_long)
+  glib_intptr_type_define=long
+  gintptr_modifier='"l"'
+  gintptr_format='"li"'
+  guintptr_format='"lu"'
+  glib_gpi_cast='(glong)'
+  glib_gpui_cast='(gulong)'
+  ;;
+$ac_cv_sizeof_long_long)
+  glib_intptr_type_define='long long'
+  gintptr_modifier='"I64"'
+  gintptr_format='"I64i"'
+  guintptr_format='"I64u"'
+  glib_gpi_cast='(gint64)'
+  glib_gpui_cast='(guint64)'
+  ;;
+$ac_cv_sizeof___int64)
+  glib_intptr_type_define=__int64
+  gintptr_modifier='"I64"'
+  gintptr_format='"I64i"'
+  guintptr_format='"I64u"'
+  glib_gpi_cast='(gint64)'
+  glib_gpui_cast='(guint64)'
+  ;;
+*)
+  glib_unknown_void_p=yes
+  ;;
+esac
+
+
+glib_defines="
+#define GLIB_MAJOR_VERSION $GLIB_MAJOR_VERSION
+#define GLIB_MINOR_VERSION $GLIB_MINOR_VERSION
+#define GLIB_MICRO_VERSION $GLIB_MICRO_VERSION
+"
+
+case xyes in
+x$glib_cv_va_copy)	glib_vacopy='#define G_VA_COPY	va_copy' ;;
+x$glib_cv___va_copy)	glib_vacopy='#define G_VA_COPY	__va_copy' ;;
+*)			glib_vacopy=''
+esac
+
+if test x$glib_cv_va_val_copy = xno; then
+  glib_vacopy="\$glib_vacopy
+#define G_VA_COPY_AS_ARRAY 1"
+fi
+
+g_have_gnuc_varargs=$g_have_gnuc_varargs
+g_have_iso_c_varargs=$g_have_iso_c_varargs
+g_have_iso_cxx_varargs=$g_have_iso_cxx_varargs
+
+g_have_gnuc_visibility=$g_have_gnuc_visibility
+g_have_sunstudio_visibility=$g_have_sunstudio_visibility
+
+if test x$ac_cv_c_bigendian = xyes; then
+  g_byte_order=G_BIG_ENDIAN
+  g_bs_native=BE
+  g_bs_alien=LE
+else
+  g_byte_order=G_LITTLE_ENDIAN
+  g_bs_native=LE
+  g_bs_alien=BE
+fi
+
+g_pollin=$glib_cv_value_POLLIN
+g_pollout=$glib_cv_value_POLLOUT
+g_pollpri=$glib_cv_value_POLLPRI
+g_pollhup=$glib_cv_value_POLLHUP
+g_pollerr=$glib_cv_value_POLLERR
+g_pollnval=$glib_cv_value_POLLNVAL
+
+# If a family is not found on the system, define that family to
+# a negative value, picking a different one for each undefined
+# family (-1 for AF_UNIX, -2 for the next one, -3 ...)
+# This is needed because glib-mkenums doesn't handle optional
+# values in enums, and thus we have to have all existing values
+# defined in the enum.
+if test "x$glib_cv_value_AF_UNIX" != "x"; then
+  g_af_unix=$glib_cv_value_AF_UNIX
+else
+  g_af_unix=-1
+fi
+g_af_inet=$glib_cv_value_AF_INET
+g_af_inet6=$glib_cv_value_AF_INET6
+
+g_msg_peek=$glib_cv_value_MSG_PEEK
+g_msg_oob=$glib_cv_value_MSG_OOB
+g_msg_dontroute=$glib_cv_value_MSG_DONTROUTE
+
+g_stack_grows=$glib_cv_stack_grows
+
+g_have_eilseq=$have_eilseq
+
+g_threads_impl_def=$g_threads_impl
+
+g_atomic_lock_free="$glib_cv_g_atomic_lock_free"
+g_memory_barrier_needed="$glib_memory_barrier_needed"
+g_gcc_atomic_ops="$glib_cv_gcc_has_builtin_atomic_operations"
+
+g_module_suffix="$glib_gmodule_suffix"
+g_pid_type="$glib_pid_type"
+g_pid_format="\"$glib_pid_format\""
+g_pollfd_format="\"$glib_pollfd_format\""
+
+case $host in
+  *-*-cygwin*)
+    glib_os="#define G_OS_UNIX
+#define G_PLATFORM_WIN32
+#define G_WITH_CYGWIN"
+    ;;
+  *-*-mingw*)
+    glib_os="#define G_OS_WIN32
+#define G_PLATFORM_WIN32"
+    ;;
+  *)
+    glib_os="#define G_OS_UNIX"
+    ;;
+esac
+glib_static_compilation=""
+if test x$glib_win32_static_compilation = xyes; then
+  glib_static_compilation="#define GLIB_STATIC_COMPILATION 1
+#define GOBJECT_STATIC_COMPILATION 1"
+fi
+])
+
+# Redo enough to get guint32 and guint64 for the alignment checks below
+case 4 in
+$ac_cv_sizeof_short)
+  gint32=short
+  ;;
+$ac_cv_sizeof_int)
+  gint32=int
+  ;;
+$ac_cv_sizeof_long)
+  gint32=long
+  ;;
+esac
+case 8 in
+$ac_cv_sizeof_int)
+  gint64=int
+  ;;
+$ac_cv_sizeof_long)
+  gint64=long
+  ;;
+$ac_cv_sizeof_long_long)
+  gint64='long long'
+  ;;
+$ac_cv_sizeof___int64)
+  gint64='__int64'
+  ;;
+esac
+
+AC_CHECK_TYPE([guint32],,,[typedef unsigned $gint32 guint32;])
+AC_CHECK_ALIGNOF([guint32], [AC_INCLUDES_DEFAULT
+typedef unsigned $gint32 guint32;])
+AC_CHECK_TYPE([guint64],,,[typedef unsigned $gint64 guint64;])
+AC_CHECK_ALIGNOF([guint64], [AC_INCLUDES_DEFAULT
+typedef unsigned $gint64 guint64;])
+AC_CHECK_TYPE([unsigned long])
+AC_CHECK_ALIGNOF([unsigned long])
+
+# Check for libdbus1 - Optional - is only used in the GDBus test cases
+#
+# 1.2.14 required for dbus_message_set_serial
+PKG_CHECK_MODULES(DBUS1,
+     dbus-1 >= 1.2.14,
+     [AC_DEFINE(HAVE_DBUS1, 1, [Define if dbus-1 is available]) have_dbus1=yes],
+     have_dbus1=no)
+AC_SUBST(DBUS1_CFLAGS)
+AC_SUBST(DBUS1_LIBS)
+AM_CONDITIONAL(HAVE_DBUS1, [test "x$have_dbus1" = "xyes"])
+
+AC_CHECK_PROGS([DBUS_DAEMON], [dbus-daemon])
+AM_CONDITIONAL([HAVE_DBUS_DAEMON], [test x$DBUS_DAEMON = xdbus-daemon ])
+
+dnl
+dnl Check for -Bsymbolic-functions linker flag used to avoid
+dnl intra-library PLT jumps, if available.
+dnl
+
+AC_ARG_ENABLE(Bsymbolic,
+              [AS_HELP_STRING([--disable-Bsymbolic],
+                              [avoid linking with -Bsymbolic])],,
+              [SAVED_LDFLAGS="${LDFLAGS}" SAVED_LIBS="${LIBS}"
+               AC_MSG_CHECKING([for -Bsymbolic-functions linker flag])
+               LDFLAGS=-Wl,-Bsymbolic-functions
+               LIBS=
+               AC_TRY_LINK([], [return 0],
+                           AC_MSG_RESULT(yes)
+                           enable_Bsymbolic=yes,
+                           AC_MSG_RESULT(no)
+                           enable_Bsymbolic=no)
+               LDFLAGS="${SAVED_LDFLAGS}" LIBS="${SAVED_LIBS}"])
+
+if test "x${enable_Bsymbolic}" = "xyes"; then
+  GLIB_LINK_FLAGS=-Wl,-Bsymbolic-functions
+fi
+
+dnl
+dnl Check for -z,nodelete linker flag: the type system assumes that
+dnl libgobject stays loaded for the lifetime of the process.
+dnl Since ld.bfd does not treat wrong -z options as fatal by default,
+dnl we also try to check for the --fatal-warnings linker flag if
+dnl auto-detecting.
+dnl
+
+AC_ARG_ENABLE([znodelete],
+              [AS_HELP_STRING([--disable-znodelete],
+                              [avoid linking with -z,nodelete])],,
+              [SAVED_LDFLAGS="${LDFLAGS}" SAVED_LIBS="${LIBS}"
+               AC_MSG_CHECKING([for --fatal-warnings linker flag])
+               LDFLAGS=-Wl,--fatal-warnings
+               LIBS=
+               AC_TRY_LINK([], [return 0],
+                           AC_MSG_RESULT(yes)
+                           [ldflags_fatal=-Wl,--fatal-warnings],
+                           AC_MSG_RESULT(no)
+                           ldflags_fatal=)
+               AC_MSG_CHECKING([for -z,nodelete linker flag])
+               LDFLAGS="$ldflags_fatal -Wl,-z,nodelete"
+               AC_TRY_LINK([], [return 0],
+                           AC_MSG_RESULT(yes)
+                           enable_znodelete=yes,
+                           AC_MSG_RESULT(no)
+                           enable_znodelete=no)
+               LDFLAGS="${SAVED_LDFLAGS}" LIBS="${SAVED_LIBS}"])
+
+if test "x${enable_znodelete}" = "xyes"; then
+  GLIB_LINK_FLAGS="$GLIB_LINK_FLAGS -Wl,-z,nodelete"
+fi
+
+AC_SUBST(GLIB_LINK_FLAGS)
+
+dnl
+dnl Check for -fvisibility=hidden to determine if we can do GNU-style
+dnl visibility attributes for symbol export control
+dnl
+GLIB_HIDDEN_VISIBILITY_CFLAGS=""
+case "$host" in
+  *-*-mingw*)
+    dnl on mingw32 we do -fvisibility=hidden and __declspec(dllexport)
+    AC_DEFINE([_GLIB_EXTERN], [__attribute__((visibility("default"))) __declspec(dllexport) extern],
+              [defines how to decorate public symbols while building])
+    CFLAGS="${CFLAGS} -fvisibility=hidden"
+    ;;
+  *)
+    dnl on other compilers, check if we can do -fvisibility=hidden
+    SAVED_CFLAGS="${CFLAGS}"
+    CFLAGS="-fvisibility=hidden"
+    AC_MSG_CHECKING([for -fvisibility=hidden compiler flag])
+    AC_TRY_COMPILE([], [return 0],
+                   AC_MSG_RESULT(yes)
+                   enable_fvisibility_hidden=yes,
+                   AC_MSG_RESULT(no)
+                   enable_fvisibility_hidden=no)
+    CFLAGS="${SAVED_CFLAGS}"
+
+    AS_IF([test "${enable_fvisibility_hidden}" = "yes"], [
+      AC_DEFINE([_GLIB_EXTERN], [__attribute__((visibility("default"))) extern],
+                [defines how to decorate public symbols while building])
+      GLIB_HIDDEN_VISIBILITY_CFLAGS="-fvisibility=hidden"
+    ])
+    ;;
+esac
+AC_SUBST(GLIB_HIDDEN_VISIBILITY_CFLAGS)
+
+dnl Compiler flags; macro originates from systemd
+dnl See https://bugzilla.gnome.org/show_bug.cgi?id=608953
+AC_ARG_ENABLE(compile-warnings,
+              [AS_HELP_STRING([--disable-compile-warnings],
+                              [Don't use builtin compiler warnings])],,
+			      enable_compile_warnings=yes)
+AS_IF([test "x$enable_compile_warnings" = xyes], [
+  CC_CHECK_FLAGS_APPEND([GLIB_WARN_CFLAGS], [CFLAGS], [\
+   -Wall -Wstrict-prototypes -Werror=declaration-after-statement \
+   -Werror=missing-prototypes -Werror=implicit-function-declaration \
+   -Werror=pointer-arith -Werror=init-self -Werror=format-security \
+   -Werror=format=2 -Werror=missing-include-dirs])
+])
+AC_SUBST(GLIB_WARN_CFLAGS)
+
+#
+# Define variables corresponding to the correct include paths to use for
+# in-tree building.
+#
+
+# for config.h:
+config_h_INCLUDES='-I$(top_builddir)'
+AC_SUBST(config_h_INCLUDES)
+
+# glib:
+#   config.h
+#   $(top_builddir)/glib: for glibconfig.h
+#   $(top_srcdir)/glib:   for glib.h
+#   $(top_srcdir):        for everything
+glib_INCLUDES='$(config_h_INCLUDES) -I$(top_builddir)/glib -I$(top_srcdir)/glib -I$(top_srcdir)'
+AC_SUBST(glib_INCLUDES)
+
+# gobject:
+#   same as glib
+gobject_INCLUDES='$(glib_INCLUDES)'
+AC_SUBST(gobject_INCLUDES)
+
+# gmodule:
+#   glib includes
+#   $(top_srcdir)/gmodule: for gmodule.h
+gmodule_INCLUDES='$(glib_INCLUDES) -I$(top_srcdir)/gmodule'
+AC_SUBST(gmodule_INCLUDES)
+
+# gio:
+#   same as gmodule
+gio_INCLUDES='$(gmodule_INCLUDES)'
+AC_SUBST(gio_INCLUDES)
+
+
+AC_CONFIG_FILES([
+glib-2.0.pc
+gmodule-2.0.pc
+gmodule-export-2.0.pc
+gmodule-no-export-2.0.pc
+gthread-2.0.pc
+gobject-2.0.pc
+gio-2.0.pc
+gio-unix-2.0.pc
+gio-windows-2.0.pc
+glib-zip
+glib-gettextize
+Makefile
+build/Makefile
+build/win32/Makefile
+build/win32/dirent/Makefile
+build/win32/vs9/Makefile
+build/win32/vs9/glib-version-paths.vsprops
+build/win32/vs10/Makefile
+build/win32/vs10/glib-version-paths.props
+build/win32/vs11/Makefile
+build/win32/vs12/Makefile
+build/win32/vs14/Makefile
+glib/Makefile
+glib/libcharset/Makefile
+glib/gnulib/Makefile
+glib/pcre/Makefile
+glib/update-pcre/Makefile
+glib/tests/Makefile
+gmodule/Makefile
+gmodule/gmoduleconf.h
+gobject/Makefile
+gobject/glib-mkenums
+gobject/tests/Makefile
+gthread/Makefile
+gio/Makefile
+gio/gdbus-2.0/codegen/Makefile
+gio/gdbus-2.0/codegen/config.py
+gio/gnetworking.h
+gio/xdgmime/Makefile
+gio/inotify/Makefile
+gio/kqueue/Makefile
+gio/fam/Makefile
+gio/win32/Makefile
+gio/tests/Makefile
+gio/tests/gdbus-object-manager-example/Makefile
+gio/tests/services/Makefile
+gio/tests/services/org.gtk.GDBus.Examples.ObjectManager.service
+gio/tests/modules/Makefile
+po/Makefile.in
+docs/Makefile
+docs/reference/Makefile
+docs/reference/glib/Makefile
+docs/reference/glib/version.xml
+docs/reference/gobject/Makefile
+docs/reference/gobject/version.xml
+docs/reference/gio/Makefile
+docs/reference/gio/version.xml
+tests/Makefile
+tests/gobject/Makefile
+tests/refcount/Makefile
+m4macros/Makefile
+])
+
+AC_CONFIG_COMMANDS([chmod-scripts],
+[chmod 0755 glib-zip
+chmod 0755 glib-gettextize
+chmod 0755 gobject/glib-mkenums])
+
+# we want to invoke this macro solely so that the config.status script
+# and automake generated makefiles know about these generated files.
+# They are only needed to distcheck the package
+if false; then
+  AC_CONFIG_FILES([
+    INSTALL
+    README
+    config.h.win32
+    glib/glibconfig.h.win32
+    glib/makefile.msc
+    glib/glib.rc
+    gmodule/makefile.msc
+    gmodule/gmodule.rc
+    gobject/makefile.msc
+    gobject/gobject.rc
+    gthread/makefile.msc
+    gthread/gthread.rc
+    gio/gio.rc
+    tests/makefile.msc
+  ])
+fi
+
+AC_OUTPUT
diff -urN glib-2.51.0.org/gio/glocalfileinfo.c glib-2.51.0/gio/glocalfileinfo.c
--- glib-2.51.0.org/gio/glocalfileinfo.c	2016-10-24 12:21:57.000000000 +0200
+++ glib-2.51.0/gio/glocalfileinfo.c	2016-10-28 22:58:56.891556576 +0200
@@ -1228,7 +1228,7 @@
       (symlink_broken || (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS)))
     return g_content_type_from_mime_type ("inode/symlink");
   else if (statbuf != NULL && S_ISDIR(statbuf->st_mode))
-    return g_content_type_from_mime_type ("inode/directory");
+    return g_strdup ("inode/directory");
 #ifndef G_OS_WIN32
   else if (statbuf != NULL && S_ISCHR(statbuf->st_mode))
     return g_content_type_from_mime_type ("inode/chardevice");
diff -urN glib-2.51.0.org/gio/glocalfileinfo.c.orig glib-2.51.0/gio/glocalfileinfo.c.orig
--- glib-2.51.0.org/gio/glocalfileinfo.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ glib-2.51.0/gio/glocalfileinfo.c.orig	2016-10-24 12:21:57.000000000 +0200
@@ -0,0 +1,2683 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2006-2007 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Alexander Larsson <alexl@redhat.com>
+ */
+
+#include "config.h"
+
+#include <glib.h>
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#ifdef G_OS_UNIX
+#include <grp.h>
+#include <pwd.h>
+#endif
+#ifdef HAVE_SELINUX
+#include <selinux/selinux.h>
+#endif
+
+#ifdef HAVE_XATTR
+
+#if defined HAVE_SYS_XATTR_H
+  #include <sys/xattr.h>
+#elif defined HAVE_ATTR_XATTR_H
+  #include <attr/xattr.h>
+#else
+  #error "Neither <sys/xattr.h> nor <attr/xattr.h> is present but extended attribute support is enabled."
+#endif /* defined HAVE_SYS_XATTR_H || HAVE_ATTR_XATTR_H */
+
+#endif /* HAVE_XATTR */
+
+#include <glib/gstdio.h>
+#include <gfileattribute-priv.h>
+#include <gfileinfo-priv.h>
+#include <gvfs.h>
+
+#ifdef G_OS_UNIX
+#include <unistd.h>
+#include "glib-unix.h"
+#include "glib-private.h"
+#endif
+
+#include "thumbnail-verify.h"
+
+#ifdef G_OS_WIN32
+#include <windows.h>
+#include <io.h>
+#ifndef W_OK
+#define W_OK 2
+#endif
+#ifndef R_OK
+#define R_OK 4
+#endif
+#ifndef X_OK
+#define X_OK 0 /* not really */
+#endif
+#ifndef S_ISREG
+#define S_ISREG(m) (((m) & _S_IFMT) == _S_IFREG)
+#endif
+#ifndef S_ISDIR
+#define S_ISDIR(m) (((m) & _S_IFMT) == _S_IFDIR)
+#endif
+#ifndef S_IXUSR
+#define S_IXUSR _S_IEXEC
+#endif
+#endif
+
+#include "glocalfileinfo.h"
+#include "gioerror.h"
+#include "gthemedicon.h"
+#include "gcontenttypeprivate.h"
+#include "glibintl.h"
+
+
+struct ThumbMD5Context {
+	guint32 buf[4];
+	guint32 bits[2];
+	unsigned char in[64];
+};
+
+#ifndef G_OS_WIN32
+
+typedef struct {
+  char *user_name;
+  char *real_name;
+} UidData;
+
+G_LOCK_DEFINE_STATIC (uid_cache);
+static GHashTable *uid_cache = NULL;
+
+G_LOCK_DEFINE_STATIC (gid_cache);
+static GHashTable *gid_cache = NULL;
+
+#endif  /* !G_OS_WIN32 */
+
+char *
+_g_local_file_info_create_etag (GLocalFileStat *statbuf)
+{
+  glong sec, usec;
+
+  sec = statbuf->st_mtime;
+#if defined (HAVE_STRUCT_STAT_ST_MTIMENSEC)
+  usec = statbuf->st_mtimensec / 1000;
+#elif defined (HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
+  usec = statbuf->st_mtim.tv_nsec / 1000;
+#else
+  usec = 0;
+#endif
+
+  return g_strdup_printf ("%lu:%lu", sec, usec);
+}
+
+static char *
+_g_local_file_info_create_file_id (GLocalFileStat *statbuf)
+{
+  return g_strdup_printf ("l%" G_GUINT64_FORMAT ":%" G_GUINT64_FORMAT,
+			  (guint64) statbuf->st_dev, 
+			  (guint64) statbuf->st_ino);
+}
+
+static char *
+_g_local_file_info_create_fs_id (GLocalFileStat *statbuf)
+{
+  return g_strdup_printf ("l%" G_GUINT64_FORMAT,
+			  (guint64) statbuf->st_dev);
+}
+
+
+#ifdef S_ISLNK
+
+static gchar *
+read_link (const gchar *full_name)
+{
+#ifdef HAVE_READLINK
+  gchar *buffer;
+  guint size;
+  
+  size = 256;
+  buffer = g_malloc (size);
+  
+  while (1)
+    {
+      int read_size;
+      
+      read_size = readlink (full_name, buffer, size);
+      if (read_size < 0)
+	{
+	  g_free (buffer);
+	  return NULL;
+	}
+      if (read_size < size)
+	{
+	  buffer[read_size] = 0;
+	  return buffer;
+	}
+      size *= 2;
+      buffer = g_realloc (buffer, size);
+    }
+#else
+  return NULL;
+#endif
+}
+
+#endif  /* S_ISLNK */
+
+#ifdef HAVE_SELINUX
+/* Get the SELinux security context */
+static void
+get_selinux_context (const char            *path,
+		     GFileInfo             *info,
+		     GFileAttributeMatcher *attribute_matcher,
+		     gboolean               follow_symlinks)
+{
+  char *context;
+
+  if (!_g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_SELINUX_CONTEXT))
+    return;
+  
+  if (is_selinux_enabled ())
+    {
+      if (follow_symlinks)
+	{
+	  if (lgetfilecon_raw (path, &context) < 0)
+	    return;
+	}
+      else
+	{
+	  if (getfilecon_raw (path, &context) < 0)
+	    return;
+	}
+
+      if (context)
+	{
+	  _g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_SELINUX_CONTEXT, context);
+	  freecon (context);
+	}
+    }
+}
+#endif
+
+#ifdef HAVE_XATTR
+
+/* Wrappers to hide away differences between (Linux) getxattr/lgetxattr and
+ * (Mac) getxattr(..., XATTR_NOFOLLOW)
+ */
+#ifdef HAVE_XATTR_NOFOLLOW
+#define g_fgetxattr(fd,name,value,size)  fgetxattr(fd,name,value,size,0,0)
+#define g_flistxattr(fd,name,size)       flistxattr(fd,name,size,0)
+#define g_setxattr(path,name,value,size) setxattr(path,name,value,size,0,0)
+#else
+#define g_fgetxattr     fgetxattr
+#define g_flistxattr    flistxattr
+#define g_setxattr(path,name,value,size) setxattr(path,name,value,size,0)
+#endif
+
+static ssize_t
+g_getxattr (const char *path, const char *name, void *value, size_t size,
+            gboolean follow_symlinks)
+{
+#ifdef HAVE_XATTR_NOFOLLOW
+  return getxattr (path, name, value, size, 0, follow_symlinks ? 0 : XATTR_NOFOLLOW);
+#else
+  if (follow_symlinks)
+    return getxattr (path, name, value, size);
+  else
+    return lgetxattr (path, name, value, size);
+#endif
+}
+
+static ssize_t
+g_listxattr(const char *path, char *namebuf, size_t size,
+            gboolean follow_symlinks)
+{
+#ifdef HAVE_XATTR_NOFOLLOW
+  return listxattr (path, namebuf, size, follow_symlinks ? 0 : XATTR_NOFOLLOW);
+#else
+  if (follow_symlinks)
+    return listxattr (path, namebuf, size);
+  else
+    return llistxattr (path, namebuf, size);
+#endif
+}
+
+static gboolean
+valid_char (char c)
+{
+  return c >= 32 && c <= 126 && c != '\\';
+}
+
+static gboolean
+name_is_valid (const char *str)
+{
+  while (*str)
+    {
+      if (!valid_char (*str++))
+	return FALSE;
+    }
+  return TRUE;
+}
+
+static char *
+hex_escape_string (const char *str, 
+                   gboolean   *free_return)
+{
+  int num_invalid, i;
+  char *escaped_str, *p;
+  unsigned char c;
+  static char *hex_digits = "0123456789abcdef";
+  int len;
+
+  len = strlen (str);
+  
+  num_invalid = 0;
+  for (i = 0; i < len; i++)
+    {
+      if (!valid_char (str[i]))
+	num_invalid++;
+    }
+
+  if (num_invalid == 0)
+    {
+      *free_return = FALSE;
+      return (char *)str;
+    }
+
+  escaped_str = g_malloc (len + num_invalid*3 + 1);
+
+  p = escaped_str;
+  for (i = 0; i < len; i++)
+    {
+      if (valid_char (str[i]))
+	*p++ = str[i];
+      else
+	{
+	  c = str[i];
+	  *p++ = '\\';
+	  *p++ = 'x';
+	  *p++ = hex_digits[(c >> 4) & 0xf];
+	  *p++ = hex_digits[c & 0xf];
+	}
+    }
+  *p = 0;
+
+  *free_return = TRUE;
+  return escaped_str;
+}
+
+static char *
+hex_unescape_string (const char *str, 
+                     int        *out_len, 
+                     gboolean   *free_return)
+{
+  int i;
+  char *unescaped_str, *p;
+  unsigned char c;
+  int len;
+
+  len = strlen (str);
+  
+  if (strchr (str, '\\') == NULL)
+    {
+      if (out_len)
+	*out_len = len;
+      *free_return = FALSE;
+      return (char *)str;
+    }
+  
+  unescaped_str = g_malloc (len + 1);
+
+  p = unescaped_str;
+  for (i = 0; i < len; i++)
+    {
+      if (str[i] == '\\' &&
+	  str[i+1] == 'x' &&
+	  len - i >= 4)
+	{
+	  c =
+	    (g_ascii_xdigit_value (str[i+2]) << 4) |
+	    g_ascii_xdigit_value (str[i+3]);
+	  *p++ = c;
+	  i += 3;
+	}
+      else
+	*p++ = str[i];
+    }
+  *p++ = 0;
+
+  if (out_len)
+    *out_len = p - unescaped_str;
+  *free_return = TRUE;
+  return unescaped_str;
+}
+
+static void
+escape_xattr (GFileInfo  *info,
+	      const char *gio_attr, /* gio attribute name */
+	      const char *value, /* Is zero terminated */
+	      size_t      len /* not including zero termination */)
+{
+  char *escaped_val;
+  gboolean free_escaped_val;
+  
+  escaped_val = hex_escape_string (value, &free_escaped_val);
+  
+  g_file_info_set_attribute_string (info, gio_attr, escaped_val);
+  
+  if (free_escaped_val)
+    g_free (escaped_val);
+}
+
+static void
+get_one_xattr (const char *path,
+	       GFileInfo  *info,
+	       const char *gio_attr,
+	       const char *xattr,
+	       gboolean    follow_symlinks)
+{
+  char value[64];
+  char *value_p;
+  ssize_t len;
+
+  len = g_getxattr (path, xattr, value, sizeof (value)-1, follow_symlinks);
+
+  value_p = NULL;
+  if (len >= 0)
+    value_p = value;
+  else if (len == -1 && errno == ERANGE)
+    {
+      len = g_getxattr (path, xattr, NULL, 0, follow_symlinks);
+
+      if (len < 0)
+	return;
+
+      value_p = g_malloc (len+1);
+
+      len = g_getxattr (path, xattr, value_p, len, follow_symlinks);
+
+      if (len < 0)
+	{
+	  g_free (value_p);
+	  return;
+	}
+    }
+  else
+    return;
+  
+  /* Null terminate */
+  value_p[len] = 0;
+
+  escape_xattr (info, gio_attr, value_p, len);
+  
+  if (value_p != value)
+    g_free (value_p);
+}
+
+#endif /* defined HAVE_XATTR */
+
+static void
+get_xattrs (const char            *path,
+	    gboolean               user,
+	    GFileInfo             *info,
+	    GFileAttributeMatcher *matcher,
+	    gboolean               follow_symlinks)
+{
+#ifdef HAVE_XATTR
+  gboolean all;
+  gsize list_size;
+  ssize_t list_res_size;
+  size_t len;
+  char *list;
+  const char *attr, *attr2;
+
+  if (user)
+    all = g_file_attribute_matcher_enumerate_namespace (matcher, "xattr");
+  else
+    all = g_file_attribute_matcher_enumerate_namespace (matcher, "xattr-sys");
+
+  if (all)
+    {
+      list_res_size = g_listxattr (path, NULL, 0, follow_symlinks);
+
+      if (list_res_size == -1 ||
+	  list_res_size == 0)
+	return;
+
+      list_size = list_res_size;
+      list = g_malloc (list_size);
+
+    retry:
+      
+      list_res_size = g_listxattr (path, list, list_size, follow_symlinks);
+      
+      if (list_res_size == -1 && errno == ERANGE)
+	{
+	  list_size = list_size * 2;
+	  list = g_realloc (list, list_size);
+	  goto retry;
+	}
+
+      if (list_res_size == -1)
+	return;
+
+      attr = list;
+      while (list_res_size > 0)
+	{
+	  if ((user && g_str_has_prefix (attr, "user.")) ||
+	      (!user && !g_str_has_prefix (attr, "user.")))
+	    {
+	      char *escaped_attr, *gio_attr;
+	      gboolean free_escaped_attr;
+	      
+	      if (user)
+		{
+		  escaped_attr = hex_escape_string (attr + 5, &free_escaped_attr);
+		  gio_attr = g_strconcat ("xattr::", escaped_attr, NULL);
+		}
+	      else
+		{
+		  escaped_attr = hex_escape_string (attr, &free_escaped_attr);
+		  gio_attr = g_strconcat ("xattr-sys::", escaped_attr, NULL);
+		}
+	      
+	      if (free_escaped_attr)
+		g_free (escaped_attr);
+	      
+	      get_one_xattr (path, info, gio_attr, attr, follow_symlinks);
+
+	      g_free (gio_attr);
+	    }
+	      
+	  len = strlen (attr) + 1;
+	  attr += len;
+	  list_res_size -= len;
+	}
+
+      g_free (list);
+    }
+  else
+    {
+      while ((attr = g_file_attribute_matcher_enumerate_next (matcher)) != NULL)
+	{
+	  char *unescaped_attribute, *a;
+	  gboolean free_unescaped_attribute;
+
+	  attr2 = strchr (attr, ':');
+	  if (attr2)
+	    {
+	      attr2 += 2; /* Skip '::' */
+	      unescaped_attribute = hex_unescape_string (attr2, NULL, &free_unescaped_attribute);
+	      if (user)
+		a = g_strconcat ("user.", unescaped_attribute, NULL);
+	      else
+		a = unescaped_attribute;
+	      
+	      get_one_xattr (path, info, attr, a, follow_symlinks);
+
+	      if (user)
+		g_free (a);
+	      
+	      if (free_unescaped_attribute)
+		g_free (unescaped_attribute);
+	    }
+	}
+    }
+#endif /* defined HAVE_XATTR */
+}
+
+#ifdef HAVE_XATTR
+static void
+get_one_xattr_from_fd (int         fd,
+		       GFileInfo  *info,
+		       const char *gio_attr,
+		       const char *xattr)
+{
+  char value[64];
+  char *value_p;
+  ssize_t len;
+
+  len = g_fgetxattr (fd, xattr, value, sizeof (value) - 1);
+
+  value_p = NULL;
+  if (len >= 0)
+    value_p = value;
+  else if (len == -1 && errno == ERANGE)
+    {
+      len = g_fgetxattr (fd, xattr, NULL, 0);
+
+      if (len < 0)
+	return;
+
+      value_p = g_malloc (len + 1);
+
+      len = g_fgetxattr (fd, xattr, value_p, len);
+
+      if (len < 0)
+	{
+	  g_free (value_p);
+	  return;
+	}
+    }
+  else
+    return;
+  
+  /* Null terminate */
+  value_p[len] = 0;
+
+  escape_xattr (info, gio_attr, value_p, len);
+  
+  if (value_p != value)
+    g_free (value_p);
+}
+#endif /* defined HAVE_XATTR */
+
+static void
+get_xattrs_from_fd (int                    fd,
+		    gboolean               user,
+		    GFileInfo             *info,
+		    GFileAttributeMatcher *matcher)
+{
+#ifdef HAVE_XATTR
+  gboolean all;
+  gsize list_size;
+  ssize_t list_res_size;
+  size_t len;
+  char *list;
+  const char *attr, *attr2;
+
+  if (user)
+    all = g_file_attribute_matcher_enumerate_namespace (matcher, "xattr");
+  else
+    all = g_file_attribute_matcher_enumerate_namespace (matcher, "xattr-sys");
+
+  if (all)
+    {
+      list_res_size = g_flistxattr (fd, NULL, 0);
+
+      if (list_res_size == -1 ||
+	  list_res_size == 0)
+	return;
+
+      list_size = list_res_size;
+      list = g_malloc (list_size);
+
+    retry:
+      
+      list_res_size = g_flistxattr (fd, list, list_size);
+      
+      if (list_res_size == -1 && errno == ERANGE)
+	{
+	  list_size = list_size * 2;
+	  list = g_realloc (list, list_size);
+	  goto retry;
+	}
+
+      if (list_res_size == -1)
+	return;
+
+      attr = list;
+      while (list_res_size > 0)
+	{
+	  if ((user && g_str_has_prefix (attr, "user.")) ||
+	      (!user && !g_str_has_prefix (attr, "user.")))
+	    {
+	      char *escaped_attr, *gio_attr;
+	      gboolean free_escaped_attr;
+	      
+	      if (user)
+		{
+		  escaped_attr = hex_escape_string (attr + 5, &free_escaped_attr);
+		  gio_attr = g_strconcat ("xattr::", escaped_attr, NULL);
+		}
+	      else
+		{
+		  escaped_attr = hex_escape_string (attr, &free_escaped_attr);
+		  gio_attr = g_strconcat ("xattr-sys::", escaped_attr, NULL);
+		}
+	      
+	      if (free_escaped_attr)
+		g_free (escaped_attr);
+	      
+	      get_one_xattr_from_fd (fd, info, gio_attr, attr);
+	      g_free (gio_attr);
+	    }
+	  
+	  len = strlen (attr) + 1;
+	  attr += len;
+	  list_res_size -= len;
+	}
+
+      g_free (list);
+    }
+  else
+    {
+      while ((attr = g_file_attribute_matcher_enumerate_next (matcher)) != NULL)
+	{
+	  char *unescaped_attribute, *a;
+	  gboolean free_unescaped_attribute;
+
+	  attr2 = strchr (attr, ':');
+	  if (attr2)
+	    {
+	      attr2++; /* Skip ':' */
+	      unescaped_attribute = hex_unescape_string (attr2, NULL, &free_unescaped_attribute);
+	      if (user)
+		a = g_strconcat ("user.", unescaped_attribute, NULL);
+	      else
+		a = unescaped_attribute;
+	      
+	      get_one_xattr_from_fd (fd, info, attr, a);
+
+	      if (user)
+		g_free (a);
+	      
+	      if (free_unescaped_attribute)
+		g_free (unescaped_attribute);
+	    }
+	}
+    }
+#endif /* defined HAVE_XATTR */
+}
+
+#ifdef HAVE_XATTR
+static gboolean
+set_xattr (char                       *filename,
+	   const char                 *escaped_attribute,
+	   const GFileAttributeValue  *attr_value,
+	   GError                    **error)
+{
+  char *attribute, *value;
+  gboolean free_attribute, free_value;
+  int val_len, res, errsv;
+  gboolean is_user;
+  char *a;
+
+  if (attr_value == NULL)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Attribute value must be non-NULL"));
+      return FALSE;
+    }
+
+  if (attr_value->type != G_FILE_ATTRIBUTE_TYPE_STRING)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Invalid attribute type (string expected)"));
+      return FALSE;
+    }
+
+  if (!name_is_valid (escaped_attribute))
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Invalid extended attribute name"));
+      return FALSE;
+    }
+
+  if (g_str_has_prefix (escaped_attribute, "xattr::"))
+    {
+      escaped_attribute += strlen ("xattr::");
+      is_user = TRUE;
+    }
+  else
+    {
+      g_warn_if_fail (g_str_has_prefix (escaped_attribute, "xattr-sys::"));
+      escaped_attribute += strlen ("xattr-sys::");
+      is_user = FALSE;
+    }
+  
+  attribute = hex_unescape_string (escaped_attribute, NULL, &free_attribute);
+  value = hex_unescape_string (attr_value->u.string, &val_len, &free_value);
+
+  if (is_user)
+    a = g_strconcat ("user.", attribute, NULL);
+  else
+    a = attribute;
+  
+  res = g_setxattr (filename, a, value, val_len);
+  errsv = errno;
+  
+  if (is_user)
+    g_free (a);
+  
+  if (free_attribute)
+    g_free (attribute);
+  
+  if (free_value)
+    g_free (value);
+
+  if (res == -1)
+    {
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting extended attribute %s: %s"),
+		   escaped_attribute, g_strerror (errsv));
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+
+#endif
+
+
+void
+_g_local_file_info_get_parent_info (const char            *dir,
+				    GFileAttributeMatcher *attribute_matcher,
+				    GLocalParentFileInfo  *parent_info)
+{
+  GStatBuf statbuf;
+  int res;
+
+  parent_info->extra_data = NULL;
+  parent_info->free_extra_data = NULL;
+  parent_info->writable = FALSE;
+  parent_info->is_sticky = FALSE;
+  parent_info->has_trash_dir = FALSE;
+  parent_info->device = 0;
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_RENAME) ||
+      _g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_DELETE) ||
+      _g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_TRASH) ||
+      _g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_UNIX_IS_MOUNTPOINT))
+    {
+      /* FIXME: Windows: The underlying _waccess() call in the C
+       * library is mostly pointless as it only looks at the READONLY
+       * FAT-style attribute of the file, it doesn't check the ACL at
+       * all.
+       */
+      parent_info->writable = (g_access (dir, W_OK) == 0);
+      
+      res = g_stat (dir, &statbuf);
+
+      /*
+       * The sticky bit (S_ISVTX) on a directory means that a file in that directory can be
+       * renamed or deleted only by the owner of the file, by the owner of the directory, and
+       * by a privileged process.
+       */
+      if (res == 0)
+	{
+#ifdef S_ISVTX
+	  parent_info->is_sticky = (statbuf.st_mode & S_ISVTX) != 0;
+#else
+	  parent_info->is_sticky = FALSE;
+#endif
+	  parent_info->owner = statbuf.st_uid;
+	  parent_info->device = statbuf.st_dev;
+          /* No need to find trash dir if it's not writable anyway */
+          if (parent_info->writable &&
+              _g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_TRASH))
+            parent_info->has_trash_dir = _g_local_file_has_trash_dir (dir, statbuf.st_dev);
+	}
+    }
+}
+
+void
+_g_local_file_info_free_parent_info (GLocalParentFileInfo *parent_info)
+{
+  if (parent_info->extra_data &&
+      parent_info->free_extra_data)
+    parent_info->free_extra_data (parent_info->extra_data);
+}
+
+static void
+get_access_rights (GFileAttributeMatcher *attribute_matcher,
+		   GFileInfo             *info,
+		   const gchar           *path,
+		   GLocalFileStat        *statbuf,
+		   GLocalParentFileInfo  *parent_info)
+{
+  /* FIXME: Windows: The underlyin _waccess() is mostly pointless */
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_ACCESS_CAN_READ))
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_READ,
+				             g_access (path, R_OK) == 0);
+  
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_ACCESS_CAN_WRITE))
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_WRITE,
+				             g_access (path, W_OK) == 0);
+  
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_ACCESS_CAN_EXECUTE))
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_EXECUTE,
+				             g_access (path, X_OK) == 0);
+
+
+  if (parent_info)
+    {
+      gboolean writable;
+
+      writable = FALSE;
+      if (parent_info->writable)
+	{
+	  if (parent_info->is_sticky)
+	    {
+#ifndef G_OS_WIN32
+	      uid_t uid = geteuid ();
+
+	      if (uid == statbuf->st_uid ||
+		  uid == parent_info->owner ||
+		  uid == 0)
+#endif
+		writable = TRUE;
+	    }
+	  else
+	    writable = TRUE;
+	}
+
+      if (_g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_RENAME))
+	_g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_RENAME,
+					         writable);
+      
+      if (_g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_DELETE))
+	_g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_DELETE,
+					         writable);
+
+      if (_g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_TRASH))
+        _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_ACCESS_CAN_TRASH,
+                                                 writable && parent_info->has_trash_dir);
+    }
+}
+
+static void
+set_info_from_stat (GFileInfo             *info, 
+                    GLocalFileStat        *statbuf,
+		    GFileAttributeMatcher *attribute_matcher)
+{
+  GFileType file_type;
+
+  file_type = G_FILE_TYPE_UNKNOWN;
+
+  if (S_ISREG (statbuf->st_mode))
+    file_type = G_FILE_TYPE_REGULAR;
+  else if (S_ISDIR (statbuf->st_mode))
+    file_type = G_FILE_TYPE_DIRECTORY;
+#ifndef G_OS_WIN32
+  else if (S_ISCHR (statbuf->st_mode) ||
+	   S_ISBLK (statbuf->st_mode) ||
+	   S_ISFIFO (statbuf->st_mode)
+#ifdef S_ISSOCK
+	   || S_ISSOCK (statbuf->st_mode)
+#endif
+	   )
+    file_type = G_FILE_TYPE_SPECIAL;
+#endif
+#ifdef S_ISLNK
+  else if (S_ISLNK (statbuf->st_mode))
+    file_type = G_FILE_TYPE_SYMBOLIC_LINK;
+#endif
+
+  g_file_info_set_file_type (info, file_type);
+  g_file_info_set_size (info, statbuf->st_size);
+
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_DEVICE, statbuf->st_dev);
+#ifndef G_OS_WIN32
+  /* Pointless setting these on Windows even if they exist in the struct */
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_INODE, statbuf->st_ino);
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_NLINK, statbuf->st_nlink);
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_UID, statbuf->st_uid);
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_GID, statbuf->st_gid);
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_RDEV, statbuf->st_rdev);
+#endif
+  /* FIXME: st_mode is mostly pointless on Windows, too. Set the attribute or not? */
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_MODE, statbuf->st_mode);
+#if defined (HAVE_STRUCT_STAT_ST_BLKSIZE)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_BLOCK_SIZE, statbuf->st_blksize);
+#endif
+#if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_BLOCKS, statbuf->st_blocks);
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_STANDARD_ALLOCATED_SIZE,
+                                          statbuf->st_blocks * G_GUINT64_CONSTANT (512));
+#endif
+  
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_MODIFIED, statbuf->st_mtime);
+#if defined (HAVE_STRUCT_STAT_ST_MTIMENSEC)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_MODIFIED_USEC, statbuf->st_mtimensec / 1000);
+#elif defined (HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_MODIFIED_USEC, statbuf->st_mtim.tv_nsec / 1000);
+#endif
+  
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_ACCESS, statbuf->st_atime);
+#if defined (HAVE_STRUCT_STAT_ST_ATIMENSEC)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_ACCESS_USEC, statbuf->st_atimensec / 1000);
+#elif defined (HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_ACCESS_USEC, statbuf->st_atim.tv_nsec / 1000);
+#endif
+  
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CHANGED, statbuf->st_ctime);
+#if defined (HAVE_STRUCT_STAT_ST_CTIMENSEC)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CHANGED_USEC, statbuf->st_ctimensec / 1000);
+#elif defined (HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC)
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CHANGED_USEC, statbuf->st_ctim.tv_nsec / 1000);
+#endif
+
+#if defined (HAVE_STRUCT_STAT_ST_BIRTHTIME) && defined (HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC)
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtime);
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED_USEC, statbuf->st_birthtimensec / 1000);
+#elif defined (HAVE_STRUCT_STAT_ST_BIRTHTIM) && defined (HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC)
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtim.tv_sec);
+  _g_file_info_set_attribute_uint32_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED_USEC, statbuf->st_birthtim.tv_nsec / 1000);
+#elif defined (HAVE_STRUCT_STAT_ST_BIRTHTIME)
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtime);
+#elif defined (HAVE_STRUCT_STAT_ST_BIRTHTIM)
+  _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_TIME_CREATED, statbuf->st_birthtim);
+#endif
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_ETAG_VALUE))
+    {
+      char *etag = _g_local_file_info_create_etag (statbuf);
+      _g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_ETAG_VALUE, etag);
+      g_free (etag);
+    }
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_ID_FILE))
+    {
+      char *id = _g_local_file_info_create_file_id (statbuf);
+      _g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_ID_FILE, id);
+      g_free (id);
+    }
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_ID_FILESYSTEM))
+    {
+      char *id = _g_local_file_info_create_fs_id (statbuf);
+      _g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_ID_FILESYSTEM, id);
+      g_free (id);
+    }
+}
+
+#ifndef G_OS_WIN32
+
+static char *
+make_valid_utf8 (const char *name)
+{
+  GString *string;
+  const gchar *remainder, *invalid;
+  gint remaining_bytes, valid_bytes;
+  
+  string = NULL;
+  remainder = name;
+  remaining_bytes = strlen (name);
+  
+  while (remaining_bytes != 0) 
+    {
+      if (g_utf8_validate (remainder, remaining_bytes, &invalid)) 
+	break;
+      valid_bytes = invalid - remainder;
+    
+      if (string == NULL) 
+	string = g_string_sized_new (remaining_bytes);
+
+      g_string_append_len (string, remainder, valid_bytes);
+      /* append U+FFFD REPLACEMENT CHARACTER */
+      g_string_append (string, "\357\277\275");
+      
+      remaining_bytes -= valid_bytes + 1;
+      remainder = invalid + 1;
+    }
+  
+  if (string == NULL)
+    return g_strdup (name);
+  
+  g_string_append (string, remainder);
+
+  g_warn_if_fail (g_utf8_validate (string->str, -1, NULL));
+  
+  return g_string_free (string, FALSE);
+}
+
+static char *
+convert_pwd_string_to_utf8 (char *pwd_str)
+{
+  char *utf8_string;
+  
+  if (!g_utf8_validate (pwd_str, -1, NULL))
+    {
+      utf8_string = g_locale_to_utf8 (pwd_str, -1, NULL, NULL, NULL);
+      if (utf8_string == NULL)
+	utf8_string = make_valid_utf8 (pwd_str);
+    }
+  else 
+    utf8_string = g_strdup (pwd_str);
+  
+  return utf8_string;
+}
+
+static void
+uid_data_free (UidData *data)
+{
+  g_free (data->user_name);
+  g_free (data->real_name);
+  g_free (data);
+}
+
+/* called with lock held */
+static UidData *
+lookup_uid_data (uid_t uid)
+{
+  UidData *data;
+  char buffer[4096];
+  struct passwd pwbuf;
+  struct passwd *pwbufp;
+  char *gecos, *comma;
+  
+  if (uid_cache == NULL)
+    uid_cache = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)uid_data_free);
+
+  data = g_hash_table_lookup (uid_cache, GINT_TO_POINTER (uid));
+
+  if (data)
+    return data;
+
+  data = g_new0 (UidData, 1);
+
+#if defined(HAVE_GETPWUID_R)
+  getpwuid_r (uid, &pwbuf, buffer, sizeof(buffer), &pwbufp);
+#else
+  pwbufp = getpwuid (uid);
+#endif
+
+  if (pwbufp != NULL)
+    {
+      if (pwbufp->pw_name != NULL && pwbufp->pw_name[0] != 0)
+	data->user_name = convert_pwd_string_to_utf8 (pwbufp->pw_name);
+
+#ifndef __BIONIC__
+      gecos = pwbufp->pw_gecos;
+
+      if (gecos)
+	{
+	  comma = strchr (gecos, ',');
+	  if (comma)
+	    *comma = 0;
+	  data->real_name = convert_pwd_string_to_utf8 (gecos);
+	}
+#endif
+    }
+
+  /* Default fallbacks */
+  if (data->real_name == NULL)
+    {
+      if (data->user_name != NULL)
+	data->real_name = g_strdup (data->user_name);
+      else
+	data->real_name = g_strdup_printf ("user #%d", (int)uid);
+    }
+  
+  if (data->user_name == NULL)
+    data->user_name = g_strdup_printf ("%d", (int)uid);
+  
+  g_hash_table_replace (uid_cache, GINT_TO_POINTER (uid), data);
+  
+  return data;
+}
+
+static char *
+get_username_from_uid (uid_t uid)
+{
+  char *res;
+  UidData *data;
+  
+  G_LOCK (uid_cache);
+  data = lookup_uid_data (uid);
+  res = g_strdup (data->user_name);  
+  G_UNLOCK (uid_cache);
+
+  return res;
+}
+
+static char *
+get_realname_from_uid (uid_t uid)
+{
+  char *res;
+  UidData *data;
+  
+  G_LOCK (uid_cache);
+  data = lookup_uid_data (uid);
+  res = g_strdup (data->real_name);  
+  G_UNLOCK (uid_cache);
+  
+  return res;
+}
+
+/* called with lock held */
+static char *
+lookup_gid_name (gid_t gid)
+{
+  char *name;
+  char buffer[4096];
+  struct group gbuf;
+  struct group *gbufp;
+  
+  if (gid_cache == NULL)
+    gid_cache = g_hash_table_new_full (NULL, NULL, NULL, (GDestroyNotify)g_free);
+
+  name = g_hash_table_lookup (gid_cache, GINT_TO_POINTER (gid));
+
+  if (name)
+    return name;
+
+#if defined (HAVE_GETGRGID_R)
+  getgrgid_r (gid, &gbuf, buffer, sizeof(buffer), &gbufp);
+#else
+  gbufp = getgrgid (gid);
+#endif
+
+  if (gbufp != NULL &&
+      gbufp->gr_name != NULL &&
+      gbufp->gr_name[0] != 0)
+    name = convert_pwd_string_to_utf8 (gbufp->gr_name);
+  else
+    name = g_strdup_printf("%d", (int)gid);
+  
+  g_hash_table_replace (gid_cache, GINT_TO_POINTER (gid), name);
+  
+  return name;
+}
+
+static char *
+get_groupname_from_gid (gid_t gid)
+{
+  char *res;
+  char *name;
+  
+  G_LOCK (gid_cache);
+  name = lookup_gid_name (gid);
+  res = g_strdup (name);  
+  G_UNLOCK (gid_cache);
+  return res;
+}
+
+#endif /* !G_OS_WIN32 */
+
+static char *
+get_content_type (const char          *basename,
+		  const char          *path,
+		  GLocalFileStat      *statbuf,
+		  gboolean             is_symlink,
+		  gboolean             symlink_broken,
+		  GFileQueryInfoFlags  flags,
+		  gboolean             fast)
+{
+  if (is_symlink &&
+      (symlink_broken || (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS)))
+    return g_content_type_from_mime_type ("inode/symlink");
+  else if (statbuf != NULL && S_ISDIR(statbuf->st_mode))
+    return g_content_type_from_mime_type ("inode/directory");
+#ifndef G_OS_WIN32
+  else if (statbuf != NULL && S_ISCHR(statbuf->st_mode))
+    return g_content_type_from_mime_type ("inode/chardevice");
+  else if (statbuf != NULL && S_ISBLK(statbuf->st_mode))
+    return g_content_type_from_mime_type ("inode/blockdevice");
+  else if (statbuf != NULL && S_ISFIFO(statbuf->st_mode))
+    return g_content_type_from_mime_type ("inode/fifo");
+  else if (statbuf != NULL && S_ISREG(statbuf->st_mode) && statbuf->st_size == 0)
+    {
+      /* Don't sniff zero-length files in order to avoid reading files
+       * that appear normal but are not (eg: files in /proc and /sys)
+       *
+       * Note that we need to return text/plain here so that
+       * newly-created text files are opened by the text editor.
+       * See https://bugzilla.gnome.org/show_bug.cgi?id=755795
+       */
+      return g_content_type_from_mime_type ("text/plain");
+    }
+#endif
+#ifdef S_ISSOCK
+  else if (statbuf != NULL && S_ISSOCK(statbuf->st_mode))
+    return g_content_type_from_mime_type ("inode/socket");
+#endif
+  else
+    {
+      char *content_type;
+      gboolean result_uncertain;
+
+      content_type = g_content_type_guess (basename, NULL, 0, &result_uncertain);
+      
+#ifndef G_OS_WIN32
+      if (!fast && result_uncertain && path != NULL)
+	{
+	  guchar sniff_buffer[4096];
+	  gsize sniff_length;
+	  int fd;
+
+	  sniff_length = _g_unix_content_type_get_sniff_len ();
+	  if (sniff_length > 4096)
+	    sniff_length = 4096;
+
+#ifdef O_NOATIME	  
+          fd = g_open (path, O_RDONLY | O_NOATIME, 0);
+          if (fd < 0 && errno == EPERM)
+#endif
+	    fd = g_open (path, O_RDONLY, 0);
+
+	  if (fd != -1)
+	    {
+	      ssize_t res;
+	      
+	      res = read (fd, sniff_buffer, sniff_length);
+	      (void) g_close (fd, NULL);
+	      if (res >= 0)
+		{
+		  g_free (content_type);
+		  content_type = g_content_type_guess (basename, sniff_buffer, res, NULL);
+		}
+	    }
+	}
+#endif
+      
+      return content_type;
+    }
+  
+}
+
+/* @stat_buf is the pre-calculated result of stat(path), or %NULL if that failed. */
+static void
+get_thumbnail_attributes (const char     *path,
+                          GFileInfo      *info,
+                          const GLocalFileStat *stat_buf)
+{
+  GChecksum *checksum;
+  char *uri;
+  char *filename;
+  char *basename;
+
+  uri = g_filename_to_uri (path, NULL, NULL);
+
+  checksum = g_checksum_new (G_CHECKSUM_MD5);
+  g_checksum_update (checksum, (const guchar *) uri, strlen (uri));
+
+  basename = g_strconcat (g_checksum_get_string (checksum), ".png", NULL);
+  g_checksum_free (checksum);
+
+  filename = g_build_filename (g_get_user_cache_dir (),
+                               "thumbnails", "large", basename,
+                               NULL);
+
+  if (g_file_test (filename, G_FILE_TEST_IS_REGULAR))
+    {
+      _g_file_info_set_attribute_byte_string_by_id (info, G_FILE_ATTRIBUTE_ID_THUMBNAIL_PATH, filename);
+      _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_THUMBNAIL_IS_VALID,
+                                                thumbnail_verify (filename, uri, stat_buf));
+    }
+  else
+    {
+      g_free (filename);
+      filename = g_build_filename (g_get_user_cache_dir (),
+                                   "thumbnails", "normal", basename,
+                                   NULL);
+
+      if (g_file_test (filename, G_FILE_TEST_IS_REGULAR))
+        {
+          _g_file_info_set_attribute_byte_string_by_id (info, G_FILE_ATTRIBUTE_ID_THUMBNAIL_PATH, filename);
+          _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_THUMBNAIL_IS_VALID,
+                                                    thumbnail_verify (filename, uri, stat_buf));
+        }
+      else
+        {
+          g_free (filename);
+          filename = g_build_filename (g_get_user_cache_dir (),
+                                       "thumbnails", "fail",
+                                       "gnome-thumbnail-factory",
+                                       basename,
+                                       NULL);
+
+          if (g_file_test (filename, G_FILE_TEST_IS_REGULAR))
+            {
+              _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_THUMBNAILING_FAILED, TRUE);
+              _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_THUMBNAIL_IS_VALID,
+                                                        thumbnail_verify (filename, uri, stat_buf));
+            }
+        }
+    }
+  g_free (basename);
+  g_free (filename);
+  g_free (uri);
+}
+
+#ifdef G_OS_WIN32
+static void
+win32_get_file_user_info (const gchar  *filename,
+			  gchar       **group_name, 
+			  gchar       **user_name, 
+			  gchar       **real_name)
+{
+  PSECURITY_DESCRIPTOR psd = NULL;
+  DWORD sd_size = 0; /* first call calculates the size required */
+  
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  if ((GetFileSecurityW (wfilename, 
+                        GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
+			NULL,
+			sd_size,
+			&sd_size) || (ERROR_INSUFFICIENT_BUFFER == GetLastError())) &&
+     (psd = g_try_malloc (sd_size)) != NULL &&
+     GetFileSecurityW (wfilename, 
+                       GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
+		       psd,
+		       sd_size,
+		       &sd_size))
+    {
+      PSID psid = 0;
+      BOOL defaulted;
+      SID_NAME_USE name_use = 0; /* don't care? */
+      wchar_t *name = NULL;
+      wchar_t *domain = NULL;
+      DWORD name_len = 0;
+      DWORD domain_len = 0;
+      /* get the user name */
+      do {
+        if (!user_name)
+	  break;
+	if (!GetSecurityDescriptorOwner (psd, &psid, &defaulted))
+	  break;
+	if (!LookupAccountSidW (NULL, /* local machine */
+                                psid, 
+			        name, &name_len,
+			        domain, &domain_len, /* no domain info yet */
+			        &name_use)  && (ERROR_INSUFFICIENT_BUFFER != GetLastError()))
+	  break;
+	name = g_try_malloc (name_len * sizeof (wchar_t));
+	domain = g_try_malloc (domain_len * sizeof (wchar_t));
+	if (name && domain &&
+            LookupAccountSidW (NULL, /* local machine */
+                               psid, 
+			       name, &name_len,
+			       domain, &domain_len, /* no domain info yet */
+			       &name_use))
+	  {
+	    *user_name = g_utf16_to_utf8 (name, -1, NULL, NULL, NULL);
+	  }
+	g_free (name);
+	g_free (domain);
+      } while (FALSE);
+
+      /* get the group name */
+      do {
+        if (!group_name)
+	  break;
+	if (!GetSecurityDescriptorGroup (psd, &psid, &defaulted))
+	  break;
+	if (!LookupAccountSidW (NULL, /* local machine */
+                                psid, 
+			        name, &name_len,
+			        domain, &domain_len, /* no domain info yet */
+			        &name_use)  && (ERROR_INSUFFICIENT_BUFFER != GetLastError()))
+	  break;
+	name = g_try_malloc (name_len * sizeof (wchar_t));
+	domain = g_try_malloc (domain_len * sizeof (wchar_t));
+	if (name && domain &&
+            LookupAccountSidW (NULL, /* local machine */
+                               psid, 
+			       name, &name_len,
+			       domain, &domain_len, /* no domain info yet */
+			       &name_use))
+	  {
+	    *group_name = g_utf16_to_utf8 (name, -1, NULL, NULL, NULL);
+	  }
+	g_free (name);
+	g_free (domain);
+      } while (FALSE);
+
+      /* TODO: get real name */
+
+      g_free (psd);
+    }
+  g_free (wfilename);
+}
+#endif /* G_OS_WIN32 */
+
+#ifndef G_OS_WIN32
+/* support for '.hidden' files */
+G_LOCK_DEFINE_STATIC (hidden_cache);
+static GHashTable *hidden_cache;
+
+static gboolean
+remove_from_hidden_cache (gpointer user_data)
+{
+  G_LOCK (hidden_cache);
+  g_hash_table_remove (hidden_cache, user_data);
+  G_UNLOCK (hidden_cache);
+
+  return FALSE;
+}
+
+static GHashTable *
+read_hidden_file (const gchar *dirname)
+{
+  gchar *contents = NULL;
+  gchar *filename;
+
+  filename = g_build_path ("/", dirname, ".hidden", NULL);
+  (void) g_file_get_contents (filename, &contents, NULL, NULL);
+  g_free (filename);
+
+  if (contents != NULL)
+    {
+      GHashTable *table;
+      gchar **lines;
+      gint i;
+
+      table = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+
+      lines = g_strsplit (contents, "\n", 0);
+      g_free (contents);
+
+      for (i = 0; lines[i]; i++)
+        /* hash table takes the individual strings... */
+        g_hash_table_add (table, lines[i]);
+
+      /* ... so we only free the container. */
+      g_free (lines);
+
+      return table;
+    }
+  else
+    return NULL;
+}
+
+static void
+maybe_unref_hash_table (gpointer data)
+{
+  if (data != NULL)
+    g_hash_table_unref (data);
+}
+
+static gboolean
+file_is_hidden (const gchar *path,
+                const gchar *basename)
+{
+  gboolean result;
+  gchar *dirname;
+  gpointer table;
+
+  dirname = g_path_get_dirname (path);
+
+  G_LOCK (hidden_cache);
+
+  if G_UNLIKELY (hidden_cache == NULL)
+    hidden_cache = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                          g_free, maybe_unref_hash_table);
+
+  if (!g_hash_table_lookup_extended (hidden_cache, dirname,
+                                     NULL, &table))
+    {
+      gchar *mydirname;
+      GSource *remove_from_cache_source;
+
+      g_hash_table_insert (hidden_cache,
+                           mydirname = g_strdup (dirname),
+                           table = read_hidden_file (dirname));
+
+      remove_from_cache_source = g_timeout_source_new_seconds (5);
+      g_source_set_priority (remove_from_cache_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (remove_from_cache_source, 
+                             remove_from_hidden_cache, 
+                             mydirname, 
+                             NULL);
+      g_source_attach (remove_from_cache_source, 
+                       GLIB_PRIVATE_CALL (g_get_worker_context) ());
+      g_source_unref (remove_from_cache_source);
+    }
+
+  result = table != NULL && g_hash_table_contains (table, basename);
+
+  G_UNLOCK (hidden_cache);
+
+  g_free (dirname);
+
+  return result;
+}
+#endif /* !G_OS_WIN32 */
+
+void
+_g_local_file_info_get_nostat (GFileInfo              *info,
+                               const char             *basename,
+			       const char             *path,
+                               GFileAttributeMatcher  *attribute_matcher)
+{
+  g_file_info_set_name (info, basename);
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_DISPLAY_NAME))
+    {
+      char *display_name = g_filename_display_basename (path);
+     
+      /* look for U+FFFD REPLACEMENT CHARACTER */ 
+      if (strstr (display_name, "\357\277\275") != NULL)
+	{
+	  char *p = display_name;
+	  display_name = g_strconcat (display_name, _(" (invalid encoding)"), NULL);
+	  g_free (p);
+	}
+      g_file_info_set_display_name (info, display_name);
+      g_free (display_name);
+    }
+  
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_EDIT_NAME))
+    {
+      char *edit_name = g_filename_display_basename (path);
+      g_file_info_set_edit_name (info, edit_name);
+      g_free (edit_name);
+    }
+
+  
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_COPY_NAME))
+    {
+      char *copy_name = g_filename_to_utf8 (basename, -1, NULL, NULL, NULL);
+      if (copy_name)
+	_g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_STANDARD_COPY_NAME, copy_name);
+      g_free (copy_name);
+    }
+}
+
+static const char *
+get_icon_name (const char *path,
+               const char *content_type,
+               gboolean    use_symbolic,
+               gboolean   *with_fallbacks_out)
+{
+  const char *name = NULL;
+  gboolean with_fallbacks = TRUE;
+
+  if (strcmp (path, g_get_home_dir ()) == 0)
+    {
+      name = use_symbolic ? "user-home-symbolic" : "user-home";
+      with_fallbacks = FALSE;
+    }
+  else if (strcmp (path, g_get_user_special_dir (G_USER_DIRECTORY_DESKTOP)) == 0)
+    {
+      name = use_symbolic ? "user-desktop-symbolic" : "user-desktop";
+      with_fallbacks = FALSE;
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_DOCUMENTS)) == 0)
+    {
+      name = use_symbolic ? "folder-documents-symbolic" : "folder-documents";
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_DOWNLOAD)) == 0)
+    {
+      name = use_symbolic ? "folder-download-symbolic" : "folder-download";
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_MUSIC)) == 0)
+    {
+      name = use_symbolic ? "folder-music-symbolic" : "folder-music";
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_PICTURES)) == 0)
+    {
+      name = use_symbolic ? "folder-pictures-symbolic" : "folder-pictures";
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_PUBLIC_SHARE)) == 0)
+    {
+      name = use_symbolic ? "folder-publicshare-symbolic" : "folder-publicshare";
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_TEMPLATES)) == 0)
+    {
+      name = use_symbolic ? "folder-templates-symbolic" : "folder-templates";
+    }
+  else if (g_strcmp0 (path, g_get_user_special_dir (G_USER_DIRECTORY_VIDEOS)) == 0)
+    {
+      name = use_symbolic ? "folder-videos-symbolic" : "folder-videos";
+    }
+  else if (g_strcmp0 (content_type, "inode/directory") == 0)
+    {
+      name = use_symbolic ? "folder-symbolic" : "folder";
+    }
+  else
+    {
+      name = NULL;
+    }
+
+  if (with_fallbacks_out != NULL)
+    *with_fallbacks_out = with_fallbacks;
+
+  return name;
+}
+
+static GIcon *
+get_icon (const char *path,
+          const char *content_type,
+          gboolean    use_symbolic)
+{
+  GIcon *icon = NULL;
+  const char *icon_name;
+  gboolean with_fallbacks;
+
+  icon_name = get_icon_name (path, content_type, use_symbolic, &with_fallbacks);
+  if (icon_name != NULL)
+    {
+      if (with_fallbacks)
+        icon = g_themed_icon_new_with_default_fallbacks (icon_name);
+      else
+        icon = g_themed_icon_new (icon_name);
+    }
+  else
+    {
+      if (use_symbolic)
+        icon = g_content_type_get_symbolic_icon (content_type);
+      else
+        icon = g_content_type_get_icon (content_type);
+    }
+
+  return icon;
+}
+
+GFileInfo *
+_g_local_file_info_get (const char             *basename,
+			const char             *path,
+			GFileAttributeMatcher  *attribute_matcher,
+			GFileQueryInfoFlags     flags,
+			GLocalParentFileInfo   *parent_info,
+			GError                **error)
+{
+  GFileInfo *info;
+  GLocalFileStat statbuf;
+#ifdef S_ISLNK
+  struct stat statbuf2;
+#endif
+  int res;
+  gboolean stat_ok;
+  gboolean is_symlink, symlink_broken;
+#ifdef G_OS_WIN32
+  DWORD dos_attributes;
+#endif
+  char *symlink_target;
+  GVfs *vfs;
+  GVfsClass *class;
+  guint64 device;
+
+  info = g_file_info_new ();
+
+  /* Make sure we don't set any unwanted attributes */
+  g_file_info_set_attribute_mask (info, attribute_matcher);
+  
+  _g_local_file_info_get_nostat (info, basename, path, attribute_matcher);
+
+  if (attribute_matcher == NULL)
+    {
+      g_file_info_unset_attribute_mask (info);
+      return info;
+    }
+
+#ifndef G_OS_WIN32
+  res = g_lstat (path, &statbuf);
+#else
+  {
+    wchar_t *wpath = g_utf8_to_utf16 (path, -1, NULL, NULL, error);
+    int len;
+
+    if (wpath == NULL)
+      {
+        g_object_unref (info);
+        return NULL;
+      }
+
+    len = wcslen (wpath);
+    while (len > 0 && G_IS_DIR_SEPARATOR (wpath[len-1]))
+      len--;
+    if (len > 0 &&
+        (!g_path_is_absolute (path) || len > g_path_skip_root (path) - path))
+      wpath[len] = '\0';
+
+    res = _wstati64 (wpath, &statbuf);
+    dos_attributes = GetFileAttributesW (wpath);
+
+    g_free (wpath);
+  }
+#endif
+
+  if (res == -1)
+    {
+      int errsv = errno;
+
+      /* Don't bail out if we get Permission denied (SELinux?) */
+      if (errsv != EACCES)
+        {
+          char *display_name = g_filename_display_name (path);
+          g_object_unref (info);
+          g_set_error (error, G_IO_ERROR,
+		       g_io_error_from_errno (errsv),
+		       _("Error when getting information for file %s: %s"),
+		       display_name, g_strerror (errsv));
+          g_free (display_name);
+          return NULL;
+        }
+    }
+
+  /* Even if stat() fails, try to get as much as other attributes possible */
+  stat_ok = res != -1;
+
+  if (stat_ok)
+    device = statbuf.st_dev;
+  else
+    device = 0;
+
+#ifdef S_ISLNK
+  is_symlink = stat_ok && S_ISLNK (statbuf.st_mode);
+#else
+  is_symlink = FALSE;
+#endif
+  symlink_broken = FALSE;
+#ifdef S_ISLNK
+  if (is_symlink)
+    {
+      g_file_info_set_is_symlink (info, TRUE);
+
+      /* Unless NOFOLLOW was set we default to following symlinks */
+      if (!(flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS))
+	{
+	  res = stat (path, &statbuf2);
+
+	  /* Report broken links as symlinks */
+	  if (res != -1)
+	    {
+	      statbuf = statbuf2;
+	      stat_ok = TRUE;
+	    }
+	  else
+	    symlink_broken = TRUE;
+	}
+    }
+#endif
+
+  if (stat_ok)
+    set_info_from_stat (info, &statbuf, attribute_matcher);
+
+#ifdef G_OS_UNIX
+  if (stat_ok && _g_local_file_is_lost_found_dir (path, statbuf.st_dev))
+    g_file_info_set_is_hidden (info, TRUE);
+#endif
+
+#ifndef G_OS_WIN32
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_IS_HIDDEN))
+    {
+      if (basename != NULL &&
+          (basename[0] == '.' ||
+           file_is_hidden (path, basename)))
+        g_file_info_set_is_hidden (info, TRUE);
+    }
+
+  if (basename != NULL && basename[strlen (basename) -1] == '~' &&
+      (stat_ok && S_ISREG (statbuf.st_mode)))
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_STANDARD_IS_BACKUP, TRUE);
+#else
+  if (dos_attributes & FILE_ATTRIBUTE_HIDDEN)
+    g_file_info_set_is_hidden (info, TRUE);
+
+  if (dos_attributes & FILE_ATTRIBUTE_ARCHIVE)
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_DOS_IS_ARCHIVE, TRUE);
+
+  if (dos_attributes & FILE_ATTRIBUTE_SYSTEM)
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_DOS_IS_SYSTEM, TRUE);
+#endif
+
+  symlink_target = NULL;
+#ifdef S_ISLNK
+  if (is_symlink)
+    {
+      symlink_target = read_link (path);
+      if (symlink_target &&
+          _g_file_attribute_matcher_matches_id (attribute_matcher,
+                                                G_FILE_ATTRIBUTE_ID_STANDARD_SYMLINK_TARGET))
+        g_file_info_set_symlink_target (info, symlink_target);
+    }
+#endif
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_CONTENT_TYPE) ||
+      _g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_ICON) ||
+      _g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_SYMBOLIC_ICON))
+    {
+      char *content_type = get_content_type (basename, path, stat_ok ? &statbuf : NULL, is_symlink, symlink_broken, flags, FALSE);
+
+      if (content_type)
+	{
+	  g_file_info_set_content_type (info, content_type);
+
+	  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+                                                     G_FILE_ATTRIBUTE_ID_STANDARD_ICON)
+               || _g_file_attribute_matcher_matches_id (attribute_matcher,
+                                                        G_FILE_ATTRIBUTE_ID_STANDARD_SYMBOLIC_ICON))
+	    {
+	      GIcon *icon;
+
+              /* non symbolic icon */
+              icon = get_icon (path, content_type, FALSE);
+              if (icon != NULL)
+                {
+                  g_file_info_set_icon (info, icon);
+                  g_object_unref (icon);
+                }
+
+              /* symbolic icon */
+              icon = get_icon (path, content_type, TRUE);
+              if (icon != NULL)
+                {
+                  g_file_info_set_symbolic_icon (info, icon);
+                  g_object_unref (icon);
+                }
+
+	    }
+	  
+	  g_free (content_type);
+	}
+    }
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_STANDARD_FAST_CONTENT_TYPE))
+    {
+      char *content_type = get_content_type (basename, path, stat_ok ? &statbuf : NULL, is_symlink, symlink_broken, flags, TRUE);
+      
+      if (content_type)
+	{
+	  _g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_STANDARD_FAST_CONTENT_TYPE, content_type);
+	  g_free (content_type);
+	}
+    }
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_OWNER_USER))
+    {
+      char *name = NULL;
+      
+#ifdef G_OS_WIN32
+      win32_get_file_user_info (path, NULL, &name, NULL);
+#else
+      if (stat_ok)
+        name = get_username_from_uid (statbuf.st_uid);
+#endif
+      if (name)
+	_g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_OWNER_USER, name);
+      g_free (name);
+    }
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_OWNER_USER_REAL))
+    {
+      char *name = NULL;
+#ifdef G_OS_WIN32
+      win32_get_file_user_info (path, NULL, NULL, &name);
+#else
+      if (stat_ok)
+        name = get_realname_from_uid (statbuf.st_uid);
+#endif
+      if (name)
+	_g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_OWNER_USER_REAL, name);
+      g_free (name);
+    }
+  
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_OWNER_GROUP))
+    {
+      char *name = NULL;
+#ifdef G_OS_WIN32
+      win32_get_file_user_info (path, &name, NULL, NULL);
+#else
+      if (stat_ok)
+        name = get_groupname_from_gid (statbuf.st_gid);
+#endif
+      if (name)
+	_g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_OWNER_GROUP, name);
+      g_free (name);
+    }
+
+  if (stat_ok && parent_info && parent_info->device != 0 &&
+      _g_file_attribute_matcher_matches_id (attribute_matcher, G_FILE_ATTRIBUTE_ID_UNIX_IS_MOUNTPOINT) &&
+      statbuf.st_dev != parent_info->device) 
+    _g_file_info_set_attribute_boolean_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_IS_MOUNTPOINT, TRUE);
+  
+  if (stat_ok)
+    get_access_rights (attribute_matcher, info, path, &statbuf, parent_info);
+  
+#ifdef HAVE_SELINUX
+  get_selinux_context (path, info, attribute_matcher, (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS) == 0);
+#endif
+  get_xattrs (path, TRUE, info, attribute_matcher, (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS) == 0);
+  get_xattrs (path, FALSE, info, attribute_matcher, (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS) == 0);
+
+  if (_g_file_attribute_matcher_matches_id (attribute_matcher,
+					    G_FILE_ATTRIBUTE_ID_THUMBNAIL_PATH))
+    {
+      if (stat_ok)
+          get_thumbnail_attributes (path, info, &statbuf);
+      else
+          get_thumbnail_attributes (path, info, NULL);
+    }
+
+  vfs = g_vfs_get_default ();
+  class = G_VFS_GET_CLASS (vfs);
+  if (class->local_file_add_info)
+    {
+      class->local_file_add_info (vfs,
+                                  path,
+                                  device,
+                                  attribute_matcher,
+                                  info,
+                                  NULL,
+                                  &parent_info->extra_data,
+                                  &parent_info->free_extra_data);
+    }
+
+  g_file_info_unset_attribute_mask (info);
+
+  g_free (symlink_target);
+
+  return info;
+}
+
+GFileInfo *
+_g_local_file_info_get_from_fd (int         fd,
+				const char *attributes,
+				GError    **error)
+{
+  GLocalFileStat stat_buf;
+  GFileAttributeMatcher *matcher;
+  GFileInfo *info;
+  
+#ifdef G_OS_WIN32
+#define FSTAT _fstati64
+#else
+#define FSTAT fstat
+#endif
+
+  if (FSTAT (fd, &stat_buf) == -1)
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error when getting information for file descriptor: %s"),
+		   g_strerror (errsv));
+      return NULL;
+    }
+
+  info = g_file_info_new ();
+
+  matcher = g_file_attribute_matcher_new (attributes);
+
+  /* Make sure we don't set any unwanted attributes */
+  g_file_info_set_attribute_mask (info, matcher);
+  
+  set_info_from_stat (info, &stat_buf, matcher);
+  
+#ifdef HAVE_SELINUX
+  if (_g_file_attribute_matcher_matches_id (matcher, G_FILE_ATTRIBUTE_ID_SELINUX_CONTEXT) &&
+      is_selinux_enabled ())
+    {
+      char *context;
+      if (fgetfilecon_raw (fd, &context) >= 0)
+	{
+	  _g_file_info_set_attribute_string_by_id (info, G_FILE_ATTRIBUTE_ID_SELINUX_CONTEXT, context);
+	  freecon (context);
+	}
+    }
+#endif
+
+  get_xattrs_from_fd (fd, TRUE, info, matcher);
+  get_xattrs_from_fd (fd, FALSE, info, matcher);
+  
+  g_file_attribute_matcher_unref (matcher);
+
+  g_file_info_unset_attribute_mask (info);
+  
+  return info;
+}
+
+static gboolean
+get_uint32 (const GFileAttributeValue  *value,
+	    guint32                    *val_out,
+	    GError                    **error)
+{
+  if (value->type != G_FILE_ATTRIBUTE_TYPE_UINT32)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Invalid attribute type (uint32 expected)"));
+      return FALSE;
+    }
+
+  *val_out = value->u.uint32;
+  
+  return TRUE;
+}
+
+#ifdef HAVE_UTIMES
+static gboolean
+get_uint64 (const GFileAttributeValue  *value,
+	    guint64                    *val_out,
+	    GError                    **error)
+{
+  if (value->type != G_FILE_ATTRIBUTE_TYPE_UINT64)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Invalid attribute type (uint64 expected)"));
+      return FALSE;
+    }
+
+  *val_out = value->u.uint64;
+  
+  return TRUE;
+}
+#endif
+
+#if defined(HAVE_SYMLINK)
+static gboolean
+get_byte_string (const GFileAttributeValue  *value,
+		 const char                **val_out,
+		 GError                    **error)
+{
+  if (value->type != G_FILE_ATTRIBUTE_TYPE_BYTE_STRING)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Invalid attribute type (byte string expected)"));
+      return FALSE;
+    }
+
+  *val_out = value->u.string;
+  
+  return TRUE;
+}
+#endif
+
+#ifdef HAVE_SELINUX
+static gboolean
+get_string (const GFileAttributeValue  *value,
+	    const char                **val_out,
+	    GError                    **error)
+{
+  if (value->type != G_FILE_ATTRIBUTE_TYPE_STRING)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("Invalid attribute type (byte string expected)"));
+      return FALSE;
+    }
+
+  *val_out = value->u.string;
+  
+  return TRUE;
+}
+#endif
+
+static gboolean
+set_unix_mode (char                       *filename,
+               GFileQueryInfoFlags         flags,
+	       const GFileAttributeValue  *value,
+	       GError                    **error)
+{
+  guint32 val = 0;
+  int res = 0;
+  
+  if (!get_uint32 (value, &val, error))
+    return FALSE;
+
+#ifdef HAVE_SYMLINK
+  if (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS) {
+#ifdef HAVE_LCHMOD
+    res = lchmod (filename, val);
+#else
+    struct stat statbuf;
+    /* Calling chmod on a symlink changes permissions on the symlink.
+     * We don't want to do this, so we need to check for a symlink */
+    res = g_lstat (filename, &statbuf);
+    if (res == 0 && S_ISLNK (statbuf.st_mode))
+      {
+        g_set_error_literal (error, G_IO_ERROR,
+                             G_IO_ERROR_NOT_SUPPORTED,
+                             _("Cannot set permissions on symlinks"));
+        return FALSE;
+      }
+    else if (res == 0)
+      res = g_chmod (filename, val);
+#endif
+  } else
+#endif
+    res = g_chmod (filename, val);
+
+  if (res == -1)
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting permissions: %s"),
+		   g_strerror (errsv));
+      return FALSE;
+    }
+  return TRUE;
+}
+
+#ifdef G_OS_UNIX
+static gboolean
+set_unix_uid_gid (char                       *filename,
+		  const GFileAttributeValue  *uid_value,
+		  const GFileAttributeValue  *gid_value,
+		  GFileQueryInfoFlags         flags,
+		  GError                    **error)
+{
+  int res;
+  guint32 val = 0;
+  uid_t uid;
+  gid_t gid;
+  
+  if (uid_value)
+    {
+      if (!get_uint32 (uid_value, &val, error))
+	return FALSE;
+      uid = val;
+    }
+  else
+    uid = -1;
+  
+  if (gid_value)
+    {
+      if (!get_uint32 (gid_value, &val, error))
+	return FALSE;
+      gid = val;
+    }
+  else
+    gid = -1;
+  
+#ifdef HAVE_LCHOWN
+  if (flags & G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS)
+    res = lchown (filename, uid, gid);
+  else
+#endif
+    res = chown (filename, uid, gid);
+  
+  if (res == -1)
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting owner: %s"),
+		   g_strerror (errsv));
+	  return FALSE;
+    }
+  return TRUE;
+}
+#endif
+
+#ifdef HAVE_SYMLINK
+static gboolean
+set_symlink (char                       *filename,
+	     const GFileAttributeValue  *value,
+	     GError                    **error)
+{
+  const char *val;
+  struct stat statbuf;
+  
+  if (!get_byte_string (value, &val, error))
+    return FALSE;
+  
+  if (val == NULL)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                           _("symlink must be non-NULL"));
+      return FALSE;
+    }
+  
+  if (g_lstat (filename, &statbuf))
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting symlink: %s"),
+		   g_strerror (errsv));
+      return FALSE;
+    }
+  
+  if (!S_ISLNK (statbuf.st_mode))
+    {
+      g_set_error_literal (error, G_IO_ERROR,
+                           G_IO_ERROR_NOT_SYMBOLIC_LINK,
+                           _("Error setting symlink: file is not a symlink"));
+      return FALSE;
+    }
+  
+  if (g_unlink (filename))
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting symlink: %s"),
+		   g_strerror (errsv));
+      return FALSE;
+    }
+  
+  if (symlink (filename, val) != 0)
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting symlink: %s"),
+		   g_strerror (errsv));
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+#endif
+
+#ifdef HAVE_UTIMES
+static int
+lazy_stat (char        *filename, 
+           struct stat *statbuf, 
+           gboolean    *called_stat)
+{
+  int res;
+
+  if (*called_stat)
+    return 0;
+  
+  res = g_stat (filename, statbuf);
+  
+  if (res == 0)
+    *called_stat = TRUE;
+  
+  return res;
+}
+
+
+static gboolean
+set_mtime_atime (char                       *filename,
+		 const GFileAttributeValue  *mtime_value,
+		 const GFileAttributeValue  *mtime_usec_value,
+		 const GFileAttributeValue  *atime_value,
+		 const GFileAttributeValue  *atime_usec_value,
+		 GError                    **error)
+{
+  int res;
+  guint64 val = 0;
+  guint32 val_usec = 0;
+  struct stat statbuf;
+  gboolean got_stat = FALSE;
+  struct timeval times[2] = { {0, 0}, {0, 0} };
+
+  /* ATIME */
+  if (atime_value)
+    {
+      if (!get_uint64 (atime_value, &val, error))
+	return FALSE;
+      times[0].tv_sec = val;
+    }
+  else
+    {
+      if (lazy_stat (filename, &statbuf, &got_stat) == 0)
+	{
+	  times[0].tv_sec = statbuf.st_mtime;
+#if defined (HAVE_STRUCT_STAT_ST_ATIMENSEC)
+	  times[0].tv_usec = statbuf.st_atimensec / 1000;
+#elif defined (HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
+	  times[0].tv_usec = statbuf.st_atim.tv_nsec / 1000;
+#endif
+	}
+    }
+  
+  if (atime_usec_value)
+    {
+      if (!get_uint32 (atime_usec_value, &val_usec, error))
+	return FALSE;
+      times[0].tv_usec = val_usec;
+    }
+
+  /* MTIME */
+  if (mtime_value)
+    {
+      if (!get_uint64 (mtime_value, &val, error))
+	return FALSE;
+      times[1].tv_sec = val;
+    }
+  else
+    {
+      if (lazy_stat (filename, &statbuf, &got_stat) == 0)
+	{
+	  times[1].tv_sec = statbuf.st_mtime;
+#if defined (HAVE_STRUCT_STAT_ST_MTIMENSEC)
+	  times[1].tv_usec = statbuf.st_mtimensec / 1000;
+#elif defined (HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
+	  times[1].tv_usec = statbuf.st_mtim.tv_nsec / 1000;
+#endif
+	}
+    }
+  
+  if (mtime_usec_value)
+    {
+      if (!get_uint32 (mtime_usec_value, &val_usec, error))
+	return FALSE;
+      times[1].tv_usec = val_usec;
+    }
+  
+  res = utimes (filename, times);
+  if (res == -1)
+    {
+      int errsv = errno;
+
+      g_set_error (error, G_IO_ERROR,
+		   g_io_error_from_errno (errsv),
+		   _("Error setting modification or access time: %s"),
+		   g_strerror (errsv));
+	  return FALSE;
+    }
+  return TRUE;
+}
+#endif
+
+
+#ifdef HAVE_SELINUX
+static gboolean
+set_selinux_context (char                       *filename,
+		 const GFileAttributeValue  *value,
+		 GError                    **error)
+{
+  const char *val;
+
+  if (!get_string (value, &val, error))
+    return FALSE;
+
+  if (val == NULL)
+  {
+    g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                         _("SELinux context must be non-NULL"));
+    return FALSE;
+  }
+
+  if (is_selinux_enabled ()) {
+	security_context_t val_s;
+	
+	val_s = g_strdup (val);
+	
+	if (setfilecon_raw (filename, val_s) < 0)
+	{
+            int errsv = errno;
+            
+            g_set_error (error, G_IO_ERROR,
+                         g_io_error_from_errno (errsv),
+                	_("Error setting SELinux context: %s"),
+                         g_strerror (errsv));
+            return FALSE;
+        }
+        g_free (val_s);
+  } else {
+    g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                         _("SELinux is not enabled on this system"));
+    return FALSE;
+  }
+                                                     
+  return TRUE;
+}
+#endif 
+
+
+gboolean
+_g_local_file_info_set_attribute (char                 *filename,
+				  const char           *attribute,
+				  GFileAttributeType    type,
+				  gpointer              value_p,
+				  GFileQueryInfoFlags   flags,
+				  GCancellable         *cancellable,
+				  GError              **error)
+{
+  GFileAttributeValue value = { 0 };
+  GVfsClass *class;
+  GVfs *vfs;
+
+  _g_file_attribute_value_set_from_pointer (&value, type, value_p, FALSE);
+  
+  if (strcmp (attribute, G_FILE_ATTRIBUTE_UNIX_MODE) == 0)
+    return set_unix_mode (filename, flags, &value, error);
+  
+#ifdef G_OS_UNIX
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_UNIX_UID) == 0)
+    return set_unix_uid_gid (filename, &value, NULL, flags, error);
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_UNIX_GID) == 0)
+    return set_unix_uid_gid (filename, NULL, &value, flags, error);
+#endif
+  
+#ifdef HAVE_SYMLINK
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET) == 0)
+    return set_symlink (filename, &value, error);
+#endif
+
+#ifdef HAVE_UTIMES
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_TIME_MODIFIED) == 0)
+    return set_mtime_atime (filename, &value, NULL, NULL, NULL, error);
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC) == 0)
+    return set_mtime_atime (filename, NULL, &value, NULL, NULL, error);
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_TIME_ACCESS) == 0)
+    return set_mtime_atime (filename, NULL, NULL, &value, NULL, error);
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_TIME_ACCESS_USEC) == 0)
+    return set_mtime_atime (filename, NULL, NULL, NULL, &value, error);
+#endif
+
+#ifdef HAVE_XATTR
+  else if (g_str_has_prefix (attribute, "xattr::"))
+    return set_xattr (filename, attribute, &value, error);
+  else if (g_str_has_prefix (attribute, "xattr-sys::"))
+    return set_xattr (filename, attribute, &value, error);
+#endif
+
+#ifdef HAVE_SELINUX 
+  else if (strcmp (attribute, G_FILE_ATTRIBUTE_SELINUX_CONTEXT) == 0)
+    return set_selinux_context (filename, &value, error);
+#endif
+
+  vfs = g_vfs_get_default ();
+  class = G_VFS_GET_CLASS (vfs);
+  if (class->local_file_set_attributes)
+    {
+      GFileInfo *info;
+
+      info = g_file_info_new ();
+      g_file_info_set_attribute (info,
+                                 attribute,
+                                 type,
+                                 value_p);
+      if (!class->local_file_set_attributes (vfs, filename,
+                                             info,
+                                             flags, cancellable,
+                                             error))
+        {
+          g_object_unref (info);
+	  return FALSE;
+        }
+
+      if (g_file_info_get_attribute_status (info, attribute) == G_FILE_ATTRIBUTE_STATUS_SET)
+        {
+          g_object_unref (info);
+          return TRUE;
+        }
+
+      g_object_unref (info);
+    }
+
+  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+	       _("Setting attribute %s not supported"), attribute);
+  return FALSE;
+}
+
+gboolean
+_g_local_file_info_set_attributes  (char                 *filename,
+				    GFileInfo            *info,
+				    GFileQueryInfoFlags   flags,
+				    GCancellable         *cancellable,
+				    GError              **error)
+{
+  GFileAttributeValue *value;
+#ifdef G_OS_UNIX
+  GFileAttributeValue *uid, *gid;
+#ifdef HAVE_UTIMES
+  GFileAttributeValue *mtime, *mtime_usec, *atime, *atime_usec;
+#endif
+  GFileAttributeStatus status;
+#endif
+  gboolean res;
+  GVfsClass *class;
+  GVfs *vfs;
+  
+  /* Handles setting multiple specified data in a single set, and takes care
+     of ordering restrictions when setting attributes */
+
+  res = TRUE;
+
+  /* Set symlink first, since this recreates the file */
+#ifdef HAVE_SYMLINK
+  value = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET);
+  if (value)
+    {
+      if (!set_symlink (filename, value, error))
+	{
+	  value->status = G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING;
+	  res = FALSE;
+	  /* Don't set error multiple times */
+	  error = NULL;
+	}
+      else
+	value->status = G_FILE_ATTRIBUTE_STATUS_SET;
+	
+    }
+#endif
+
+#ifdef G_OS_UNIX
+  /* Group uid and gid setting into one call
+   * Change ownership before permissions, since ownership changes can
+     change permissions (e.g. setuid)
+   */
+  uid = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_UNIX_UID);
+  gid = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_UNIX_GID);
+  
+  if (uid || gid)
+    {
+      if (!set_unix_uid_gid (filename, uid, gid, flags, error))
+	{
+	  status = G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING;
+	  res = FALSE;
+	  /* Don't set error multiple times */
+	  error = NULL;
+	}
+      else
+	status = G_FILE_ATTRIBUTE_STATUS_SET;
+      if (uid)
+	uid->status = status;
+      if (gid)
+	gid->status = status;
+    }
+#endif
+  
+  value = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_UNIX_MODE);
+  if (value)
+    {
+      if (!set_unix_mode (filename, flags, value, error))
+	{
+	  value->status = G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING;
+	  res = FALSE;
+	  /* Don't set error multiple times */
+	  error = NULL;
+	}
+      else
+	value->status = G_FILE_ATTRIBUTE_STATUS_SET;
+	
+    }
+
+#ifdef HAVE_UTIMES
+  /* Group all time settings into one call
+   * Change times as the last thing to avoid it changing due to metadata changes
+   */
+  
+  mtime = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_TIME_MODIFIED);
+  mtime_usec = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC);
+  atime = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_TIME_ACCESS);
+  atime_usec = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_TIME_ACCESS_USEC);
+
+  if (mtime || mtime_usec || atime || atime_usec)
+    {
+      if (!set_mtime_atime (filename, mtime, mtime_usec, atime, atime_usec, error))
+	{
+	  status = G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING;
+	  res = FALSE;
+	  /* Don't set error multiple times */
+	  error = NULL;
+	}
+      else
+	status = G_FILE_ATTRIBUTE_STATUS_SET;
+      
+      if (mtime)
+	mtime->status = status;
+      if (mtime_usec)
+	mtime_usec->status = status;
+      if (atime)
+	atime->status = status;
+      if (atime_usec)
+	atime_usec->status = status;
+    }
+#endif
+
+  /* xattrs are handled by default callback */
+
+
+  /*  SELinux context */
+#ifdef HAVE_SELINUX 
+  if (is_selinux_enabled ()) {
+    value = _g_file_info_get_attribute_value (info, G_FILE_ATTRIBUTE_SELINUX_CONTEXT);
+    if (value)
+    {
+      if (!set_selinux_context (filename, value, error))
+        {
+          value->status = G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING;
+          res = FALSE;
+          /* Don't set error multiple times */
+          error = NULL;
+        }
+      else
+        value->status = G_FILE_ATTRIBUTE_STATUS_SET;
+    }
+  }
+#endif
+
+  vfs = g_vfs_get_default ();
+  class = G_VFS_GET_CLASS (vfs);
+  if (class->local_file_set_attributes)
+    {
+      if (!class->local_file_set_attributes (vfs, filename,
+                                             info,
+                                             flags, cancellable,
+                                             error))
+        {
+	  res = FALSE;
+	  /* Don't set error multiple times */
+	  error = NULL;
+        }
+    }
+
+  return res;
+}
diff -urN glib-2.51.0.org/gio/gsocket.c glib-2.51.0/gio/gsocket.c
--- glib-2.51.0.org/gio/gsocket.c	2016-10-22 07:17:33.000000000 +0200
+++ glib-2.51.0/gio/gsocket.c	2016-10-28 22:58:56.889556591 +0200
@@ -2139,7 +2139,7 @@
 
 #if !defined(HAVE_IF_NAMETOINDEX) && defined(G_OS_WIN32)
 static guint
-if_nametoindex (const gchar *iface)
+w32_if_nametoindex (const gchar *iface)
 {
   PIP_ADAPTER_ADDRESSES addresses = NULL, p;
   gulong addresses_len = 0;
@@ -2192,6 +2192,7 @@
 }
 
 #define HAVE_IF_NAMETOINDEX 1
+#define if_nametoindex w32_if_nametoindex
 #endif
 
 static gboolean
diff -urN glib-2.51.0.org/gio/gsocket.c.orig glib-2.51.0/gio/gsocket.c.orig
--- glib-2.51.0.org/gio/gsocket.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ glib-2.51.0/gio/gsocket.c.orig	2016-10-22 07:17:33.000000000 +0200
@@ -0,0 +1,5556 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2008 Christian Kellner, Samuel Cormier-Iijima
+ * Copyright  2009 Codethink Limited
+ * Copyright  2009 Red Hat, Inc
+ * Copyright  2015 Collabora, Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authors: Christian Kellner <gicmo@gnome.org>
+ *          Samuel Cormier-Iijima <sciyoshi@gmail.com>
+ *          Ryan Lortie <desrt@desrt.ca>
+ *          Alexander Larsson <alexl@redhat.com>
+ *          Philip Withnall <philip.withnall@collabora.co.uk>
+ */
+
+#include "config.h"
+
+#include "gsocket.h"
+
+#ifdef G_OS_UNIX
+#include "glib-unix.h"
+#endif
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+#include <stdlib.h>
+
+#ifndef G_OS_WIN32
+# include <fcntl.h>
+# include <unistd.h>
+# include <sys/ioctl.h>
+#endif
+
+#ifdef HAVE_SYS_FILIO_H
+# include <sys/filio.h>
+#endif
+
+#ifdef G_OS_UNIX
+#include <sys/uio.h>
+#endif
+
+#include "gcancellable.h"
+#include "gdatagrambased.h"
+#include "gioenumtypes.h"
+#include "ginetaddress.h"
+#include "ginitable.h"
+#include "gioerror.h"
+#include "gioenums.h"
+#include "gioerror.h"
+#include "gnetworkingprivate.h"
+#include "gsocketaddress.h"
+#include "gsocketcontrolmessage.h"
+#include "gcredentials.h"
+#include "gcredentialsprivate.h"
+#include "glibintl.h"
+
+#ifdef G_OS_WIN32
+/* For Windows XP runtime compatibility, but use the system's if_nametoindex() if available */
+#include "gwin32networking.h"
+#endif
+
+/**
+ * SECTION:gsocket
+ * @short_description: Low-level socket object
+ * @include: gio/gio.h
+ * @see_also: #GInitable, [<gnetworking.h>][gio-gnetworking.h]
+ *
+ * A #GSocket is a low-level networking primitive. It is a more or less
+ * direct mapping of the BSD socket API in a portable GObject based API.
+ * It supports both the UNIX socket implementations and winsock2 on Windows.
+ *
+ * #GSocket is the platform independent base upon which the higher level
+ * network primitives are based. Applications are not typically meant to
+ * use it directly, but rather through classes like #GSocketClient,
+ * #GSocketService and #GSocketConnection. However there may be cases where
+ * direct use of #GSocket is useful.
+ *
+ * #GSocket implements the #GInitable interface, so if it is manually constructed
+ * by e.g. g_object_new() you must call g_initable_init() and check the
+ * results before using the object. This is done automatically in
+ * g_socket_new() and g_socket_new_from_fd(), so these functions can return
+ * %NULL.
+ *
+ * Sockets operate in two general modes, blocking or non-blocking. When
+ * in blocking mode all operations (which dont take an explicit blocking
+ * parameter) block until the requested operation
+ * is finished or there is an error. In non-blocking mode all calls that
+ * would block return immediately with a %G_IO_ERROR_WOULD_BLOCK error.
+ * To know when a call would successfully run you can call g_socket_condition_check(),
+ * or g_socket_condition_wait(). You can also use g_socket_create_source() and
+ * attach it to a #GMainContext to get callbacks when I/O is possible.
+ * Note that all sockets are always set to non blocking mode in the system, and
+ * blocking mode is emulated in GSocket.
+ *
+ * When working in non-blocking mode applications should always be able to
+ * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other
+ * function said that I/O was possible. This can easily happen in case
+ * of a race condition in the application, but it can also happen for other
+ * reasons. For instance, on Windows a socket is always seen as writable
+ * until a write returns %G_IO_ERROR_WOULD_BLOCK.
+ *
+ * #GSockets can be either connection oriented or datagram based.
+ * For connection oriented types you must first establish a connection by
+ * either connecting to an address or accepting a connection from another
+ * address. For connectionless socket types the target/source address is
+ * specified or received in each I/O operation.
+ *
+ * All socket file descriptors are set to be close-on-exec.
+ *
+ * Note that creating a #GSocket causes the signal %SIGPIPE to be
+ * ignored for the remainder of the program. If you are writing a
+ * command-line utility that uses #GSocket, you may need to take into
+ * account the fact that your program will not automatically be killed
+ * if it tries to write to %stdout after it has been closed.
+ *
+ * Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
+ * a #GSocket concurrently from multiple threads, you must implement your own
+ * locking.
+ *
+ * Since: 2.22
+ */
+
+static void     g_socket_initable_iface_init (GInitableIface  *iface);
+static gboolean g_socket_initable_init       (GInitable       *initable,
+					      GCancellable    *cancellable,
+					      GError         **error);
+
+static void     g_socket_datagram_based_iface_init       (GDatagramBasedInterface *iface);
+static gint     g_socket_datagram_based_receive_messages (GDatagramBased  *self,
+                                                          GInputMessage   *messages,
+                                                          guint            num_messages,
+                                                          gint             flags,
+                                                          gint64           timeout,
+                                                          GCancellable    *cancellable,
+                                                          GError         **error);
+static gint     g_socket_datagram_based_send_messages    (GDatagramBased  *self,
+                                                          GOutputMessage  *messages,
+                                                          guint            num_messages,
+                                                          gint             flags,
+                                                          gint64           timeout,
+                                                          GCancellable    *cancellable,
+                                                          GError         **error);
+static GSource *g_socket_datagram_based_create_source    (GDatagramBased           *self,
+                                                          GIOCondition              condition,
+                                                          GCancellable             *cancellable);
+static GIOCondition g_socket_datagram_based_condition_check      (GDatagramBased   *datagram_based,
+                                                                  GIOCondition      condition);
+static gboolean     g_socket_datagram_based_condition_wait       (GDatagramBased   *datagram_based,
+                                                                  GIOCondition      condition,
+                                                                  gint64            timeout,
+                                                                  GCancellable     *cancellable,
+                                                                  GError          **error);
+
+static GSocketAddress *
+cache_recv_address (GSocket *socket, struct sockaddr *native, int native_len);
+
+static gssize
+g_socket_receive_message_with_timeout  (GSocket                 *socket,
+                                        GSocketAddress         **address,
+                                        GInputVector            *vectors,
+                                        gint                     num_vectors,
+                                        GSocketControlMessage ***messages,
+                                        gint                    *num_messages,
+                                        gint                    *flags,
+                                        gint64                   timeout,
+                                        GCancellable            *cancellable,
+                                        GError                 **error);
+static gint
+g_socket_receive_messages_with_timeout (GSocket        *socket,
+                                        GInputMessage  *messages,
+                                        guint           num_messages,
+                                        gint            flags,
+                                        gint64          timeout,
+                                        GCancellable   *cancellable,
+                                        GError        **error);
+static gssize
+g_socket_send_message_with_timeout     (GSocket                 *socket,
+                                        GSocketAddress          *address,
+                                        GOutputVector           *vectors,
+                                        gint                     num_vectors,
+                                        GSocketControlMessage  **messages,
+                                        gint                     num_messages,
+                                        gint                     flags,
+                                        gint64                   timeout,
+                                        GCancellable            *cancellable,
+                                        GError                 **error);
+static gint
+g_socket_send_messages_with_timeout    (GSocket        *socket,
+                                        GOutputMessage *messages,
+                                        guint           num_messages,
+                                        gint            flags,
+                                        gint64          timeout,
+                                        GCancellable   *cancellable,
+                                        GError        **error);
+
+enum
+{
+  PROP_0,
+  PROP_FAMILY,
+  PROP_TYPE,
+  PROP_PROTOCOL,
+  PROP_FD,
+  PROP_BLOCKING,
+  PROP_LISTEN_BACKLOG,
+  PROP_KEEPALIVE,
+  PROP_LOCAL_ADDRESS,
+  PROP_REMOTE_ADDRESS,
+  PROP_TIMEOUT,
+  PROP_TTL,
+  PROP_BROADCAST,
+  PROP_MULTICAST_LOOPBACK,
+  PROP_MULTICAST_TTL
+};
+
+/* Size of the receiver cache for g_socket_receive_from() */
+#define RECV_ADDR_CACHE_SIZE 8
+
+struct _GSocketPrivate
+{
+  GSocketFamily   family;
+  GSocketType     type;
+  GSocketProtocol protocol;
+  gint            fd;
+  gint            listen_backlog;
+  guint           timeout;
+  GError         *construct_error;
+  GSocketAddress *remote_address;
+  guint           inited : 1;
+  guint           blocking : 1;
+  guint           keepalive : 1;
+  guint           closed : 1;
+  guint           connected_read : 1;
+  guint           connected_write : 1;
+  guint           listening : 1;
+  guint           timed_out : 1;
+  guint           connect_pending : 1;
+#ifdef G_OS_WIN32
+  WSAEVENT        event;
+  int             current_events;
+  int             current_errors;
+  int             selected_events;
+  GList          *requested_conditions; /* list of requested GIOCondition * */
+  GMutex          win32_source_lock;
+#endif
+
+  struct {
+    GSocketAddress *addr;
+    struct sockaddr *native;
+    gint native_len;
+    guint64 last_used;
+  } recv_addr_cache[RECV_ADDR_CACHE_SIZE];
+};
+
+G_DEFINE_TYPE_WITH_CODE (GSocket, g_socket, G_TYPE_OBJECT,
+                         G_ADD_PRIVATE (GSocket)
+			 g_networking_init ();
+			 G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+						g_socket_initable_iface_init);
+                         G_IMPLEMENT_INTERFACE (G_TYPE_DATAGRAM_BASED,
+                                                g_socket_datagram_based_iface_init));
+
+static int
+get_socket_errno (void)
+{
+#ifndef G_OS_WIN32
+  return errno;
+#else
+  return WSAGetLastError ();
+#endif
+}
+
+static GIOErrorEnum
+socket_io_error_from_errno (int err)
+{
+#ifdef G_OS_WIN32
+  return g_io_error_from_win32_error (err);
+#else
+  return g_io_error_from_errno (err);
+#endif
+}
+
+static const char *
+socket_strerror (int err)
+{
+#ifndef G_OS_WIN32
+  return g_strerror (err);
+#else
+  const char *msg_ret;
+  char *msg;
+
+  msg = g_win32_error_message (err);
+
+  msg_ret = g_intern_string (msg);
+  g_free (msg);
+
+  return msg_ret;
+#endif
+}
+
+/* Wrapper around g_set_error() to avoid doing excess work */
+#define socket_set_error_lazy(err, errsv, fmt)                          \
+  G_STMT_START {                                                        \
+    GError **__err = (err);                                             \
+    int __errsv = (errsv);                                              \
+                                                                        \
+    if (__err)                                                          \
+      {                                                                 \
+        int __code = socket_io_error_from_errno (__errsv);              \
+        const char *__strerr = socket_strerror (__errsv);               \
+                                                                        \
+        if (__code == G_IO_ERROR_WOULD_BLOCK)                           \
+          g_set_error_literal (__err, G_IO_ERROR, __code, __strerr);    \
+        else                                                            \
+          g_set_error (__err, G_IO_ERROR, __code, fmt, __strerr);       \
+      }                                                                 \
+  } G_STMT_END
+
+#ifdef G_OS_WIN32
+#define win32_unset_event_mask(_socket, _mask) _win32_unset_event_mask (_socket, _mask)
+static void
+_win32_unset_event_mask (GSocket *socket, int mask)
+{
+  socket->priv->current_events &= ~mask;
+  socket->priv->current_errors &= ~mask;
+}
+#else
+#define win32_unset_event_mask(_socket, _mask)
+#endif
+
+/* Windows has broken prototypes... */
+#ifdef G_OS_WIN32
+#define getsockopt(sockfd, level, optname, optval, optlen) \
+  getsockopt (sockfd, level, optname, (gpointer) optval, (int*) optlen)
+#define setsockopt(sockfd, level, optname, optval, optlen) \
+  setsockopt (sockfd, level, optname, (gpointer) optval, optlen)
+#define getsockname(sockfd, addr, addrlen) \
+  getsockname (sockfd, addr, (int *)addrlen)
+#define getpeername(sockfd, addr, addrlen) \
+  getpeername (sockfd, addr, (int *)addrlen)
+#define recv(sockfd, buf, len, flags) \
+  recv (sockfd, (gpointer)buf, len, flags)
+#endif
+
+static gboolean
+check_socket (GSocket *socket,
+	      GError **error)
+{
+  if (!socket->priv->inited)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_INITIALIZED,
+                           _("Invalid socket, not initialized"));
+      return FALSE;
+    }
+
+  if (socket->priv->construct_error)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_INITIALIZED,
+		   _("Invalid socket, initialization failed due to: %s"),
+		   socket->priv->construct_error->message);
+      return FALSE;
+    }
+
+  if (socket->priv->closed)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_CLOSED,
+			   _("Socket is already closed"));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gboolean
+check_timeout (GSocket *socket,
+	       GError **error)
+{
+  if (socket->priv->timed_out)
+    {
+      socket->priv->timed_out = FALSE;
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_TIMED_OUT,
+			   _("Socket I/O timed out"));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+g_socket_details_from_fd (GSocket *socket)
+{
+  struct sockaddr_storage address;
+  gint fd;
+  guint addrlen;
+  int value, family;
+  int errsv;
+
+  fd = socket->priv->fd;
+  if (!g_socket_get_option (socket, SOL_SOCKET, SO_TYPE, &value, NULL))
+    {
+      errsv = get_socket_errno ();
+      goto err;
+    }
+
+  switch (value)
+    {
+     case SOCK_STREAM:
+      socket->priv->type = G_SOCKET_TYPE_STREAM;
+      break;
+
+     case SOCK_DGRAM:
+      socket->priv->type = G_SOCKET_TYPE_DATAGRAM;
+      break;
+
+     case SOCK_SEQPACKET:
+      socket->priv->type = G_SOCKET_TYPE_SEQPACKET;
+      break;
+
+     default:
+      socket->priv->type = G_SOCKET_TYPE_INVALID;
+      break;
+    }
+
+  addrlen = sizeof address;
+  if (getsockname (fd, (struct sockaddr *) &address, &addrlen) != 0)
+    {
+      errsv = get_socket_errno ();
+      goto err;
+    }
+
+  if (addrlen > 0)
+    {
+      g_assert (G_STRUCT_OFFSET (struct sockaddr, sa_family) +
+		sizeof address.ss_family <= addrlen);
+      family = address.ss_family;
+    }
+  else
+    {
+      /* On Solaris, this happens if the socket is not yet connected.
+       * But we can use SO_DOMAIN as a workaround there.
+       */
+#ifdef SO_DOMAIN
+      if (!g_socket_get_option (socket, SOL_SOCKET, SO_DOMAIN, &family, NULL))
+	{
+	  errsv = get_socket_errno ();
+	  goto err;
+	}
+#else
+      /* This will translate to G_IO_ERROR_FAILED on either unix or windows */
+      errsv = -1;
+      goto err;
+#endif
+    }
+
+  switch (family)
+    {
+     case G_SOCKET_FAMILY_IPV4:
+     case G_SOCKET_FAMILY_IPV6:
+       socket->priv->family = address.ss_family;
+       switch (socket->priv->type)
+	 {
+	 case G_SOCKET_TYPE_STREAM:
+	   socket->priv->protocol = G_SOCKET_PROTOCOL_TCP;
+	   break;
+
+	 case G_SOCKET_TYPE_DATAGRAM:
+	   socket->priv->protocol = G_SOCKET_PROTOCOL_UDP;
+	   break;
+
+	 case G_SOCKET_TYPE_SEQPACKET:
+	   socket->priv->protocol = G_SOCKET_PROTOCOL_SCTP;
+	   break;
+
+	 default:
+	   break;
+	 }
+       break;
+
+     case G_SOCKET_FAMILY_UNIX:
+       socket->priv->family = G_SOCKET_FAMILY_UNIX;
+       socket->priv->protocol = G_SOCKET_PROTOCOL_DEFAULT;
+       break;
+
+     default:
+       socket->priv->family = G_SOCKET_FAMILY_INVALID;
+       break;
+    }
+
+  if (socket->priv->family != G_SOCKET_FAMILY_INVALID)
+    {
+      addrlen = sizeof address;
+      if (getpeername (fd, (struct sockaddr *) &address, &addrlen) >= 0)
+        {
+          socket->priv->connected_read = TRUE;
+          socket->priv->connected_write = TRUE;
+        }
+    }
+
+  if (g_socket_get_option (socket, SOL_SOCKET, SO_KEEPALIVE, &value, NULL))
+    {
+      socket->priv->keepalive = !!value;
+    }
+  else
+    {
+      /* Can't read, maybe not supported, assume FALSE */
+      socket->priv->keepalive = FALSE;
+    }
+
+  return;
+
+ err:
+  g_set_error (&socket->priv->construct_error, G_IO_ERROR,
+	       socket_io_error_from_errno (errsv),
+	       _("creating GSocket from fd: %s"),
+	       socket_strerror (errsv));
+}
+
+/* Wrapper around socket() that is shared with gnetworkmonitornetlink.c */
+gint
+g_socket (gint     domain,
+          gint     type,
+          gint     protocol,
+          GError **error)
+{
+  int fd;
+
+#ifdef SOCK_CLOEXEC
+  fd = socket (domain, type | SOCK_CLOEXEC, protocol);
+  if (fd != -1)
+    return fd;
+
+  /* It's possible that libc has SOCK_CLOEXEC but the kernel does not */
+  if (fd < 0 && (errno == EINVAL || errno == EPROTOTYPE))
+#endif
+    fd = socket (domain, type, protocol);
+
+  if (fd < 0)
+    {
+      int errsv = get_socket_errno ();
+
+      g_set_error (error, G_IO_ERROR, socket_io_error_from_errno (errsv),
+		   _("Unable to create socket: %s"), socket_strerror (errsv));
+      errno = errsv;
+      return -1;
+    }
+
+#ifndef G_OS_WIN32
+  {
+    int flags;
+
+    /* We always want to set close-on-exec to protect users. If you
+       need to so some weird inheritance to exec you can re-enable this
+       using lower level hacks with g_socket_get_fd(). */
+    flags = fcntl (fd, F_GETFD, 0);
+    if (flags != -1 &&
+	(flags & FD_CLOEXEC) == 0)
+      {
+	flags |= FD_CLOEXEC;
+	fcntl (fd, F_SETFD, flags);
+      }
+  }
+#endif
+
+  return fd;
+}
+
+static gint
+g_socket_create_socket (GSocketFamily   family,
+			GSocketType     type,
+			int             protocol,
+			GError        **error)
+{
+  gint native_type;
+
+  switch (type)
+    {
+     case G_SOCKET_TYPE_STREAM:
+      native_type = SOCK_STREAM;
+      break;
+
+     case G_SOCKET_TYPE_DATAGRAM:
+      native_type = SOCK_DGRAM;
+      break;
+
+     case G_SOCKET_TYPE_SEQPACKET:
+      native_type = SOCK_SEQPACKET;
+      break;
+
+     default:
+      g_assert_not_reached ();
+    }
+
+  if (family <= 0)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+                   _("Unable to create socket: %s"), _("Unknown family was specified"));
+      return -1;
+    }
+
+  if (protocol == -1)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,
+		   _("Unable to create socket: %s"), _("Unknown protocol was specified"));
+      return -1;
+    }
+
+  return g_socket (family, native_type, protocol, error);
+}
+
+static void
+g_socket_constructed (GObject *object)
+{
+  GSocket *socket = G_SOCKET (object);
+
+  if (socket->priv->fd >= 0)
+    /* create socket->priv info from the fd */
+    g_socket_details_from_fd (socket);
+
+  else
+    /* create the fd from socket->priv info */
+    socket->priv->fd = g_socket_create_socket (socket->priv->family,
+					       socket->priv->type,
+					       socket->priv->protocol,
+					       &socket->priv->construct_error);
+
+  if (socket->priv->fd != -1)
+    {
+#ifndef G_OS_WIN32
+      GError *error = NULL;
+#else
+      gulong arg;
+#endif
+
+      /* Always use native nonblocking sockets, as Windows sets sockets to
+       * nonblocking automatically in certain operations. This way we make
+       * things work the same on all platforms.
+       */
+#ifndef G_OS_WIN32
+      if (!g_unix_set_fd_nonblocking (socket->priv->fd, TRUE, &error))
+        {
+          g_warning ("Error setting socket nonblocking: %s", error->message);
+          g_clear_error (&error);
+        }
+#else
+      arg = TRUE;
+
+      if (ioctlsocket (socket->priv->fd, FIONBIO, &arg) == SOCKET_ERROR)
+        {
+          int errsv = get_socket_errno ();
+          g_warning ("Error setting socket status flags: %s", socket_strerror (errsv));
+        }
+#endif
+
+#ifdef SO_NOSIGPIPE
+      /* See note about SIGPIPE below. */
+      g_socket_set_option (socket, SOL_SOCKET, SO_NOSIGPIPE, TRUE, NULL);
+#endif
+    }
+}
+
+static void
+g_socket_get_property (GObject    *object,
+		       guint       prop_id,
+		       GValue     *value,
+		       GParamSpec *pspec)
+{
+  GSocket *socket = G_SOCKET (object);
+  GSocketAddress *address;
+
+  switch (prop_id)
+    {
+      case PROP_FAMILY:
+	g_value_set_enum (value, socket->priv->family);
+	break;
+
+      case PROP_TYPE:
+	g_value_set_enum (value, socket->priv->type);
+	break;
+
+      case PROP_PROTOCOL:
+	g_value_set_enum (value, socket->priv->protocol);
+	break;
+
+      case PROP_FD:
+	g_value_set_int (value, socket->priv->fd);
+	break;
+
+      case PROP_BLOCKING:
+	g_value_set_boolean (value, socket->priv->blocking);
+	break;
+
+      case PROP_LISTEN_BACKLOG:
+	g_value_set_int (value, socket->priv->listen_backlog);
+	break;
+
+      case PROP_KEEPALIVE:
+	g_value_set_boolean (value, socket->priv->keepalive);
+	break;
+
+      case PROP_LOCAL_ADDRESS:
+	address = g_socket_get_local_address (socket, NULL);
+	g_value_take_object (value, address);
+	break;
+
+      case PROP_REMOTE_ADDRESS:
+	address = g_socket_get_remote_address (socket, NULL);
+	g_value_take_object (value, address);
+	break;
+
+      case PROP_TIMEOUT:
+	g_value_set_uint (value, socket->priv->timeout);
+	break;
+
+      case PROP_TTL:
+	g_value_set_uint (value, g_socket_get_ttl (socket));
+	break;
+
+      case PROP_BROADCAST:
+	g_value_set_boolean (value, g_socket_get_broadcast (socket));
+	break;
+
+      case PROP_MULTICAST_LOOPBACK:
+	g_value_set_boolean (value, g_socket_get_multicast_loopback (socket));
+	break;
+
+      case PROP_MULTICAST_TTL:
+	g_value_set_uint (value, g_socket_get_multicast_ttl (socket));
+	break;
+
+      default:
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_socket_set_property (GObject      *object,
+		       guint         prop_id,
+		       const GValue *value,
+		       GParamSpec   *pspec)
+{
+  GSocket *socket = G_SOCKET (object);
+
+  switch (prop_id)
+    {
+      case PROP_FAMILY:
+	socket->priv->family = g_value_get_enum (value);
+	break;
+
+      case PROP_TYPE:
+	socket->priv->type = g_value_get_enum (value);
+	break;
+
+      case PROP_PROTOCOL:
+	socket->priv->protocol = g_value_get_enum (value);
+	break;
+
+      case PROP_FD:
+	socket->priv->fd = g_value_get_int (value);
+	break;
+
+      case PROP_BLOCKING:
+	g_socket_set_blocking (socket, g_value_get_boolean (value));
+	break;
+
+      case PROP_LISTEN_BACKLOG:
+	g_socket_set_listen_backlog (socket, g_value_get_int (value));
+	break;
+
+      case PROP_KEEPALIVE:
+	g_socket_set_keepalive (socket, g_value_get_boolean (value));
+	break;
+
+      case PROP_TIMEOUT:
+	g_socket_set_timeout (socket, g_value_get_uint (value));
+	break;
+
+      case PROP_TTL:
+	g_socket_set_ttl (socket, g_value_get_uint (value));
+	break;
+
+      case PROP_BROADCAST:
+	g_socket_set_broadcast (socket, g_value_get_boolean (value));
+	break;
+
+      case PROP_MULTICAST_LOOPBACK:
+	g_socket_set_multicast_loopback (socket, g_value_get_boolean (value));
+	break;
+
+      case PROP_MULTICAST_TTL:
+	g_socket_set_multicast_ttl (socket, g_value_get_uint (value));
+	break;
+
+      default:
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+g_socket_finalize (GObject *object)
+{
+  GSocket *socket = G_SOCKET (object);
+  gint i;
+
+  g_clear_error (&socket->priv->construct_error);
+
+  if (socket->priv->fd != -1 &&
+      !socket->priv->closed)
+    g_socket_close (socket, NULL);
+
+  if (socket->priv->remote_address)
+    g_object_unref (socket->priv->remote_address);
+
+#ifdef G_OS_WIN32
+  if (socket->priv->event != WSA_INVALID_EVENT)
+    {
+      WSACloseEvent (socket->priv->event);
+      socket->priv->event = WSA_INVALID_EVENT;
+    }
+
+  g_assert (socket->priv->requested_conditions == NULL);
+  g_mutex_clear (&socket->priv->win32_source_lock);
+#endif
+
+  for (i = 0; i < RECV_ADDR_CACHE_SIZE; i++)
+    {
+      if (socket->priv->recv_addr_cache[i].addr)
+        {
+          g_object_unref (socket->priv->recv_addr_cache[i].addr);
+          g_free (socket->priv->recv_addr_cache[i].native);
+        }
+    }
+
+  if (G_OBJECT_CLASS (g_socket_parent_class)->finalize)
+    (*G_OBJECT_CLASS (g_socket_parent_class)->finalize) (object);
+}
+
+static void
+g_socket_class_init (GSocketClass *klass)
+{
+  GObjectClass *gobject_class G_GNUC_UNUSED = G_OBJECT_CLASS (klass);
+
+#ifdef SIGPIPE
+  /* There is no portable, thread-safe way to avoid having the process
+   * be killed by SIGPIPE when calling send() or sendmsg(), so we are
+   * forced to simply ignore the signal process-wide.
+   *
+   * Even if we ignore it though, gdb will still stop if the app
+   * receives a SIGPIPE, which can be confusing and annoying. So when
+   * possible, we also use MSG_NOSIGNAL / SO_NOSIGPIPE elsewhere to
+   * prevent the signal from occurring at all.
+   */
+  signal (SIGPIPE, SIG_IGN);
+#endif
+
+  gobject_class->finalize = g_socket_finalize;
+  gobject_class->constructed = g_socket_constructed;
+  gobject_class->set_property = g_socket_set_property;
+  gobject_class->get_property = g_socket_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_FAMILY,
+				   g_param_spec_enum ("family",
+						      P_("Socket family"),
+						      P_("The sockets address family"),
+						      G_TYPE_SOCKET_FAMILY,
+						      G_SOCKET_FAMILY_INVALID,
+						      G_PARAM_CONSTRUCT_ONLY |
+                                                      G_PARAM_READWRITE |
+                                                      G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_TYPE,
+				   g_param_spec_enum ("type",
+						      P_("Socket type"),
+						      P_("The sockets type"),
+						      G_TYPE_SOCKET_TYPE,
+						      G_SOCKET_TYPE_STREAM,
+						      G_PARAM_CONSTRUCT_ONLY |
+                                                      G_PARAM_READWRITE |
+                                                      G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_PROTOCOL,
+				   g_param_spec_enum ("protocol",
+						      P_("Socket protocol"),
+						      P_("The id of the protocol to use, or -1 for unknown"),
+						      G_TYPE_SOCKET_PROTOCOL,
+						      G_SOCKET_PROTOCOL_UNKNOWN,
+						      G_PARAM_CONSTRUCT_ONLY |
+                                                      G_PARAM_READWRITE |
+                                                      G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_FD,
+				   g_param_spec_int ("fd",
+						     P_("File descriptor"),
+						     P_("The sockets file descriptor"),
+						     G_MININT,
+						     G_MAXINT,
+						     -1,
+						     G_PARAM_CONSTRUCT_ONLY |
+                                                     G_PARAM_READWRITE |
+                                                     G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_BLOCKING,
+				   g_param_spec_boolean ("blocking",
+							 P_("blocking"),
+							 P_("Whether or not I/O on this socket is blocking"),
+							 TRUE,
+							 G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_LISTEN_BACKLOG,
+				   g_param_spec_int ("listen-backlog",
+						     P_("Listen backlog"),
+						     P_("Outstanding connections in the listen queue"),
+						     0,
+						     SOMAXCONN,
+						     10,
+						     G_PARAM_READWRITE |
+                                                     G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_KEEPALIVE,
+				   g_param_spec_boolean ("keepalive",
+							 P_("Keep connection alive"),
+							 P_("Keep connection alive by sending periodic pings"),
+							 FALSE,
+							 G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_LOCAL_ADDRESS,
+				   g_param_spec_object ("local-address",
+							P_("Local address"),
+							P_("The local address the socket is bound to"),
+							G_TYPE_SOCKET_ADDRESS,
+							G_PARAM_READABLE |
+                                                        G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_REMOTE_ADDRESS,
+				   g_param_spec_object ("remote-address",
+							P_("Remote address"),
+							P_("The remote address the socket is connected to"),
+							G_TYPE_SOCKET_ADDRESS,
+							G_PARAM_READABLE |
+                                                        G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GSocket:timeout:
+   *
+   * The timeout in seconds on socket I/O
+   *
+   * Since: 2.26
+   */
+  g_object_class_install_property (gobject_class, PROP_TIMEOUT,
+				   g_param_spec_uint ("timeout",
+						      P_("Timeout"),
+						      P_("The timeout in seconds on socket I/O"),
+						      0,
+						      G_MAXUINT,
+						      0,
+						      G_PARAM_READWRITE |
+						      G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GSocket:broadcast:
+   *
+   * Whether the socket should allow sending to broadcast addresses.
+   *
+   * Since: 2.32
+   */
+  g_object_class_install_property (gobject_class, PROP_BROADCAST,
+				   g_param_spec_boolean ("broadcast",
+							 P_("Broadcast"),
+							 P_("Whether to allow sending to broadcast addresses"),
+							 FALSE,
+							 G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GSocket:ttl:
+   *
+   * Time-to-live for outgoing unicast packets
+   *
+   * Since: 2.32
+   */
+  g_object_class_install_property (gobject_class, PROP_TTL,
+				   g_param_spec_uint ("ttl",
+						      P_("TTL"),
+						      P_("Time-to-live of outgoing unicast packets"),
+						      0, G_MAXUINT, 0,
+						      G_PARAM_READWRITE |
+						      G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GSocket:multicast-loopback:
+   *
+   * Whether outgoing multicast packets loop back to the local host.
+   *
+   * Since: 2.32
+   */
+  g_object_class_install_property (gobject_class, PROP_MULTICAST_LOOPBACK,
+				   g_param_spec_boolean ("multicast-loopback",
+							 P_("Multicast loopback"),
+							 P_("Whether outgoing multicast packets loop back to the local host"),
+							 TRUE,
+							 G_PARAM_READWRITE |
+                                                         G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GSocket:multicast-ttl:
+   *
+   * Time-to-live out outgoing multicast packets
+   *
+   * Since: 2.32
+   */
+  g_object_class_install_property (gobject_class, PROP_MULTICAST_TTL,
+				   g_param_spec_uint ("multicast-ttl",
+						      P_("Multicast TTL"),
+						      P_("Time-to-live of outgoing multicast packets"),
+						      0, G_MAXUINT, 1,
+						      G_PARAM_READWRITE |
+						      G_PARAM_STATIC_STRINGS));
+}
+
+static void
+g_socket_initable_iface_init (GInitableIface *iface)
+{
+  iface->init = g_socket_initable_init;
+}
+
+static void
+g_socket_datagram_based_iface_init (GDatagramBasedInterface *iface)
+{
+  iface->receive_messages = g_socket_datagram_based_receive_messages;
+  iface->send_messages = g_socket_datagram_based_send_messages;
+  iface->create_source = g_socket_datagram_based_create_source;
+  iface->condition_check = g_socket_datagram_based_condition_check;
+  iface->condition_wait = g_socket_datagram_based_condition_wait;
+}
+
+static void
+g_socket_init (GSocket *socket)
+{
+  socket->priv = g_socket_get_instance_private (socket);
+
+  socket->priv->fd = -1;
+  socket->priv->blocking = TRUE;
+  socket->priv->listen_backlog = 10;
+  socket->priv->construct_error = NULL;
+#ifdef G_OS_WIN32
+  socket->priv->event = WSA_INVALID_EVENT;
+  g_mutex_init (&socket->priv->win32_source_lock);
+#endif
+}
+
+static gboolean
+g_socket_initable_init (GInitable *initable,
+			GCancellable *cancellable,
+			GError  **error)
+{
+  GSocket  *socket;
+
+  g_return_val_if_fail (G_IS_SOCKET (initable), FALSE);
+
+  socket = G_SOCKET (initable);
+
+  if (cancellable != NULL)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                           _("Cancellable initialization not supported"));
+      return FALSE;
+    }
+
+  socket->priv->inited = TRUE;
+
+  if (socket->priv->construct_error)
+    {
+      if (error)
+	*error = g_error_copy (socket->priv->construct_error);
+      return FALSE;
+    }
+
+
+  return TRUE;
+}
+
+static gboolean
+check_datagram_based (GDatagramBased  *self,
+                      GError         **error)
+{
+  switch (g_socket_get_socket_type (G_SOCKET (self)))
+    {
+    case G_SOCKET_TYPE_INVALID:
+    case G_SOCKET_TYPE_STREAM:
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   _("Cannot use datagram operations on a non-datagram "
+                     "socket."));
+      return FALSE;
+    case G_SOCKET_TYPE_DATAGRAM:
+    case G_SOCKET_TYPE_SEQPACKET:
+      /* Fall through. */
+      break;
+    }
+
+  /* Due to us sharing #GSocketSource with the #GSocket implementation, it is
+   * pretty tricky to split out #GSocket:timeout so that it does not affect
+   * #GDatagramBased operations (but still affects #GSocket operations). It is
+   * not worth that effort  just disallow it and require the user to specify
+   * timeouts on a per-operation basis. */
+  if (g_socket_get_timeout (G_SOCKET (self)) != 0)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   _("Cannot use datagram operations on a socket with a "
+                     "timeout set."));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static gint
+g_socket_datagram_based_receive_messages (GDatagramBased  *self,
+                                          GInputMessage   *messages,
+                                          guint            num_messages,
+                                          gint             flags,
+                                          gint64           timeout,
+                                          GCancellable    *cancellable,
+                                          GError         **error)
+{
+  if (!check_datagram_based (self, error))
+    return FALSE;
+
+  return g_socket_receive_messages_with_timeout (G_SOCKET (self), messages,
+                                                 num_messages, flags, timeout,
+                                                 cancellable, error);
+}
+
+static gint
+g_socket_datagram_based_send_messages (GDatagramBased  *self,
+                                       GOutputMessage  *messages,
+                                       guint            num_messages,
+                                       gint             flags,
+                                       gint64           timeout,
+                                       GCancellable    *cancellable,
+                                       GError         **error)
+{
+  if (!check_datagram_based (self, error))
+    return FALSE;
+
+  return g_socket_send_messages_with_timeout (G_SOCKET (self), messages,
+                                              num_messages, flags, timeout,
+                                              cancellable, error);
+}
+
+static GSource *
+g_socket_datagram_based_create_source (GDatagramBased  *self,
+                                       GIOCondition     condition,
+                                       GCancellable    *cancellable)
+{
+  if (!check_datagram_based (self, NULL))
+    return NULL;
+
+  return g_socket_create_source (G_SOCKET (self), condition, cancellable);
+}
+
+static GIOCondition
+g_socket_datagram_based_condition_check (GDatagramBased  *datagram_based,
+                                         GIOCondition     condition)
+{
+  if (!check_datagram_based (datagram_based, NULL))
+    return G_IO_ERR;
+
+  return g_socket_condition_check (G_SOCKET (datagram_based), condition);
+}
+
+static gboolean
+g_socket_datagram_based_condition_wait (GDatagramBased  *datagram_based,
+                                        GIOCondition     condition,
+                                        gint64           timeout,
+                                        GCancellable    *cancellable,
+                                        GError         **error)
+{
+  if (!check_datagram_based (datagram_based, error))
+    return FALSE;
+
+  return g_socket_condition_timed_wait (G_SOCKET (datagram_based), condition,
+                                        timeout, cancellable, error);
+}
+
+/**
+ * g_socket_new:
+ * @family: the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.
+ * @type: the socket type to use.
+ * @protocol: the id of the protocol to use, or 0 for default.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Creates a new #GSocket with the defined family, type and protocol.
+ * If @protocol is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
+ * for the family and type is used.
+ *
+ * The @protocol is a family and type specific int that specifies what
+ * kind of protocol to use. #GSocketProtocol lists several common ones.
+ * Many families only support one protocol, and use 0 for this, others
+ * support several and using 0 means to use the default protocol for
+ * the family and type.
+ *
+ * The protocol id is passed directly to the operating
+ * system, so you can use protocols not listed in #GSocketProtocol if you
+ * know the protocol number used for it.
+ *
+ * Returns: a #GSocket or %NULL on error.
+ *     Free the returned object with g_object_unref().
+ *
+ * Since: 2.22
+ */
+GSocket *
+g_socket_new (GSocketFamily     family,
+	      GSocketType       type,
+	      GSocketProtocol   protocol,
+	      GError          **error)
+{
+  return G_SOCKET (g_initable_new (G_TYPE_SOCKET,
+				   NULL, error,
+				   "family", family,
+				   "type", type,
+				   "protocol", protocol,
+				   NULL));
+}
+
+/**
+ * g_socket_new_from_fd:
+ * @fd: a native socket file descriptor.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Creates a new #GSocket from a native file descriptor
+ * or winsock SOCKET handle.
+ *
+ * This reads all the settings from the file descriptor so that
+ * all properties should work. Note that the file descriptor
+ * will be set to non-blocking mode, independent on the blocking
+ * mode of the #GSocket.
+ *
+ * On success, the returned #GSocket takes ownership of @fd. On failure, the
+ * caller must close @fd themselves.
+ *
+ * Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
+ * descriptor.  Instead, a GError will be set with code %G_IO_ERROR_FAILED
+ *
+ * Returns: a #GSocket or %NULL on error.
+ *     Free the returned object with g_object_unref().
+ *
+ * Since: 2.22
+ */
+GSocket *
+g_socket_new_from_fd (gint     fd,
+		      GError **error)
+{
+  return G_SOCKET (g_initable_new (G_TYPE_SOCKET,
+				   NULL, error,
+				   "fd", fd,
+				   NULL));
+}
+
+/**
+ * g_socket_set_blocking:
+ * @socket: a #GSocket.
+ * @blocking: Whether to use blocking I/O or not.
+ *
+ * Sets the blocking mode of the socket. In blocking mode
+ * all operations (which dont take an explicit blocking parameter) block until
+ * they succeed or there is an error. In
+ * non-blocking mode all functions return results immediately or
+ * with a %G_IO_ERROR_WOULD_BLOCK error.
+ *
+ * All sockets are created in blocking mode. However, note that the
+ * platform level socket is always non-blocking, and blocking mode
+ * is a GSocket level feature.
+ *
+ * Since: 2.22
+ */
+void
+g_socket_set_blocking (GSocket  *socket,
+		       gboolean  blocking)
+{
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  blocking = !!blocking;
+
+  if (socket->priv->blocking == blocking)
+    return;
+
+  socket->priv->blocking = blocking;
+  g_object_notify (G_OBJECT (socket), "blocking");
+}
+
+/**
+ * g_socket_get_blocking:
+ * @socket: a #GSocket.
+ *
+ * Gets the blocking mode of the socket. For details on blocking I/O,
+ * see g_socket_set_blocking().
+ *
+ * Returns: %TRUE if blocking I/O is used, %FALSE otherwise.
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_get_blocking (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  return socket->priv->blocking;
+}
+
+/**
+ * g_socket_set_keepalive:
+ * @socket: a #GSocket.
+ * @keepalive: Value for the keepalive flag
+ *
+ * Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
+ * this flag is set on a socket, the system will attempt to verify that the
+ * remote socket endpoint is still present if a sufficiently long period of
+ * time passes with no data being exchanged. If the system is unable to
+ * verify the presence of the remote endpoint, it will automatically close
+ * the connection.
+ *
+ * This option is only functional on certain kinds of sockets. (Notably,
+ * %G_SOCKET_PROTOCOL_TCP sockets.)
+ *
+ * The exact time between pings is system- and protocol-dependent, but will
+ * normally be at least two hours. Most commonly, you would set this flag
+ * on a server socket if you want to allow clients to remain idle for long
+ * periods of time, but also want to ensure that connections are eventually
+ * garbage-collected if clients crash or become unreachable.
+ *
+ * Since: 2.22
+ */
+void
+g_socket_set_keepalive (GSocket  *socket,
+			gboolean  keepalive)
+{
+  GError *error = NULL;
+
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  keepalive = !!keepalive;
+  if (socket->priv->keepalive == keepalive)
+    return;
+
+  if (!g_socket_set_option (socket, SOL_SOCKET, SO_KEEPALIVE,
+			    keepalive, &error))
+    {
+      g_warning ("error setting keepalive: %s", error->message);
+      g_error_free (error);
+      return;
+    }
+
+  socket->priv->keepalive = keepalive;
+  g_object_notify (G_OBJECT (socket), "keepalive");
+}
+
+/**
+ * g_socket_get_keepalive:
+ * @socket: a #GSocket.
+ *
+ * Gets the keepalive mode of the socket. For details on this,
+ * see g_socket_set_keepalive().
+ *
+ * Returns: %TRUE if keepalive is active, %FALSE otherwise.
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_get_keepalive (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  return socket->priv->keepalive;
+}
+
+/**
+ * g_socket_get_listen_backlog:
+ * @socket: a #GSocket.
+ *
+ * Gets the listen backlog setting of the socket. For details on this,
+ * see g_socket_set_listen_backlog().
+ *
+ * Returns: the maximum number of pending connections.
+ *
+ * Since: 2.22
+ */
+gint
+g_socket_get_listen_backlog  (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), 0);
+
+  return socket->priv->listen_backlog;
+}
+
+/**
+ * g_socket_set_listen_backlog:
+ * @socket: a #GSocket.
+ * @backlog: the maximum number of pending connections.
+ *
+ * Sets the maximum number of outstanding connections allowed
+ * when listening on this socket. If more clients than this are
+ * connecting to the socket and the application is not handling them
+ * on time then the new connections will be refused.
+ *
+ * Note that this must be called before g_socket_listen() and has no
+ * effect if called after that.
+ *
+ * Since: 2.22
+ */
+void
+g_socket_set_listen_backlog (GSocket *socket,
+			     gint     backlog)
+{
+  g_return_if_fail (G_IS_SOCKET (socket));
+  g_return_if_fail (!socket->priv->listening);
+
+  if (backlog != socket->priv->listen_backlog)
+    {
+      socket->priv->listen_backlog = backlog;
+      g_object_notify (G_OBJECT (socket), "listen-backlog");
+    }
+}
+
+/**
+ * g_socket_get_timeout:
+ * @socket: a #GSocket.
+ *
+ * Gets the timeout setting of the socket. For details on this, see
+ * g_socket_set_timeout().
+ *
+ * Returns: the timeout in seconds
+ *
+ * Since: 2.26
+ */
+guint
+g_socket_get_timeout (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), 0);
+
+  return socket->priv->timeout;
+}
+
+/**
+ * g_socket_set_timeout:
+ * @socket: a #GSocket.
+ * @timeout: the timeout for @socket, in seconds, or 0 for none
+ *
+ * Sets the time in seconds after which I/O operations on @socket will
+ * time out if they have not yet completed.
+ *
+ * On a blocking socket, this means that any blocking #GSocket
+ * operation will time out after @timeout seconds of inactivity,
+ * returning %G_IO_ERROR_TIMED_OUT.
+ *
+ * On a non-blocking socket, calls to g_socket_condition_wait() will
+ * also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
+ * created with g_socket_create_source() will trigger after
+ * @timeout seconds of inactivity, with the requested condition
+ * set, at which point calling g_socket_receive(), g_socket_send(),
+ * g_socket_check_connect_result(), etc, will fail with
+ * %G_IO_ERROR_TIMED_OUT.
+ *
+ * If @timeout is 0 (the default), operations will never time out
+ * on their own.
+ *
+ * Note that if an I/O operation is interrupted by a signal, this may
+ * cause the timeout to be reset.
+ *
+ * Since: 2.26
+ */
+void
+g_socket_set_timeout (GSocket *socket,
+		      guint    timeout)
+{
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  if (timeout != socket->priv->timeout)
+    {
+      socket->priv->timeout = timeout;
+      g_object_notify (G_OBJECT (socket), "timeout");
+    }
+}
+
+/**
+ * g_socket_get_ttl:
+ * @socket: a #GSocket.
+ *
+ * Gets the unicast time-to-live setting on @socket; see
+ * g_socket_set_ttl() for more details.
+ *
+ * Returns: the time-to-live setting on @socket
+ *
+ * Since: 2.32
+ */
+guint
+g_socket_get_ttl (GSocket *socket)
+{
+  GError *error = NULL;
+  gint value;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), 0);
+
+  if (socket->priv->family == G_SOCKET_FAMILY_IPV4)
+    {
+      g_socket_get_option (socket, IPPROTO_IP, IP_TTL,
+			   &value, &error);
+    }
+  else if (socket->priv->family == G_SOCKET_FAMILY_IPV6)
+    {
+      g_socket_get_option (socket, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
+			   &value, &error);
+    }
+  else
+    g_return_val_if_reached (0);
+
+  if (error)
+    {
+      g_warning ("error getting unicast ttl: %s", error->message);
+      g_error_free (error);
+      return 0;
+    }
+
+  return value;
+}
+
+/**
+ * g_socket_set_ttl:
+ * @socket: a #GSocket.
+ * @ttl: the time-to-live value for all unicast packets on @socket
+ *
+ * Sets the time-to-live for outgoing unicast packets on @socket.
+ * By default the platform-specific default value is used.
+ *
+ * Since: 2.32
+ */
+void
+g_socket_set_ttl (GSocket  *socket,
+                  guint     ttl)
+{
+  GError *error = NULL;
+
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  if (socket->priv->family == G_SOCKET_FAMILY_IPV4)
+    {
+      g_socket_set_option (socket, IPPROTO_IP, IP_TTL,
+			   ttl, &error);
+    }
+  else if (socket->priv->family == G_SOCKET_FAMILY_IPV6)
+    {
+      g_socket_set_option (socket, IPPROTO_IP, IP_TTL,
+			   ttl, NULL);
+      g_socket_set_option (socket, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
+			   ttl, &error);
+    }
+  else
+    g_return_if_reached ();
+
+  if (error)
+    {
+      g_warning ("error setting unicast ttl: %s", error->message);
+      g_error_free (error);
+      return;
+    }
+
+  g_object_notify (G_OBJECT (socket), "ttl");
+}
+
+/**
+ * g_socket_get_broadcast:
+ * @socket: a #GSocket.
+ *
+ * Gets the broadcast setting on @socket; if %TRUE,
+ * it is possible to send packets to broadcast
+ * addresses.
+ *
+ * Returns: the broadcast setting on @socket
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_get_broadcast (GSocket *socket)
+{
+  GError *error = NULL;
+  gint value;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  if (!g_socket_get_option (socket, SOL_SOCKET, SO_BROADCAST,
+			    &value, &error))
+    {
+      g_warning ("error getting broadcast: %s", error->message);
+      g_error_free (error);
+      return FALSE;
+    }
+
+  return !!value;
+}
+
+/**
+ * g_socket_set_broadcast:
+ * @socket: a #GSocket.
+ * @broadcast: whether @socket should allow sending to broadcast
+ *     addresses
+ *
+ * Sets whether @socket should allow sending to broadcast addresses.
+ * This is %FALSE by default.
+ *
+ * Since: 2.32
+ */
+void
+g_socket_set_broadcast (GSocket    *socket,
+       	                gboolean    broadcast)
+{
+  GError *error = NULL;
+
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  broadcast = !!broadcast;
+
+  if (!g_socket_set_option (socket, SOL_SOCKET, SO_BROADCAST,
+			    broadcast, &error))
+    {
+      g_warning ("error setting broadcast: %s", error->message);
+      g_error_free (error);
+      return;
+    }
+
+  g_object_notify (G_OBJECT (socket), "broadcast");
+}
+
+/**
+ * g_socket_get_multicast_loopback:
+ * @socket: a #GSocket.
+ *
+ * Gets the multicast loopback setting on @socket; if %TRUE (the
+ * default), outgoing multicast packets will be looped back to
+ * multicast listeners on the same host.
+ *
+ * Returns: the multicast loopback setting on @socket
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_get_multicast_loopback (GSocket *socket)
+{
+  GError *error = NULL;
+  gint value;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  if (socket->priv->family == G_SOCKET_FAMILY_IPV4)
+    {
+      g_socket_get_option (socket, IPPROTO_IP, IP_MULTICAST_LOOP,
+			   &value, &error);
+    }
+  else if (socket->priv->family == G_SOCKET_FAMILY_IPV6)
+    {
+      g_socket_get_option (socket, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
+			   &value, &error);
+    }
+  else
+    g_return_val_if_reached (FALSE);
+
+  if (error)
+    {
+      g_warning ("error getting multicast loopback: %s", error->message);
+      g_error_free (error);
+      return FALSE;
+    }
+
+  return !!value;
+}
+
+/**
+ * g_socket_set_multicast_loopback:
+ * @socket: a #GSocket.
+ * @loopback: whether @socket should receive messages sent to its
+ *   multicast groups from the local host
+ *
+ * Sets whether outgoing multicast packets will be received by sockets
+ * listening on that multicast address on the same host. This is %TRUE
+ * by default.
+ *
+ * Since: 2.32
+ */
+void
+g_socket_set_multicast_loopback (GSocket    *socket,
+				 gboolean    loopback)
+{
+  GError *error = NULL;
+
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  loopback = !!loopback;
+
+  if (socket->priv->family == G_SOCKET_FAMILY_IPV4)
+    {
+      g_socket_set_option (socket, IPPROTO_IP, IP_MULTICAST_LOOP,
+			   loopback, &error);
+    }
+  else if (socket->priv->family == G_SOCKET_FAMILY_IPV6)
+    {
+      g_socket_set_option (socket, IPPROTO_IP, IP_MULTICAST_LOOP,
+			   loopback, NULL);
+      g_socket_set_option (socket, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
+			   loopback, &error);
+    }
+  else
+    g_return_if_reached ();
+
+  if (error)
+    {
+      g_warning ("error setting multicast loopback: %s", error->message);
+      g_error_free (error);
+      return;
+    }
+
+  g_object_notify (G_OBJECT (socket), "multicast-loopback");
+}
+
+/**
+ * g_socket_get_multicast_ttl:
+ * @socket: a #GSocket.
+ *
+ * Gets the multicast time-to-live setting on @socket; see
+ * g_socket_set_multicast_ttl() for more details.
+ *
+ * Returns: the multicast time-to-live setting on @socket
+ *
+ * Since: 2.32
+ */
+guint
+g_socket_get_multicast_ttl (GSocket *socket)
+{
+  GError *error = NULL;
+  gint value;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), 0);
+
+  if (socket->priv->family == G_SOCKET_FAMILY_IPV4)
+    {
+      g_socket_get_option (socket, IPPROTO_IP, IP_MULTICAST_TTL,
+			   &value, &error);
+    }
+  else if (socket->priv->family == G_SOCKET_FAMILY_IPV6)
+    {
+      g_socket_get_option (socket, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+			   &value, &error);
+    }
+  else
+    g_return_val_if_reached (FALSE);
+
+  if (error)
+    {
+      g_warning ("error getting multicast ttl: %s", error->message);
+      g_error_free (error);
+      return FALSE;
+    }
+
+  return value;
+}
+
+/**
+ * g_socket_set_multicast_ttl:
+ * @socket: a #GSocket.
+ * @ttl: the time-to-live value for all multicast datagrams on @socket
+ *
+ * Sets the time-to-live for outgoing multicast datagrams on @socket.
+ * By default, this is 1, meaning that multicast packets will not leave
+ * the local network.
+ *
+ * Since: 2.32
+ */
+void
+g_socket_set_multicast_ttl (GSocket  *socket,
+                            guint     ttl)
+{
+  GError *error = NULL;
+
+  g_return_if_fail (G_IS_SOCKET (socket));
+
+  if (socket->priv->family == G_SOCKET_FAMILY_IPV4)
+    {
+      g_socket_set_option (socket, IPPROTO_IP, IP_MULTICAST_TTL,
+			   ttl, &error);
+    }
+  else if (socket->priv->family == G_SOCKET_FAMILY_IPV6)
+    {
+      g_socket_set_option (socket, IPPROTO_IP, IP_MULTICAST_TTL,
+			   ttl, NULL);
+      g_socket_set_option (socket, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+			   ttl, &error);
+    }
+  else
+    g_return_if_reached ();
+
+  if (error)
+    {
+      g_warning ("error setting multicast ttl: %s", error->message);
+      g_error_free (error);
+      return;
+    }
+
+  g_object_notify (G_OBJECT (socket), "multicast-ttl");
+}
+
+/**
+ * g_socket_get_family:
+ * @socket: a #GSocket.
+ *
+ * Gets the socket family of the socket.
+ *
+ * Returns: a #GSocketFamily
+ *
+ * Since: 2.22
+ */
+GSocketFamily
+g_socket_get_family (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), G_SOCKET_FAMILY_INVALID);
+
+  return socket->priv->family;
+}
+
+/**
+ * g_socket_get_socket_type:
+ * @socket: a #GSocket.
+ *
+ * Gets the socket type of the socket.
+ *
+ * Returns: a #GSocketType
+ *
+ * Since: 2.22
+ */
+GSocketType
+g_socket_get_socket_type (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), G_SOCKET_TYPE_INVALID);
+
+  return socket->priv->type;
+}
+
+/**
+ * g_socket_get_protocol:
+ * @socket: a #GSocket.
+ *
+ * Gets the socket protocol id the socket was created with.
+ * In case the protocol is unknown, -1 is returned.
+ *
+ * Returns: a protocol id, or -1 if unknown
+ *
+ * Since: 2.22
+ */
+GSocketProtocol
+g_socket_get_protocol (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+
+  return socket->priv->protocol;
+}
+
+/**
+ * g_socket_get_fd:
+ * @socket: a #GSocket.
+ *
+ * Returns the underlying OS socket object. On unix this
+ * is a socket file descriptor, and on Windows this is
+ * a Winsock2 SOCKET handle. This may be useful for
+ * doing platform specific or otherwise unusual operations
+ * on the socket.
+ *
+ * Returns: the file descriptor of the socket.
+ *
+ * Since: 2.22
+ */
+int
+g_socket_get_fd (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+
+  return socket->priv->fd;
+}
+
+/**
+ * g_socket_get_local_address:
+ * @socket: a #GSocket.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Try to get the local address of a bound socket. This is only
+ * useful if the socket has been bound to a local address,
+ * either explicitly or implicitly when connecting.
+ *
+ * Returns: (transfer full): a #GSocketAddress or %NULL on error.
+ *     Free the returned object with g_object_unref().
+ *
+ * Since: 2.22
+ */
+GSocketAddress *
+g_socket_get_local_address (GSocket  *socket,
+			    GError  **error)
+{
+  struct sockaddr_storage buffer;
+  guint len = sizeof (buffer);
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), NULL);
+
+  if (getsockname (socket->priv->fd, (struct sockaddr *) &buffer, &len) < 0)
+    {
+      int errsv = get_socket_errno ();
+      g_set_error (error, G_IO_ERROR, socket_io_error_from_errno (errsv),
+		   _("could not get local address: %s"), socket_strerror (errsv));
+      return NULL;
+    }
+
+  return g_socket_address_new_from_native (&buffer, len);
+}
+
+/**
+ * g_socket_get_remote_address:
+ * @socket: a #GSocket.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Try to get the remove address of a connected socket. This is only
+ * useful for connection oriented sockets that have been connected.
+ *
+ * Returns: (transfer full): a #GSocketAddress or %NULL on error.
+ *     Free the returned object with g_object_unref().
+ *
+ * Since: 2.22
+ */
+GSocketAddress *
+g_socket_get_remote_address (GSocket  *socket,
+			     GError  **error)
+{
+  struct sockaddr_storage buffer;
+  guint len = sizeof (buffer);
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), NULL);
+
+  if (socket->priv->connect_pending)
+    {
+      if (!g_socket_check_connect_result (socket, error))
+        return NULL;
+      else
+        socket->priv->connect_pending = FALSE;
+    }
+
+  if (!socket->priv->remote_address)
+    {
+      if (getpeername (socket->priv->fd, (struct sockaddr *) &buffer, &len) < 0)
+	{
+	  int errsv = get_socket_errno ();
+	  g_set_error (error, G_IO_ERROR, socket_io_error_from_errno (errsv),
+		       _("could not get remote address: %s"), socket_strerror (errsv));
+	  return NULL;
+	}
+
+      socket->priv->remote_address = g_socket_address_new_from_native (&buffer, len);
+    }
+
+  return g_object_ref (socket->priv->remote_address);
+}
+
+/**
+ * g_socket_is_connected:
+ * @socket: a #GSocket.
+ *
+ * Check whether the socket is connected. This is only useful for
+ * connection-oriented sockets.
+ *
+ * If using g_socket_shutdown(), this function will return %TRUE until the
+ * socket has been shut down for reading and writing. If you do a non-blocking
+ * connect, this function will not return %TRUE until after you call
+ * g_socket_check_connect_result().
+ *
+ * Returns: %TRUE if socket is connected, %FALSE otherwise.
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_is_connected (GSocket *socket)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  return (socket->priv->connected_read || socket->priv->connected_write);
+}
+
+/**
+ * g_socket_listen:
+ * @socket: a #GSocket.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Marks the socket as a server socket, i.e. a socket that is used
+ * to accept incoming requests using g_socket_accept().
+ *
+ * Before calling this the socket must be bound to a local address using
+ * g_socket_bind().
+ *
+ * To set the maximum amount of outstanding clients, use
+ * g_socket_set_listen_backlog().
+ *
+ * Returns: %TRUE on success, %FALSE on error.
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_listen (GSocket  *socket,
+		 GError  **error)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  if (listen (socket->priv->fd, socket->priv->listen_backlog) < 0)
+    {
+      int errsv = get_socket_errno ();
+
+      g_set_error (error, G_IO_ERROR, socket_io_error_from_errno (errsv),
+		   _("could not listen: %s"), socket_strerror (errsv));
+      return FALSE;
+    }
+
+  socket->priv->listening = TRUE;
+
+  return TRUE;
+}
+
+/**
+ * g_socket_bind:
+ * @socket: a #GSocket.
+ * @address: a #GSocketAddress specifying the local address.
+ * @allow_reuse: whether to allow reusing this address
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * When a socket is created it is attached to an address family, but it
+ * doesn't have an address in this family. g_socket_bind() assigns the
+ * address (sometimes called name) of the socket.
+ *
+ * It is generally required to bind to a local address before you can
+ * receive connections. (See g_socket_listen() and g_socket_accept() ).
+ * In certain situations, you may also want to bind a socket that will be
+ * used to initiate connections, though this is not normally required.
+ *
+ * If @socket is a TCP socket, then @allow_reuse controls the setting
+ * of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
+ * server sockets (sockets that you will eventually call
+ * g_socket_accept() on), and %FALSE for client sockets. (Failing to
+ * set this flag on a server socket may cause g_socket_bind() to return
+ * %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
+ * immediately restarted.)
+ *
+ * If @socket is a UDP socket, then @allow_reuse determines whether or
+ * not other UDP sockets can be bound to the same address at the same
+ * time. In particular, you can have several UDP sockets bound to the
+ * same address, and they will all receive all of the multicast and
+ * broadcast packets sent to that address. (The behavior of unicast
+ * UDP packets to an address with multiple listeners is not defined.)
+ *
+ * Returns: %TRUE on success, %FALSE on error.
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_bind (GSocket         *socket,
+	       GSocketAddress  *address,
+	       gboolean         reuse_address,
+	       GError         **error)
+{
+  struct sockaddr_storage addr;
+  gboolean so_reuseaddr;
+#ifdef SO_REUSEPORT
+  gboolean so_reuseport;
+#endif
+
+  g_return_val_if_fail (G_IS_SOCKET (socket) && G_IS_SOCKET_ADDRESS (address), FALSE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  if (!g_socket_address_to_native (address, &addr, sizeof addr, error))
+    return FALSE;
+
+  /* On Windows, SO_REUSEADDR has the semantics we want for UDP
+   * sockets, but has nasty side effects we don't want for TCP
+   * sockets.
+   *
+   * On other platforms, we set SO_REUSEPORT, if it exists, for
+   * UDP sockets, and SO_REUSEADDR for all sockets, hoping that
+   * if SO_REUSEPORT doesn't exist, then SO_REUSEADDR will have
+   * the desired semantics on UDP (as it does on Linux, although
+   * Linux has SO_REUSEPORT too as of 3.9).
+   */
+
+#ifdef G_OS_WIN32
+  so_reuseaddr = reuse_address && (socket->priv->type == G_SOCKET_TYPE_DATAGRAM);
+#else
+  so_reuseaddr = !!reuse_address;
+#endif
+
+#ifdef SO_REUSEPORT
+  so_reuseport = reuse_address && (socket->priv->type == G_SOCKET_TYPE_DATAGRAM);
+#endif
+
+  /* Ignore errors here, the only likely error is "not supported", and
+   * this is a "best effort" thing mainly.
+   */
+  g_socket_set_option (socket, SOL_SOCKET, SO_REUSEADDR, so_reuseaddr, NULL);
+#ifdef SO_REUSEPORT
+  g_socket_set_option (socket, SOL_SOCKET, SO_REUSEPORT, so_reuseport, NULL);
+#endif
+
+  if (bind (socket->priv->fd, (struct sockaddr *) &addr,
+	    g_socket_address_get_native_size (address)) < 0)
+    {
+      int errsv = get_socket_errno ();
+      g_set_error (error,
+		   G_IO_ERROR, socket_io_error_from_errno (errsv),
+		   _("Error binding to address: %s"), socket_strerror (errsv));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+#if !defined(HAVE_IF_NAMETOINDEX) && defined(G_OS_WIN32)
+static guint
+if_nametoindex (const gchar *iface)
+{
+  PIP_ADAPTER_ADDRESSES addresses = NULL, p;
+  gulong addresses_len = 0;
+  guint idx = 0;
+  DWORD res;
+
+  if (ws2funcs.pIfNameToIndex != NULL)
+    return ws2funcs.pIfNameToIndex (iface);
+
+  res = GetAdaptersAddresses (AF_UNSPEC, 0, NULL, NULL, &addresses_len);
+  if (res != NO_ERROR && res != ERROR_BUFFER_OVERFLOW)
+    {
+      if (res == ERROR_NO_DATA)
+        errno = ENXIO;
+      else
+        errno = EINVAL;
+      return 0;
+    }
+
+  addresses = g_malloc (addresses_len);
+  res = GetAdaptersAddresses (AF_UNSPEC, 0, NULL, addresses, &addresses_len);
+
+  if (res != NO_ERROR)
+    {
+      g_free (addresses);
+      if (res == ERROR_NO_DATA)
+        errno = ENXIO;
+      else
+        errno = EINVAL;
+      return 0;
+    }
+
+  p = addresses;
+  while (p)
+    {
+      if (strcmp (p->AdapterName, iface) == 0)
+        {
+          idx = p->IfIndex;
+          break;
+        }
+      p = p->Next;
+    }
+
+  if (p == NULL)
+    errno = ENXIO;
+
+  g_free (addresses);
+
+  return idx;
+}
+
+#define HAVE_IF_NAMETOINDEX 1
+#endif
+
+static gboolean
+g_socket_multicast_group_operation (GSocket       *socket,
+				    GInetAddress  *group,
+                                    gboolean       source_specific,
+                                    const gchar   *iface,
+				    gboolean       join_group,
+				    GError       **error)
+{
+  const guint8 *native_addr;
+  gint optname, result;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+  g_return_val_if_fail (socket->priv->type == G_SOCKET_TYPE_DATAGRAM, FALSE);
+  g_return_val_if_fail (G_IS_INET_ADDRESS (group), FALSE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  native_addr = g_inet_address_to_bytes (group);
+  if (g_inet_address_get_family (group) == G_SOCKET_FAMILY_IPV4)
+    {
+#ifdef HAVE_IP_MREQN
+      struct ip_mreqn mc_req;
+#else
+      struct ip_mreq mc_req;
+#endif
+
+      memset (&mc_req, 0, sizeof (mc_req));
+      memcpy (&mc_req.imr_multiaddr, native_addr, sizeof (struct in_addr));
+
+#ifdef HAVE_IP_MREQN
+      if (iface)
+        mc_req.imr_ifindex = if_nametoindex (iface);
+      else
+        mc_req.imr_ifindex = 0;  /* Pick any.  */
+#elif defined(G_OS_WIN32)
+      if (iface)
+        mc_req.imr_interface.s_addr = g_htonl (if_nametoindex (iface));
+      else
+        mc_req.imr_interface.s_addr = g_htonl (INADDR_ANY);
+#else
+      mc_req.imr_interface.s_addr = g_htonl (INADDR_ANY);
+#endif
+
+      if (source_specific)
+	{
+#ifdef IP_ADD_SOURCE_MEMBERSHIP
+	  optname = join_group ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
+#else
+	  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+		       join_group ?
+		       _("Error joining multicast group: %s") :
+		       _("Error leaving multicast group: %s"),
+		       _("No support for source-specific multicast"));
+	  return FALSE;
+#endif
+	}
+      else
+        optname = join_group ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
+      result = setsockopt (socket->priv->fd, IPPROTO_IP, optname,
+			   &mc_req, sizeof (mc_req));
+    }
+  else if (g_inet_address_get_family (group) == G_SOCKET_FAMILY_IPV6)
+    {
+      struct ipv6_mreq mc_req_ipv6;
+
+      memset (&mc_req_ipv6, 0, sizeof (mc_req_ipv6));
+      memcpy (&mc_req_ipv6.ipv6mr_multiaddr, native_addr, sizeof (struct in6_addr));
+#ifdef HAVE_IF_NAMETOINDEX
+      if (iface)
+        mc_req_ipv6.ipv6mr_interface = if_nametoindex (iface);
+      else
+#endif
+        mc_req_ipv6.ipv6mr_interface = 0;
+
+      optname = join_group ? IPV6_JOIN_GROUP : IPV6_LEAVE_GROUP;
+      result = setsockopt (socket->priv->fd, IPPROTO_IPV6, optname,
+			   &mc_req_ipv6, sizeof (mc_req_ipv6));
+    }
+  else
+    g_return_val_if_reached (FALSE);
+
+  if (result < 0)
+    {
+      int errsv = get_socket_errno ();
+
+      g_set_error (error, G_IO_ERROR, socket_io_error_from_errno (errsv),
+		   join_group ?
+		   _("Error joining multicast group: %s") :
+		   _("Error leaving multicast group: %s"),
+		   socket_strerror (errsv));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/**
+ * g_socket_join_multicast_group:
+ * @socket: a #GSocket.
+ * @group: a #GInetAddress specifying the group address to join.
+ * @iface: (allow-none): Name of the interface to use, or %NULL
+ * @source_specific: %TRUE if source-specific multicast should be used
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Registers @socket to receive multicast messages sent to @group.
+ * @socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
+ * been bound to an appropriate interface and port with
+ * g_socket_bind().
+ *
+ * If @iface is %NULL, the system will automatically pick an interface
+ * to bind to based on @group.
+ *
+ * If @source_specific is %TRUE, source-specific multicast as defined
+ * in RFC 4604 is used. Note that on older platforms this may fail
+ * with a %G_IO_ERROR_NOT_SUPPORTED error.
+ *
+ * Returns: %TRUE on success, %FALSE on error.
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_join_multicast_group (GSocket       *socket,
+			       GInetAddress  *group,
+                               gboolean       source_specific,
+                               const gchar   *iface,
+			       GError       **error)
+{
+  return g_socket_multicast_group_operation (socket, group, source_specific, iface, TRUE, error);
+}
+
+/**
+ * g_socket_leave_multicast_group:
+ * @socket: a #GSocket.
+ * @group: a #GInetAddress specifying the group address to leave.
+ * @iface: (allow-none): Interface used
+ * @source_specific: %TRUE if source-specific multicast was used
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Removes @socket from the multicast group defined by @group, @iface,
+ * and @source_specific (which must all have the same values they had
+ * when you joined the group).
+ *
+ * @socket remains bound to its address and port, and can still receive
+ * unicast messages after calling this.
+ *
+ * Returns: %TRUE on success, %FALSE on error.
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_leave_multicast_group (GSocket       *socket,
+				GInetAddress  *group,
+                                gboolean       source_specific,
+                                const gchar   *iface,
+				GError       **error)
+{
+  return g_socket_multicast_group_operation (socket, group, source_specific, iface, FALSE, error);
+}
+
+/**
+ * g_socket_speaks_ipv4:
+ * @socket: a #GSocket
+ *
+ * Checks if a socket is capable of speaking IPv4.
+ *
+ * IPv4 sockets are capable of speaking IPv4.  On some operating systems
+ * and under some combinations of circumstances IPv6 sockets are also
+ * capable of speaking IPv4.  See RFC 3493 section 3.7 for more
+ * information.
+ *
+ * No other types of sockets are currently considered as being capable
+ * of speaking IPv4.
+ *
+ * Returns: %TRUE if this socket can be used with IPv4.
+ *
+ * Since: 2.22
+ **/
+gboolean
+g_socket_speaks_ipv4 (GSocket *socket)
+{
+  switch (socket->priv->family)
+    {
+    case G_SOCKET_FAMILY_IPV4:
+      return TRUE;
+
+    case G_SOCKET_FAMILY_IPV6:
+#if defined (IPPROTO_IPV6) && defined (IPV6_V6ONLY)
+      {
+        gint v6_only;
+
+        if (!g_socket_get_option (socket,
+				  IPPROTO_IPV6, IPV6_V6ONLY,
+				  &v6_only, NULL))
+          return FALSE;
+
+        return !v6_only;
+      }
+#else
+      return FALSE;
+#endif
+
+    default:
+      return FALSE;
+    }
+}
+
+/**
+ * g_socket_accept:
+ * @socket: a #GSocket.
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Accept incoming connections on a connection-based socket. This removes
+ * the first outstanding connection request from the listening socket and
+ * creates a #GSocket object for it.
+ *
+ * The @socket must be bound to a local address with g_socket_bind() and
+ * must be listening for incoming connections (g_socket_listen()).
+ *
+ * If there are no outstanding connections then the operation will block
+ * or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
+ * To be notified of an incoming connection, wait for the %G_IO_IN condition.
+ *
+ * Returns: (transfer full): a new #GSocket, or %NULL on error.
+ *     Free the returned object with g_object_unref().
+ *
+ * Since: 2.22
+ */
+GSocket *
+g_socket_accept (GSocket       *socket,
+		 GCancellable  *cancellable,
+		 GError       **error)
+{
+  GSocket *new_socket;
+  gint ret;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), NULL);
+
+  if (!check_socket (socket, error))
+    return NULL;
+
+  if (!check_timeout (socket, error))
+    return NULL;
+
+  while (TRUE)
+    {
+      if ((ret = accept (socket->priv->fd, NULL, 0)) < 0)
+	{
+	  int errsv = get_socket_errno ();
+
+	  if (errsv == EINTR)
+	    continue;
+
+#ifdef WSAEWOULDBLOCK
+          if (errsv == WSAEWOULDBLOCK)
+#else
+          if (errsv == EWOULDBLOCK ||
+              errsv == EAGAIN)
+#endif
+            {
+              win32_unset_event_mask (socket, FD_ACCEPT);
+
+              if (socket->priv->blocking)
+                {
+                  if (!g_socket_condition_wait (socket,
+                                                G_IO_IN, cancellable, error))
+                    return NULL;
+
+                  continue;
+                }
+            }
+
+	  socket_set_error_lazy (error, errsv, _("Error accepting connection: %s"));
+	  return NULL;
+	}
+      break;
+    }
+
+  win32_unset_event_mask (socket, FD_ACCEPT);
+
+#ifdef G_OS_WIN32
+  {
+    /* The socket inherits the accepting sockets event mask and even object,
+       we need to remove that */
+    WSAEventSelect (ret, NULL, 0);
+  }
+#else
+  {
+    int flags;
+
+    /* We always want to set close-on-exec to protect users. If you
+       need to so some weird inheritance to exec you can re-enable this
+       using lower level hacks with g_socket_get_fd(). */
+    flags = fcntl (ret, F_GETFD, 0);
+    if (flags != -1 &&
+	(flags & FD_CLOEXEC) == 0)
+      {
+	flags |= FD_CLOEXEC;
+	fcntl (ret, F_SETFD, flags);
+      }
+  }
+#endif
+
+  new_socket = g_socket_new_from_fd (ret, error);
+  if (new_socket == NULL)
+    {
+#ifdef G_OS_WIN32
+      closesocket (ret);
+#else
+      close (ret);
+#endif
+    }
+  else
+    new_socket->priv->protocol = socket->priv->protocol;
+
+  return new_socket;
+}
+
+/**
+ * g_socket_connect:
+ * @socket: a #GSocket.
+ * @address: a #GSocketAddress specifying the remote address.
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Connect the socket to the specified remote address.
+ *
+ * For connection oriented socket this generally means we attempt to make
+ * a connection to the @address. For a connection-less socket it sets
+ * the default address for g_socket_send() and discards all incoming datagrams
+ * from other sources.
+ *
+ * Generally connection oriented sockets can only connect once, but
+ * connection-less sockets can connect multiple times to change the
+ * default address.
+ *
+ * If the connect call needs to do network I/O it will block, unless
+ * non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
+ * and the user can be notified of the connection finishing by waiting
+ * for the G_IO_OUT condition. The result of the connection must then be
+ * checked with g_socket_check_connect_result().
+ *
+ * Returns: %TRUE if connected, %FALSE on error.
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_connect (GSocket         *socket,
+		  GSocketAddress  *address,
+		  GCancellable    *cancellable,
+		  GError         **error)
+{
+  struct sockaddr_storage buffer;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket) && G_IS_SOCKET_ADDRESS (address), FALSE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  if (!g_socket_address_to_native (address, &buffer, sizeof buffer, error))
+    return FALSE;
+
+  if (socket->priv->remote_address)
+    g_object_unref (socket->priv->remote_address);
+  socket->priv->remote_address = g_object_ref (address);
+
+  while (1)
+    {
+      if (connect (socket->priv->fd, (struct sockaddr *) &buffer,
+		   g_socket_address_get_native_size (address)) < 0)
+	{
+	  int errsv = get_socket_errno ();
+
+	  if (errsv == EINTR)
+	    continue;
+
+#ifndef G_OS_WIN32
+	  if (errsv == EINPROGRESS)
+#else
+	  if (errsv == WSAEWOULDBLOCK)
+#endif
+	    {
+              win32_unset_event_mask (socket, FD_CONNECT);
+
+	      if (socket->priv->blocking)
+		{
+		  if (g_socket_condition_wait (socket, G_IO_OUT, cancellable, error))
+		    {
+		      if (g_socket_check_connect_result (socket, error))
+			break;
+		    }
+		}
+	      else
+                {
+                  g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_PENDING,
+                                       _("Connection in progress"));
+                  socket->priv->connect_pending = TRUE;
+                }
+	    }
+	  else
+	    g_set_error_literal (error, G_IO_ERROR,
+				 socket_io_error_from_errno (errsv),
+				 socket_strerror (errsv));
+
+	  return FALSE;
+	}
+      break;
+    }
+
+  win32_unset_event_mask (socket, FD_CONNECT);
+
+  socket->priv->connected_read = TRUE;
+  socket->priv->connected_write = TRUE;
+
+  return TRUE;
+}
+
+/**
+ * g_socket_check_connect_result:
+ * @socket: a #GSocket
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Checks and resets the pending connect error for the socket.
+ * This is used to check for errors when g_socket_connect() is
+ * used in non-blocking mode.
+ *
+ * Returns: %TRUE if no error, %FALSE otherwise, setting @error to the error
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_check_connect_result (GSocket  *socket,
+			       GError  **error)
+{
+  int value;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  if (!check_timeout (socket, error))
+    return FALSE;
+
+  if (!g_socket_get_option (socket, SOL_SOCKET, SO_ERROR, &value, error))
+    {
+      g_prefix_error (error, _("Unable to get pending error: "));
+      return FALSE;
+    }
+
+  if (value != 0)
+    {
+      g_set_error_literal (error, G_IO_ERROR, socket_io_error_from_errno (value),
+                           socket_strerror (value));
+      if (socket->priv->remote_address)
+        {
+          g_object_unref (socket->priv->remote_address);
+          socket->priv->remote_address = NULL;
+        }
+      return FALSE;
+    }
+
+  socket->priv->connected_read = TRUE;
+  socket->priv->connected_write = TRUE;
+
+  return TRUE;
+}
+
+/**
+ * g_socket_get_available_bytes:
+ * @socket: a #GSocket
+ *
+ * Get the amount of data pending in the OS input buffer, without blocking.
+ *
+ * If @socket is a UDP or SCTP socket, this will return the size of
+ * just the next packet, even if additional packets are buffered after
+ * that one.
+ *
+ * Note that on Windows, this function is rather inefficient in the
+ * UDP case, and so if you know any plausible upper bound on the size
+ * of the incoming packet, it is better to just do a
+ * g_socket_receive() with a buffer of that size, rather than calling
+ * g_socket_get_available_bytes() first and then doing a receive of
+ * exactly the right size.
+ *
+ * Returns: the number of bytes that can be read from the socket
+ * without blocking or truncating, or -1 on error.
+ *
+ * Since: 2.32
+ */
+gssize
+g_socket_get_available_bytes (GSocket *socket)
+{
+#ifdef G_OS_WIN32
+  const gint bufsize = 64 * 1024;
+  static guchar *buf = NULL;
+  u_long avail;
+#else
+  gint avail;
+#endif
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+
+#if defined (SO_NREAD)
+  if (!g_socket_get_option (socket, SOL_SOCKET, SO_NREAD, &avail, NULL))
+      return -1;
+#elif !defined (G_OS_WIN32)
+  if (ioctl (socket->priv->fd, FIONREAD, &avail) < 0)
+    avail = -1;
+#else
+  if (socket->priv->type == G_SOCKET_TYPE_DATAGRAM)
+    {
+      if (G_UNLIKELY (g_once_init_enter (&buf)))
+        g_once_init_leave (&buf, g_malloc (bufsize));
+
+      avail = recv (socket->priv->fd, buf, bufsize, MSG_PEEK);
+      if (avail == -1 && get_socket_errno () == WSAEWOULDBLOCK)
+        avail = 0;
+    }
+  else
+    {
+      if (ioctlsocket (socket->priv->fd, FIONREAD, &avail) < 0)
+        avail = -1;
+    }
+#endif
+
+  return avail;
+}
+
+/* Block on a timed wait for @condition until (@start_time + @timeout).
+ * Return %G_IO_ERROR_TIMED_OUT if the timeout is reached; otherwise %TRUE.
+ */
+static gboolean
+block_on_timeout (GSocket       *socket,
+                  GIOCondition   condition,
+                  gint64         timeout,
+                  gint64         start_time,
+                  GCancellable  *cancellable,
+                  GError       **error)
+{
+  gint64 wait_timeout = -1;
+
+  g_return_val_if_fail (timeout != 0, TRUE);
+
+  /* check if we've timed out or how much time to wait at most */
+  if (timeout >= 0)
+    {
+      gint64 elapsed = g_get_monotonic_time () - start_time;
+
+      if (elapsed >= timeout)
+        {
+          g_set_error_literal (error,
+                               G_IO_ERROR, G_IO_ERROR_TIMED_OUT,
+                               _("Socket I/O timed out"));
+          return FALSE;
+        }
+
+      wait_timeout = timeout - elapsed;
+    }
+
+  return g_socket_condition_timed_wait (socket, condition, wait_timeout,
+                                        cancellable, error);
+}
+
+static gssize
+g_socket_receive_with_timeout (GSocket       *socket,
+                               guint8        *buffer,
+                               gsize          size,
+                               gint64         timeout,
+                               GCancellable  *cancellable,
+                               GError       **error)
+{
+  gssize ret;
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket) && buffer != NULL, -1);
+
+  start_time = g_get_monotonic_time ();
+
+  if (!check_socket (socket, error))
+    return -1;
+
+  if (!check_timeout (socket, error))
+    return -1;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  while (1)
+    {
+      if ((ret = recv (socket->priv->fd, buffer, size, 0)) < 0)
+	{
+	  int errsv = get_socket_errno ();
+
+	  if (errsv == EINTR)
+	    continue;
+
+#ifdef WSAEWOULDBLOCK
+          if (errsv == WSAEWOULDBLOCK)
+#else
+          if (errsv == EWOULDBLOCK ||
+              errsv == EAGAIN)
+#endif
+            {
+              win32_unset_event_mask (socket, FD_READ);
+
+              if (timeout != 0)
+                {
+                  if (!block_on_timeout (socket, G_IO_IN, timeout, start_time,
+                                         cancellable, error))
+                    return -1;
+
+                  continue;
+                }
+            }
+
+	  win32_unset_event_mask (socket, FD_READ);
+
+	  socket_set_error_lazy (error, errsv, _("Error receiving data: %s"));
+	  return -1;
+	}
+
+      win32_unset_event_mask (socket, FD_READ);
+
+      break;
+    }
+
+  return ret;
+}
+
+/**
+ * g_socket_receive:
+ * @socket: a #GSocket
+ * @buffer: (array length=size) (element-type guint8): a buffer to
+ *     read data into (which should be at least @size bytes long).
+ * @size: the number of bytes you want to read from the socket
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Receive data (up to @size bytes) from a socket. This is mainly used by
+ * connection-oriented sockets; it is identical to g_socket_receive_from()
+ * with @address set to %NULL.
+ *
+ * For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
+ * g_socket_receive() will always read either 0 or 1 complete messages from
+ * the socket. If the received message is too large to fit in @buffer, then
+ * the data beyond @size bytes will be discarded, without any explicit
+ * indication that this has occurred.
+ *
+ * For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
+ * number of bytes, up to @size. If more than @size bytes have been
+ * received, the additional data will be returned in future calls to
+ * g_socket_receive().
+ *
+ * If the socket is in blocking mode the call will block until there
+ * is some data to receive, the connection is closed, or there is an
+ * error. If there is no data available and the socket is in
+ * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
+ * returned. To be notified when data is available, wait for the
+ * %G_IO_IN condition.
+ *
+ * On error -1 is returned and @error is set accordingly.
+ *
+ * Returns: Number of bytes read, or 0 if the connection was closed by
+ * the peer, or -1 on error
+ *
+ * Since: 2.22
+ */
+gssize
+g_socket_receive (GSocket       *socket,
+		  gchar         *buffer,
+		  gsize          size,
+		  GCancellable  *cancellable,
+		  GError       **error)
+{
+  return g_socket_receive_with_timeout (socket, (guint8 *) buffer, size,
+                                        socket->priv->blocking ? -1 : 0,
+                                        cancellable, error);
+}
+
+/**
+ * g_socket_receive_with_blocking:
+ * @socket: a #GSocket
+ * @buffer: (array length=size) (element-type guint8): a buffer to
+ *     read data into (which should be at least @size bytes long).
+ * @size: the number of bytes you want to read from the socket
+ * @blocking: whether to do blocking or non-blocking I/O
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * This behaves exactly the same as g_socket_receive(), except that
+ * the choice of blocking or non-blocking behavior is determined by
+ * the @blocking argument rather than by @socket's properties.
+ *
+ * Returns: Number of bytes read, or 0 if the connection was closed by
+ * the peer, or -1 on error
+ *
+ * Since: 2.26
+ */
+gssize
+g_socket_receive_with_blocking (GSocket       *socket,
+				gchar         *buffer,
+				gsize          size,
+				gboolean       blocking,
+				GCancellable  *cancellable,
+				GError       **error)
+{
+  return g_socket_receive_with_timeout (socket, (guint8 *) buffer, size,
+                                        blocking ? -1 : 0, cancellable, error);
+}
+
+/**
+ * g_socket_receive_from:
+ * @socket: a #GSocket
+ * @address: (out) (allow-none): a pointer to a #GSocketAddress
+ *     pointer, or %NULL
+ * @buffer: (array length=size) (element-type guint8): a buffer to
+ *     read data into (which should be at least @size bytes long).
+ * @size: the number of bytes you want to read from the socket
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Receive data (up to @size bytes) from a socket.
+ *
+ * If @address is non-%NULL then @address will be set equal to the
+ * source address of the received packet.
+ * @address is owned by the caller.
+ *
+ * See g_socket_receive() for additional information.
+ *
+ * Returns: Number of bytes read, or 0 if the connection was closed by
+ * the peer, or -1 on error
+ *
+ * Since: 2.22
+ */
+gssize
+g_socket_receive_from (GSocket         *socket,
+		       GSocketAddress **address,
+		       gchar           *buffer,
+		       gsize            size,
+		       GCancellable    *cancellable,
+		       GError         **error)
+{
+  GInputVector v;
+
+  v.buffer = buffer;
+  v.size = size;
+
+  return g_socket_receive_message (socket,
+				   address,
+				   &v, 1,
+				   NULL, 0, NULL,
+				   cancellable,
+				   error);
+}
+
+/* See the comment about SIGPIPE above. */
+#ifdef MSG_NOSIGNAL
+#define G_SOCKET_DEFAULT_SEND_FLAGS MSG_NOSIGNAL
+#else
+#define G_SOCKET_DEFAULT_SEND_FLAGS 0
+#endif
+
+static gssize
+g_socket_send_with_timeout (GSocket       *socket,
+                            const guint8  *buffer,
+                            gsize          size,
+                            gint64         timeout,
+                            GCancellable  *cancellable,
+                            GError       **error)
+{
+  gssize ret;
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket) && buffer != NULL, -1);
+
+  start_time = g_get_monotonic_time ();
+
+  if (!check_socket (socket, error))
+    return -1;
+
+  if (!check_timeout (socket, error))
+    return -1;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  while (1)
+    {
+      if ((ret = send (socket->priv->fd, buffer, size, G_SOCKET_DEFAULT_SEND_FLAGS)) < 0)
+	{
+	  int errsv = get_socket_errno ();
+
+	  if (errsv == EINTR)
+	    continue;
+
+#ifdef WSAEWOULDBLOCK
+          if (errsv == WSAEWOULDBLOCK)
+#else
+          if (errsv == EWOULDBLOCK ||
+              errsv == EAGAIN)
+#endif
+            {
+              win32_unset_event_mask (socket, FD_WRITE);
+
+              if (timeout != 0)
+                {
+                  if (!block_on_timeout (socket, G_IO_OUT, timeout, start_time,
+                                         cancellable, error))
+                    return -1;
+
+                  continue;
+                }
+            }
+
+	  socket_set_error_lazy (error, errsv, _("Error sending data: %s"));
+	  return -1;
+	}
+      break;
+    }
+
+  return ret;
+}
+
+/**
+ * g_socket_send:
+ * @socket: a #GSocket
+ * @buffer: (array length=size) (element-type guint8): the buffer
+ *     containing the data to send.
+ * @size: the number of bytes to send
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Tries to send @size bytes from @buffer on the socket. This is
+ * mainly used by connection-oriented sockets; it is identical to
+ * g_socket_send_to() with @address set to %NULL.
+ *
+ * If the socket is in blocking mode the call will block until there is
+ * space for the data in the socket queue. If there is no space available
+ * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
+ * will be returned. To be notified when space is available, wait for the
+ * %G_IO_OUT condition. Note though that you may still receive
+ * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
+ * notified of a %G_IO_OUT condition. (On Windows in particular, this is
+ * very common due to the way the underlying APIs work.)
+ *
+ * On error -1 is returned and @error is set accordingly.
+ *
+ * Returns: Number of bytes written (which may be less than @size), or -1
+ * on error
+ *
+ * Since: 2.22
+ */
+gssize
+g_socket_send (GSocket       *socket,
+	       const gchar   *buffer,
+	       gsize          size,
+	       GCancellable  *cancellable,
+	       GError       **error)
+{
+  return g_socket_send_with_blocking (socket, buffer, size,
+				      socket->priv->blocking,
+				      cancellable, error);
+}
+
+/**
+ * g_socket_send_with_blocking:
+ * @socket: a #GSocket
+ * @buffer: (array length=size) (element-type guint8): the buffer
+ *     containing the data to send.
+ * @size: the number of bytes to send
+ * @blocking: whether to do blocking or non-blocking I/O
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * This behaves exactly the same as g_socket_send(), except that
+ * the choice of blocking or non-blocking behavior is determined by
+ * the @blocking argument rather than by @socket's properties.
+ *
+ * Returns: Number of bytes written (which may be less than @size), or -1
+ * on error
+ *
+ * Since: 2.26
+ */
+gssize
+g_socket_send_with_blocking (GSocket       *socket,
+			     const gchar   *buffer,
+			     gsize          size,
+			     gboolean       blocking,
+			     GCancellable  *cancellable,
+			     GError       **error)
+{
+  return g_socket_send_with_timeout (socket, (const guint8 *) buffer, size,
+                                     blocking ? -1 : 0, cancellable, error);
+}
+
+/**
+ * g_socket_send_to:
+ * @socket: a #GSocket
+ * @address: (allow-none): a #GSocketAddress, or %NULL
+ * @buffer: (array length=size) (element-type guint8): the buffer
+ *     containing the data to send.
+ * @size: the number of bytes to send
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Tries to send @size bytes from @buffer to @address. If @address is
+ * %NULL then the message is sent to the default receiver (set by
+ * g_socket_connect()).
+ *
+ * See g_socket_send() for additional information.
+ *
+ * Returns: Number of bytes written (which may be less than @size), or -1
+ * on error
+ *
+ * Since: 2.22
+ */
+gssize
+g_socket_send_to (GSocket         *socket,
+		  GSocketAddress  *address,
+		  const gchar     *buffer,
+		  gsize            size,
+		  GCancellable    *cancellable,
+		  GError         **error)
+{
+  GOutputVector v;
+
+  v.buffer = buffer;
+  v.size = size;
+
+  return g_socket_send_message (socket,
+				address,
+				&v, 1,
+				NULL, 0,
+				0,
+				cancellable,
+				error);
+}
+
+/**
+ * g_socket_shutdown:
+ * @socket: a #GSocket
+ * @shutdown_read: whether to shut down the read side
+ * @shutdown_write: whether to shut down the write side
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Shut down part or all of a full-duplex connection.
+ *
+ * If @shutdown_read is %TRUE then the receiving side of the connection
+ * is shut down, and further reading is disallowed.
+ *
+ * If @shutdown_write is %TRUE then the sending side of the connection
+ * is shut down, and further writing is disallowed.
+ *
+ * It is allowed for both @shutdown_read and @shutdown_write to be %TRUE.
+ *
+ * One example where it is useful to shut down only one side of a connection is
+ * graceful disconnect for TCP connections where you close the sending side,
+ * then wait for the other side to close the connection, thus ensuring that the
+ * other side saw all sent data.
+ *
+ * Returns: %TRUE on success, %FALSE on error
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_shutdown (GSocket   *socket,
+		   gboolean   shutdown_read,
+		   gboolean   shutdown_write,
+		   GError   **error)
+{
+  int how;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), TRUE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  /* Do nothing? */
+  if (!shutdown_read && !shutdown_write)
+    return TRUE;
+
+#ifndef G_OS_WIN32
+  if (shutdown_read && shutdown_write)
+    how = SHUT_RDWR;
+  else if (shutdown_read)
+    how = SHUT_RD;
+  else
+    how = SHUT_WR;
+#else
+  if (shutdown_read && shutdown_write)
+    how = SD_BOTH;
+  else if (shutdown_read)
+    how = SD_RECEIVE;
+  else
+    how = SD_SEND;
+#endif
+
+  if (shutdown (socket->priv->fd, how) != 0)
+    {
+      int errsv = get_socket_errno ();
+      g_set_error (error, G_IO_ERROR, socket_io_error_from_errno (errsv),
+		   _("Unable to shutdown socket: %s"), socket_strerror (errsv));
+      return FALSE;
+    }
+
+  if (shutdown_read)
+    socket->priv->connected_read = FALSE;
+  if (shutdown_write)
+    socket->priv->connected_write = FALSE;
+
+  return TRUE;
+}
+
+/**
+ * g_socket_close:
+ * @socket: a #GSocket
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Closes the socket, shutting down any active connection.
+ *
+ * Closing a socket does not wait for all outstanding I/O operations
+ * to finish, so the caller should not rely on them to be guaranteed
+ * to complete even if the close returns with no error.
+ *
+ * Once the socket is closed, all other operations will return
+ * %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
+ * return an error.
+ *
+ * Sockets will be automatically closed when the last reference
+ * is dropped, but you might want to call this function to make sure
+ * resources are released as early as possible.
+ *
+ * Beware that due to the way that TCP works, it is possible for
+ * recently-sent data to be lost if either you close a socket while the
+ * %G_IO_IN condition is set, or else if the remote connection tries to
+ * send something to you after you close the socket but before it has
+ * finished reading all of the data you sent. There is no easy generic
+ * way to avoid this problem; the easiest fix is to design the network
+ * protocol such that the client will never send data "out of turn".
+ * Another solution is for the server to half-close the connection by
+ * calling g_socket_shutdown() with only the @shutdown_write flag set,
+ * and then wait for the client to notice this and close its side of the
+ * connection, after which the server can safely call g_socket_close().
+ * (This is what #GTcpConnection does if you call
+ * g_tcp_connection_set_graceful_disconnect(). But of course, this
+ * only works if the client will close its connection after the server
+ * does.)
+ *
+ * Returns: %TRUE on success, %FALSE on error
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_close (GSocket  *socket,
+		GError  **error)
+{
+  int res;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), TRUE);
+
+  if (socket->priv->closed)
+    return TRUE; /* Multiple close not an error */
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  while (1)
+    {
+#ifdef G_OS_WIN32
+      res = closesocket (socket->priv->fd);
+#else
+      res = close (socket->priv->fd);
+#endif
+      if (res == -1)
+	{
+	  int errsv = get_socket_errno ();
+
+	  if (errsv == EINTR)
+	    continue;
+
+	  g_set_error (error, G_IO_ERROR,
+		       socket_io_error_from_errno (errsv),
+		       _("Error closing socket: %s"),
+		       socket_strerror (errsv));
+	  return FALSE;
+	}
+      break;
+    }
+
+  socket->priv->fd = -1;
+  socket->priv->connected_read = FALSE;
+  socket->priv->connected_write = FALSE;
+  socket->priv->closed = TRUE;
+  if (socket->priv->remote_address)
+    {
+      g_object_unref (socket->priv->remote_address);
+      socket->priv->remote_address = NULL;
+    }
+
+  return TRUE;
+}
+
+/**
+ * g_socket_is_closed:
+ * @socket: a #GSocket
+ *
+ * Checks whether a socket is closed.
+ *
+ * Returns: %TRUE if socket is closed, %FALSE otherwise
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_is_closed (GSocket *socket)
+{
+  return socket->priv->closed;
+}
+
+#ifdef G_OS_WIN32
+/* Broken source, used on errors */
+static gboolean
+broken_dispatch (GSource     *source,
+		 GSourceFunc  callback,
+		 gpointer     user_data)
+{
+  return TRUE;
+}
+
+static GSourceFuncs broken_funcs =
+{
+  NULL,
+  NULL,
+  broken_dispatch,
+  NULL
+};
+
+static gint
+network_events_for_condition (GIOCondition condition)
+{
+  int event_mask = 0;
+
+  if (condition & G_IO_IN)
+    event_mask |= (FD_READ | FD_ACCEPT);
+  if (condition & G_IO_OUT)
+    event_mask |= (FD_WRITE | FD_CONNECT);
+  event_mask |= FD_CLOSE;
+
+  return event_mask;
+}
+
+static void
+ensure_event (GSocket *socket)
+{
+  if (socket->priv->event == WSA_INVALID_EVENT)
+    socket->priv->event = WSACreateEvent();
+}
+
+static void
+update_select_events (GSocket *socket)
+{
+  int event_mask;
+  GIOCondition *ptr;
+  GList *l;
+  WSAEVENT event;
+
+  ensure_event (socket);
+
+  event_mask = 0;
+  for (l = socket->priv->requested_conditions; l != NULL; l = l->next)
+    {
+      ptr = l->data;
+      event_mask |= network_events_for_condition (*ptr);
+    }
+
+  if (event_mask != socket->priv->selected_events)
+    {
+      /* If no events selected, disable event so we can unset
+	 nonblocking mode */
+
+      if (event_mask == 0)
+	event = NULL;
+      else
+	event = socket->priv->event;
+
+      if (WSAEventSelect (socket->priv->fd, event, event_mask) == 0)
+	socket->priv->selected_events = event_mask;
+    }
+}
+
+static void
+add_condition_watch (GSocket      *socket,
+		     GIOCondition *condition)
+{
+  g_mutex_lock (&socket->priv->win32_source_lock);
+  g_assert (g_list_find (socket->priv->requested_conditions, condition) == NULL);
+
+  socket->priv->requested_conditions =
+    g_list_prepend (socket->priv->requested_conditions, condition);
+
+  update_select_events (socket);
+  g_mutex_unlock (&socket->priv->win32_source_lock);
+}
+
+static void
+remove_condition_watch (GSocket      *socket,
+			GIOCondition *condition)
+{
+  g_mutex_lock (&socket->priv->win32_source_lock);
+  g_assert (g_list_find (socket->priv->requested_conditions, condition) != NULL);
+
+  socket->priv->requested_conditions =
+    g_list_remove (socket->priv->requested_conditions, condition);
+
+  update_select_events (socket);
+  g_mutex_unlock (&socket->priv->win32_source_lock);
+}
+
+static GIOCondition
+update_condition (GSocket *socket)
+{
+  WSANETWORKEVENTS events;
+  GIOCondition condition;
+
+  if (WSAEnumNetworkEvents (socket->priv->fd,
+			    socket->priv->event,
+			    &events) == 0)
+    {
+      socket->priv->current_events |= events.lNetworkEvents;
+      if (events.lNetworkEvents & FD_WRITE &&
+	  events.iErrorCode[FD_WRITE_BIT] != 0)
+	socket->priv->current_errors |= FD_WRITE;
+      if (events.lNetworkEvents & FD_CONNECT &&
+	  events.iErrorCode[FD_CONNECT_BIT] != 0)
+	socket->priv->current_errors |= FD_CONNECT;
+    }
+
+  condition = 0;
+  if (socket->priv->current_events & (FD_READ | FD_ACCEPT))
+    condition |= G_IO_IN;
+
+  if (socket->priv->current_events & FD_CLOSE)
+    {
+      int r, errsv, buffer;
+
+      r = recv (socket->priv->fd, &buffer, sizeof (buffer), MSG_PEEK);
+      if (r < 0)
+          errsv = get_socket_errno ();
+
+      if (r > 0 ||
+          (r < 0 && errsv == WSAENOTCONN))
+        condition |= G_IO_IN;
+      else if (r == 0 ||
+               (r < 0 && (errsv == WSAESHUTDOWN || errsv == WSAECONNRESET ||
+                          errsv == WSAECONNABORTED || errsv == WSAENETRESET)))
+        condition |= G_IO_HUP;
+      else
+        condition |= G_IO_ERR;
+    }
+
+  if (socket->priv->closed)
+    condition |= G_IO_HUP;
+
+  /* Never report both G_IO_OUT and HUP, these are
+     mutually exclusive (can't write to a closed socket) */
+  if ((condition & G_IO_HUP) == 0 &&
+      socket->priv->current_events & FD_WRITE)
+    {
+      if (socket->priv->current_errors & FD_WRITE)
+	condition |= G_IO_ERR;
+      else
+	condition |= G_IO_OUT;
+    }
+  else
+    {
+      if (socket->priv->current_events & FD_CONNECT)
+	{
+	  if (socket->priv->current_errors & FD_CONNECT)
+	    condition |= (G_IO_HUP | G_IO_ERR);
+	  else
+	    condition |= G_IO_OUT;
+	}
+    }
+
+  return condition;
+}
+#endif
+
+typedef struct {
+  GSource       source;
+#ifdef G_OS_WIN32
+  GPollFD       pollfd;
+#else
+  gpointer      fd_tag;
+#endif
+  GSocket      *socket;
+  GIOCondition  condition;
+} GSocketSource;
+
+#ifdef G_OS_WIN32
+static gboolean
+socket_source_prepare_win32 (GSource *source,
+                             gint    *timeout)
+{
+  GSocketSource *socket_source = (GSocketSource *)source;
+
+  *timeout = -1;
+
+  return (update_condition (socket_source->socket) & socket_source->condition) != 0;
+}
+
+static gboolean
+socket_source_check_win32 (GSource *source)
+{
+  int timeout;
+
+  return socket_source_prepare_win32 (source, &timeout);
+}
+#endif
+
+static gboolean
+socket_source_dispatch (GSource     *source,
+			GSourceFunc  callback,
+			gpointer     user_data)
+{
+  GSocketSourceFunc func = (GSocketSourceFunc)callback;
+  GSocketSource *socket_source = (GSocketSource *)source;
+  GSocket *socket = socket_source->socket;
+  gint64 timeout;
+  guint events;
+  gboolean ret;
+
+#ifdef G_OS_WIN32
+  events = update_condition (socket_source->socket);
+#else
+  events = g_source_query_unix_fd (source, socket_source->fd_tag);
+#endif
+
+  timeout = g_source_get_ready_time (source);
+  if (timeout >= 0 && timeout < g_source_get_time (source))
+    {
+      socket->priv->timed_out = TRUE;
+      events |= (G_IO_IN | G_IO_OUT);
+    }
+
+  ret = (*func) (socket, events & socket_source->condition, user_data);
+
+  if (socket->priv->timeout)
+    g_source_set_ready_time (source, g_get_monotonic_time () + socket->priv->timeout * 1000000);
+  else
+    g_source_set_ready_time (source, -1);
+
+  return ret;
+}
+
+static void
+socket_source_finalize (GSource *source)
+{
+  GSocketSource *socket_source = (GSocketSource *)source;
+  GSocket *socket;
+
+  socket = socket_source->socket;
+
+#ifdef G_OS_WIN32
+  remove_condition_watch (socket, &socket_source->condition);
+#endif
+
+  g_object_unref (socket);
+}
+
+static gboolean
+socket_source_closure_callback (GSocket      *socket,
+				GIOCondition  condition,
+				gpointer      data)
+{
+  GClosure *closure = data;
+
+  GValue params[2] = { G_VALUE_INIT, G_VALUE_INIT };
+  GValue result_value = G_VALUE_INIT;
+  gboolean result;
+
+  g_value_init (&result_value, G_TYPE_BOOLEAN);
+
+  g_value_init (&params[0], G_TYPE_SOCKET);
+  g_value_set_object (&params[0], socket);
+  g_value_init (&params[1], G_TYPE_IO_CONDITION);
+  g_value_set_flags (&params[1], condition);
+
+  g_closure_invoke (closure, &result_value, 2, params, NULL);
+
+  result = g_value_get_boolean (&result_value);
+  g_value_unset (&result_value);
+  g_value_unset (&params[0]);
+  g_value_unset (&params[1]);
+
+  return result;
+}
+
+static GSourceFuncs socket_source_funcs =
+{
+#ifdef G_OS_WIN32
+  socket_source_prepare_win32,
+  socket_source_check_win32,
+#else
+  NULL, NULL, /* check, prepare */
+#endif
+  socket_source_dispatch,
+  socket_source_finalize,
+  (GSourceFunc)socket_source_closure_callback,
+};
+
+static GSource *
+socket_source_new (GSocket      *socket,
+		   GIOCondition  condition,
+		   GCancellable *cancellable)
+{
+  GSource *source;
+  GSocketSource *socket_source;
+
+#ifdef G_OS_WIN32
+  ensure_event (socket);
+
+  if (socket->priv->event == WSA_INVALID_EVENT)
+    {
+      g_warning ("Failed to create WSAEvent");
+      return g_source_new (&broken_funcs, sizeof (GSource));
+    }
+#endif
+
+  condition |= G_IO_HUP | G_IO_ERR | G_IO_NVAL;
+
+  source = g_source_new (&socket_source_funcs, sizeof (GSocketSource));
+  g_source_set_name (source, "GSocket");
+  socket_source = (GSocketSource *)source;
+
+  socket_source->socket = g_object_ref (socket);
+  socket_source->condition = condition;
+
+  if (cancellable)
+    {
+      GSource *cancellable_source;
+
+      cancellable_source = g_cancellable_source_new (cancellable);
+      g_source_add_child_source (source, cancellable_source);
+      g_source_set_dummy_callback (cancellable_source);
+      g_source_unref (cancellable_source);
+    }
+
+#ifdef G_OS_WIN32
+  add_condition_watch (socket, &socket_source->condition);
+  socket_source->pollfd.fd = (gintptr) socket->priv->event;
+  socket_source->pollfd.events = condition;
+  socket_source->pollfd.revents = 0;
+  g_source_add_poll (source, &socket_source->pollfd);
+#else
+  socket_source->fd_tag = g_source_add_unix_fd (source, socket->priv->fd, condition);
+#endif
+
+  if (socket->priv->timeout)
+    g_source_set_ready_time (source, g_get_monotonic_time () + socket->priv->timeout * 1000000);
+  else
+    g_source_set_ready_time (source, -1);
+
+  return source;
+}
+
+/**
+ * g_socket_create_source: (skip)
+ * @socket: a #GSocket
+ * @condition: a #GIOCondition mask to monitor
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ *
+ * Creates a #GSource that can be attached to a %GMainContext to monitor
+ * for the availability of the specified @condition on the socket. The #GSource
+ * keeps a reference to the @socket.
+ *
+ * The callback on the source is of the #GSocketSourceFunc type.
+ *
+ * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition;
+ * these conditions will always be reported output if they are true.
+ *
+ * @cancellable if not %NULL can be used to cancel the source, which will
+ * cause the source to trigger, reporting the current condition (which
+ * is likely 0 unless cancellation happened at the same time as a
+ * condition change). You can check for this in the callback using
+ * g_cancellable_is_cancelled().
+ *
+ * If @socket has a timeout set, and it is reached before @condition
+ * occurs, the source will then trigger anyway, reporting %G_IO_IN or
+ * %G_IO_OUT depending on @condition. However, @socket will have been
+ * marked as having had a timeout, and so the next #GSocket I/O method
+ * you call will then fail with a %G_IO_ERROR_TIMED_OUT.
+ *
+ * Returns: (transfer full): a newly allocated %GSource, free with g_source_unref().
+ *
+ * Since: 2.22
+ */
+GSource *
+g_socket_create_source (GSocket      *socket,
+			GIOCondition  condition,
+			GCancellable *cancellable)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket) && (cancellable == NULL || G_IS_CANCELLABLE (cancellable)), NULL);
+
+  return socket_source_new (socket, condition, cancellable);
+}
+
+/**
+ * g_socket_condition_check:
+ * @socket: a #GSocket
+ * @condition: a #GIOCondition mask to check
+ *
+ * Checks on the readiness of @socket to perform operations.
+ * The operations specified in @condition are checked for and masked
+ * against the currently-satisfied conditions on @socket. The result
+ * is returned.
+ *
+ * Note that on Windows, it is possible for an operation to return
+ * %G_IO_ERROR_WOULD_BLOCK even immediately after
+ * g_socket_condition_check() has claimed that the socket is ready for
+ * writing. Rather than calling g_socket_condition_check() and then
+ * writing to the socket if it succeeds, it is generally better to
+ * simply try writing to the socket right away, and try again later if
+ * the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
+ *
+ * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
+ * these conditions will always be set in the output if they are true.
+ *
+ * This call never blocks.
+ *
+ * Returns: the @GIOCondition mask of the current state
+ *
+ * Since: 2.22
+ */
+GIOCondition
+g_socket_condition_check (GSocket      *socket,
+			  GIOCondition  condition)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), 0);
+
+  if (!check_socket (socket, NULL))
+    return 0;
+
+#ifdef G_OS_WIN32
+  {
+    GIOCondition current_condition;
+
+    condition |= G_IO_ERR | G_IO_HUP;
+
+    add_condition_watch (socket, &condition);
+    current_condition = update_condition (socket);
+    remove_condition_watch (socket, &condition);
+    return condition & current_condition;
+  }
+#else
+  {
+    GPollFD poll_fd;
+    gint result;
+    poll_fd.fd = socket->priv->fd;
+    poll_fd.events = condition;
+    poll_fd.revents = 0;
+
+    do
+      result = g_poll (&poll_fd, 1, 0);
+    while (result == -1 && get_socket_errno () == EINTR);
+
+    return poll_fd.revents;
+  }
+#endif
+}
+
+/**
+ * g_socket_condition_wait:
+ * @socket: a #GSocket
+ * @condition: a #GIOCondition mask to wait for
+ * @cancellable: (allow-none): a #GCancellable, or %NULL
+ * @error: a #GError pointer, or %NULL
+ *
+ * Waits for @condition to become true on @socket. When the condition
+ * is met, %TRUE is returned.
+ *
+ * If @cancellable is cancelled before the condition is met, or if the
+ * socket has a timeout set and it is reached before the condition is
+ * met, then %FALSE is returned and @error, if non-%NULL, is set to
+ * the appropriate value (%G_IO_ERROR_CANCELLED or
+ * %G_IO_ERROR_TIMED_OUT).
+ *
+ * See also g_socket_condition_timed_wait().
+ *
+ * Returns: %TRUE if the condition was met, %FALSE otherwise
+ *
+ * Since: 2.22
+ */
+gboolean
+g_socket_condition_wait (GSocket       *socket,
+			 GIOCondition   condition,
+			 GCancellable  *cancellable,
+			 GError       **error)
+{
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  return g_socket_condition_timed_wait (socket, condition, -1,
+					cancellable, error);
+}
+
+/**
+ * g_socket_condition_timed_wait:
+ * @socket: a #GSocket
+ * @condition: a #GIOCondition mask to wait for
+ * @timeout: the maximum time (in microseconds) to wait, or -1
+ * @cancellable: (allow-none): a #GCancellable, or %NULL
+ * @error: a #GError pointer, or %NULL
+ *
+ * Waits for up to @timeout microseconds for @condition to become true
+ * on @socket. If the condition is met, %TRUE is returned.
+ *
+ * If @cancellable is cancelled before the condition is met, or if
+ * @timeout (or the socket's #GSocket:timeout) is reached before the
+ * condition is met, then %FALSE is returned and @error, if non-%NULL,
+ * is set to the appropriate value (%G_IO_ERROR_CANCELLED or
+ * %G_IO_ERROR_TIMED_OUT).
+ *
+ * If you don't want a timeout, use g_socket_condition_wait().
+ * (Alternatively, you can pass -1 for @timeout.)
+ *
+ * Note that although @timeout is in microseconds for consistency with
+ * other GLib APIs, this function actually only has millisecond
+ * resolution, and the behavior is undefined if @timeout is not an
+ * exact number of milliseconds.
+ *
+ * Returns: %TRUE if the condition was met, %FALSE otherwise
+ *
+ * Since: 2.32
+ */
+gboolean
+g_socket_condition_timed_wait (GSocket       *socket,
+			       GIOCondition   condition,
+			       gint64         timeout,
+			       GCancellable  *cancellable,
+			       GError       **error)
+{
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  if (!check_socket (socket, error))
+    return FALSE;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return FALSE;
+
+  if (socket->priv->timeout &&
+      (timeout < 0 || socket->priv->timeout < timeout / G_USEC_PER_SEC))
+    timeout = socket->priv->timeout * 1000;
+  else if (timeout != -1)
+    timeout = timeout / 1000;
+
+  start_time = g_get_monotonic_time ();
+
+#ifdef G_OS_WIN32
+  {
+    GIOCondition current_condition;
+    WSAEVENT events[2];
+    DWORD res;
+    GPollFD cancel_fd;
+    int num_events;
+
+    /* Always check these */
+    condition |=  G_IO_ERR | G_IO_HUP;
+
+    add_condition_watch (socket, &condition);
+
+    num_events = 0;
+    events[num_events++] = socket->priv->event;
+
+    if (g_cancellable_make_pollfd (cancellable, &cancel_fd))
+      events[num_events++] = (WSAEVENT)cancel_fd.fd;
+
+    if (timeout == -1)
+      timeout = WSA_INFINITE;
+
+    current_condition = update_condition (socket);
+    while ((condition & current_condition) == 0)
+      {
+	res = WSAWaitForMultipleEvents (num_events, events,
+					FALSE, timeout, FALSE);
+	if (res == WSA_WAIT_FAILED)
+	  {
+	    int errsv = get_socket_errno ();
+
+	    g_set_error (error, G_IO_ERROR,
+			 socket_io_error_from_errno (errsv),
+			 _("Waiting for socket condition: %s"),
+			 socket_strerror (errsv));
+	    break;
+	  }
+	else if (res == WSA_WAIT_TIMEOUT)
+	  {
+	    g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_TIMED_OUT,
+				 _("Socket I/O timed out"));
+	    break;
+	  }
+
+	if (g_cancellable_set_error_if_cancelled (cancellable, error))
+	  break;
+
+	current_condition = update_condition (socket);
+
+	if (timeout != WSA_INFINITE)
+	  {
+	    timeout -= (g_get_monotonic_time () - start_time) * 1000;
+	    if (timeout < 0)
+	      timeout = 0;
+	  }
+      }
+    remove_condition_watch (socket, &condition);
+    if (num_events > 1)
+      g_cancellable_release_fd (cancellable);
+
+    return (condition & current_condition) != 0;
+  }
+#else
+  {
+    GPollFD poll_fd[2];
+    gint result;
+    gint num;
+
+    poll_fd[0].fd = socket->priv->fd;
+    poll_fd[0].events = condition;
+    num = 1;
+
+    if (g_cancellable_make_pollfd (cancellable, &poll_fd[1]))
+      num++;
+
+    while (TRUE)
+      {
+	result = g_poll (poll_fd, num, timeout);
+	if (result != -1 || errno != EINTR)
+	  break;
+
+	if (timeout != -1)
+	  {
+	    timeout -= (g_get_monotonic_time () - start_time) / 1000;
+	    if (timeout < 0)
+	      timeout = 0;
+	  }
+      }
+    
+    if (num > 1)
+      g_cancellable_release_fd (cancellable);
+
+    if (result == 0)
+      {
+	g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_TIMED_OUT,
+			     _("Socket I/O timed out"));
+	return FALSE;
+      }
+
+    return !g_cancellable_set_error_if_cancelled (cancellable, error);
+  }
+  #endif
+}
+
+#ifndef G_OS_WIN32
+
+/* Unfortunately these have to be macros rather than inline functions due to
+ * using alloca(). */
+#define output_message_to_msghdr(message, prev_message, msg, prev_msg, error) \
+G_STMT_START { \
+  const GOutputMessage  *_message = (message); \
+  const GOutputMessage *_prev_message = (prev_message); \
+  struct msghdr *_msg = (msg); \
+  const struct msghdr *_prev_msg = (prev_msg); \
+  GError **_error = (error); \
+ \
+  _msg->msg_flags = 0; \
+ \
+  /* name */ \
+  if (_prev_message != NULL && _prev_message->address == _message->address) \
+    { \
+      _msg->msg_name = _prev_msg->msg_name; \
+      _msg->msg_namelen = _prev_msg->msg_namelen; \
+    } \
+  else if (_message->address != NULL) \
+    { \
+      _msg->msg_namelen = g_socket_address_get_native_size (_message->address); \
+      _msg->msg_name = g_alloca (_msg->msg_namelen); \
+      if (!g_socket_address_to_native (_message->address, _msg->msg_name, \
+                                       _msg->msg_namelen, _error)) \
+        break; \
+    } \
+  else \
+    { \
+      _msg->msg_name = NULL; \
+      _msg->msg_namelen = 0; \
+    } \
+ \
+  /* iov */ \
+  { \
+    /* this entire expression will be evaluated at compile time */ \
+    if (sizeof *_msg->msg_iov == sizeof *_message->vectors && \
+        sizeof _msg->msg_iov->iov_base == sizeof _message->vectors->buffer && \
+        G_STRUCT_OFFSET (struct iovec, iov_base) == \
+        G_STRUCT_OFFSET (GOutputVector, buffer) && \
+        sizeof _msg->msg_iov->iov_len == sizeof _message->vectors->size && \
+        G_STRUCT_OFFSET (struct iovec, iov_len) == \
+        G_STRUCT_OFFSET (GOutputVector, size)) \
+      /* ABI is compatible */ \
+      { \
+        _msg->msg_iov = (struct iovec *) _message->vectors; \
+        _msg->msg_iovlen = _message->num_vectors; \
+      } \
+    else \
+      /* ABI is incompatible */ \
+      { \
+        gint i; \
+ \
+        _msg->msg_iov = g_newa (struct iovec, _message->num_vectors); \
+        for (i = 0; i < _message->num_vectors; i++) \
+          { \
+            _msg->msg_iov[i].iov_base = (void *) _message->vectors[i].buffer; \
+            _msg->msg_iov[i].iov_len = _message->vectors[i].size; \
+          } \
+        _msg->msg_iovlen = _message->num_vectors; \
+      } \
+  } \
+ \
+  /* control */ \
+  { \
+    struct cmsghdr *cmsg; \
+    gint i; \
+ \
+    _msg->msg_controllen = 0; \
+    for (i = 0; i < _message->num_control_messages; i++) \
+      _msg->msg_controllen += CMSG_SPACE (g_socket_control_message_get_size (_message->control_messages[i])); \
+ \
+    if (_msg->msg_controllen == 0) \
+      _msg->msg_control = NULL; \
+    else \
+      { \
+        _msg->msg_control = g_alloca (_msg->msg_controllen); \
+        memset (_msg->msg_control, '\0', _msg->msg_controllen); \
+      } \
+ \
+    cmsg = CMSG_FIRSTHDR (_msg); \
+    for (i = 0; i < _message->num_control_messages; i++) \
+      { \
+        cmsg->cmsg_level = g_socket_control_message_get_level (_message->control_messages[i]); \
+        cmsg->cmsg_type = g_socket_control_message_get_msg_type (_message->control_messages[i]); \
+        cmsg->cmsg_len = CMSG_LEN (g_socket_control_message_get_size (_message->control_messages[i])); \
+        g_socket_control_message_serialize (_message->control_messages[i], \
+                                            CMSG_DATA (cmsg)); \
+        cmsg = CMSG_NXTHDR (_msg, cmsg); \
+      } \
+    g_assert (cmsg == NULL); \
+  } \
+} G_STMT_END
+
+#define input_message_to_msghdr(message, msg) \
+G_STMT_START { \
+  const GInputMessage  *_message = (message); \
+  struct msghdr *_msg = (msg); \
+ \
+  /* name */ \
+  if (_message->address) \
+    { \
+      _msg->msg_namelen = sizeof (struct sockaddr_storage); \
+      _msg->msg_name = g_alloca (_msg->msg_namelen); \
+    } \
+  else \
+    { \
+      _msg->msg_name = NULL; \
+      _msg->msg_namelen = 0; \
+    } \
+ \
+  /* iov */ \
+  /* this entire expression will be evaluated at compile time */ \
+  if (sizeof *_msg->msg_iov == sizeof *_message->vectors && \
+      sizeof _msg->msg_iov->iov_base == sizeof _message->vectors->buffer && \
+      G_STRUCT_OFFSET (struct iovec, iov_base) == \
+      G_STRUCT_OFFSET (GInputVector, buffer) && \
+      sizeof _msg->msg_iov->iov_len == sizeof _message->vectors->size && \
+      G_STRUCT_OFFSET (struct iovec, iov_len) == \
+      G_STRUCT_OFFSET (GInputVector, size)) \
+    /* ABI is compatible */ \
+    { \
+      _msg->msg_iov = (struct iovec *) _message->vectors; \
+      _msg->msg_iovlen = _message->num_vectors; \
+    } \
+  else \
+    /* ABI is incompatible */ \
+    { \
+      guint i; \
+ \
+      _msg->msg_iov = g_newa (struct iovec, _message->num_vectors); \
+      for (i = 0; i < _message->num_vectors; i++) \
+        { \
+          _msg->msg_iov[i].iov_base = _message->vectors[i].buffer; \
+          _msg->msg_iov[i].iov_len = _message->vectors[i].size; \
+        } \
+      _msg->msg_iovlen = _message->num_vectors; \
+    } \
+ \
+  /* control */ \
+  _msg->msg_controllen = 2048; \
+  _msg->msg_control = g_alloca (_msg->msg_controllen); \
+ \
+  /* flags */ \
+  _msg->msg_flags = _message->flags; \
+} G_STMT_END
+
+static void
+input_message_from_msghdr (const struct msghdr  *msg,
+                           GInputMessage        *message,
+                           GSocket              *socket)
+{
+  /* decode address */
+  if (message->address != NULL)
+    {
+      *message->address = cache_recv_address (socket, msg->msg_name,
+                                              msg->msg_namelen);
+    }
+
+  /* decode control messages */
+  {
+    GPtrArray *my_messages = NULL;
+    struct cmsghdr *cmsg;
+
+    if (msg->msg_controllen >= sizeof (struct cmsghdr))
+      {
+        for (cmsg = CMSG_FIRSTHDR (msg);
+             cmsg != NULL;
+             cmsg = CMSG_NXTHDR ((struct msghdr *) msg, cmsg))
+          {
+            GSocketControlMessage *control_message;
+
+            control_message = g_socket_control_message_deserialize (cmsg->cmsg_level,
+                                                                    cmsg->cmsg_type,
+                                                                    cmsg->cmsg_len - ((char *)CMSG_DATA (cmsg) - (char *)cmsg),
+                                                                    CMSG_DATA (cmsg));
+            if (control_message == NULL)
+              /* We've already spewed about the problem in the
+                 deserialization code, so just continue */
+              continue;
+
+            if (message->control_messages == NULL)
+              {
+                /* we have to do it this way if the user ignores the
+                 * messages so that we will close any received fds.
+                 */
+                g_object_unref (control_message);
+              }
+            else
+              {
+                if (my_messages == NULL)
+                  my_messages = g_ptr_array_new ();
+                g_ptr_array_add (my_messages, control_message);
+              }
+           }
+      }
+
+    if (message->num_control_messages)
+      *message->num_control_messages = my_messages != NULL ? my_messages->len : 0;
+
+    if (message->control_messages)
+      {
+        if (my_messages == NULL)
+          {
+            *message->control_messages = NULL;
+          }
+        else
+          {
+            g_ptr_array_add (my_messages, NULL);
+            *message->control_messages = (GSocketControlMessage **) g_ptr_array_free (my_messages, FALSE);
+          }
+      }
+    else
+      {
+        g_assert (my_messages == NULL);
+      }
+  }
+
+  /* capture the flags */
+  message->flags = msg->msg_flags;
+}
+#endif
+
+/**
+ * g_socket_send_message:
+ * @socket: a #GSocket
+ * @address: (allow-none): a #GSocketAddress, or %NULL
+ * @vectors: (array length=num_vectors): an array of #GOutputVector structs
+ * @num_vectors: the number of elements in @vectors, or -1
+ * @messages: (array length=num_messages) (allow-none): a pointer to an
+ *   array of #GSocketControlMessages, or %NULL.
+ * @num_messages: number of elements in @messages, or -1.
+ * @flags: an int containing #GSocketMsgFlags flags
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Send data to @address on @socket.  For sending multiple messages see
+ * g_socket_send_messages(); for easier use, see
+ * g_socket_send() and g_socket_send_to().
+ *
+ * If @address is %NULL then the message is sent to the default receiver
+ * (set by g_socket_connect()).
+ *
+ * @vectors must point to an array of #GOutputVector structs and
+ * @num_vectors must be the length of this array. (If @num_vectors is -1,
+ * then @vectors is assumed to be terminated by a #GOutputVector with a
+ * %NULL buffer pointer.) The #GOutputVector structs describe the buffers
+ * that the sent data will be gathered from. Using multiple
+ * #GOutputVectors is more memory-efficient than manually copying
+ * data from multiple sources into a single buffer, and more
+ * network-efficient than making multiple calls to g_socket_send().
+ *
+ * @messages, if non-%NULL, is taken to point to an array of @num_messages
+ * #GSocketControlMessage instances. These correspond to the control
+ * messages to be sent on the socket.
+ * If @num_messages is -1 then @messages is treated as a %NULL-terminated
+ * array.
+ *
+ * @flags modify how the message is sent. The commonly available arguments
+ * for this are available in the #GSocketMsgFlags enum, but the
+ * values there are the same as the system values, and the flags
+ * are passed in as-is, so you can pass in system-specific flags too.
+ *
+ * If the socket is in blocking mode the call will block until there is
+ * space for the data in the socket queue. If there is no space available
+ * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
+ * will be returned. To be notified when space is available, wait for the
+ * %G_IO_OUT condition. Note though that you may still receive
+ * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
+ * notified of a %G_IO_OUT condition. (On Windows in particular, this is
+ * very common due to the way the underlying APIs work.)
+ *
+ * On error -1 is returned and @error is set accordingly.
+ *
+ * Returns: Number of bytes written (which may be less than @size), or -1
+ * on error
+ *
+ * Since: 2.22
+ */
+gssize
+g_socket_send_message (GSocket                *socket,
+		       GSocketAddress         *address,
+		       GOutputVector          *vectors,
+		       gint                    num_vectors,
+		       GSocketControlMessage **messages,
+		       gint                    num_messages,
+		       gint                    flags,
+		       GCancellable           *cancellable,
+		       GError                **error)
+{
+  return g_socket_send_message_with_timeout (socket, address,
+                                             vectors, num_vectors,
+                                             messages, num_messages, flags,
+                                             socket->priv->blocking ? -1 : 0,
+                                             cancellable, error);
+}
+
+static gssize
+g_socket_send_message_with_timeout (GSocket                *socket,
+                                    GSocketAddress         *address,
+                                    GOutputVector          *vectors,
+                                    gint                    num_vectors,
+                                    GSocketControlMessage **messages,
+                                    gint                    num_messages,
+                                    gint                    flags,
+                                    gint64                  timeout,
+                                    GCancellable           *cancellable,
+                                    GError                **error)
+{
+  GOutputVector one_vector;
+  char zero;
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+  g_return_val_if_fail (address == NULL || G_IS_SOCKET_ADDRESS (address), -1);
+  g_return_val_if_fail (num_vectors == 0 || vectors != NULL, -1);
+  g_return_val_if_fail (num_messages == 0 || messages != NULL, -1);
+  g_return_val_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable), -1);
+  g_return_val_if_fail (error == NULL || *error == NULL, -1);
+
+  start_time = g_get_monotonic_time ();
+
+  if (!check_socket (socket, error))
+    return -1;
+
+  if (!check_timeout (socket, error))
+    return -1;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  if (num_vectors == -1)
+    {
+      for (num_vectors = 0;
+	   vectors[num_vectors].buffer != NULL;
+	   num_vectors++)
+	;
+    }
+
+  if (num_messages == -1)
+    {
+      for (num_messages = 0;
+	   messages != NULL && messages[num_messages] != NULL;
+	   num_messages++)
+	;
+    }
+
+  if (num_vectors == 0)
+    {
+      zero = '\0';
+
+      one_vector.buffer = &zero;
+      one_vector.size = 1;
+      num_vectors = 1;
+      vectors = &one_vector;
+    }
+
+#ifndef G_OS_WIN32
+  {
+    GOutputMessage output_message;
+    struct msghdr msg;
+    gssize result;
+    GError *child_error = NULL;
+
+    output_message.address = address;
+    output_message.vectors = vectors;
+    output_message.num_vectors = num_vectors;
+    output_message.bytes_sent = 0;
+    output_message.control_messages = messages;
+    output_message.num_control_messages = num_messages;
+
+    output_message_to_msghdr (&output_message, NULL, &msg, NULL, &child_error);
+
+    if (child_error != NULL)
+      {
+        g_propagate_error (error, child_error);
+        return -1;
+      }
+
+    while (1)
+      {
+	result = sendmsg (socket->priv->fd, &msg, flags | G_SOCKET_DEFAULT_SEND_FLAGS);
+	if (result < 0)
+	  {
+	    int errsv = get_socket_errno ();
+
+	    if (errsv == EINTR)
+	      continue;
+
+	    if (timeout != 0 &&
+		(errsv == EWOULDBLOCK ||
+		 errsv == EAGAIN))
+              {
+                if (!block_on_timeout (socket, G_IO_OUT, timeout, start_time,
+                                       cancellable, error))
+                  return -1;
+
+                continue;
+              }
+
+	    socket_set_error_lazy (error, errsv, _("Error sending message: %s"));
+	    return -1;
+	  }
+	break;
+      }
+
+    return result;
+  }
+#else
+  {
+    struct sockaddr_storage addr;
+    guint addrlen;
+    DWORD bytes_sent;
+    int result;
+    WSABUF *bufs;
+    gint i;
+
+    /* Win32 doesn't support control messages.
+       Actually this is possible for raw and datagram sockets
+       via WSASendMessage on Vista or later, but that doesn't
+       seem very useful */
+    if (num_messages != 0)
+      {
+        g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                             _("GSocketControlMessage not supported on Windows"));
+	return -1;
+      }
+
+    /* iov */
+    bufs = g_newa (WSABUF, num_vectors);
+    for (i = 0; i < num_vectors; i++)
+      {
+	bufs[i].buf = (char *)vectors[i].buffer;
+	bufs[i].len = (gulong)vectors[i].size;
+      }
+
+    /* name */
+    addrlen = 0; /* Avoid warning */
+    if (address)
+      {
+	addrlen = g_socket_address_get_native_size (address);
+	if (!g_socket_address_to_native (address, &addr, sizeof addr, error))
+	  return -1;
+      }
+
+    while (1)
+      {
+	if (address)
+	  result = WSASendTo (socket->priv->fd,
+			      bufs, num_vectors,
+			      &bytes_sent, flags,
+			      (const struct sockaddr *)&addr, addrlen,
+			      NULL, NULL);
+	else
+	  result = WSASend (socket->priv->fd,
+			    bufs, num_vectors,
+			    &bytes_sent, flags,
+			    NULL, NULL);
+
+	if (result != 0)
+	  {
+	    int errsv = get_socket_errno ();
+
+	    if (errsv == WSAEINTR)
+	      continue;
+
+	    if (errsv == WSAEWOULDBLOCK)
+              {
+                win32_unset_event_mask (socket, FD_WRITE);
+
+                if (timeout != 0)
+                  {
+                    if (!block_on_timeout (socket, G_IO_OUT, timeout,
+                                           start_time, cancellable, error))
+                      return -1;
+
+                    continue;
+                  }
+              }
+
+	    socket_set_error_lazy (error, errsv, _("Error sending message: %s"));
+	    return -1;
+	  }
+	break;
+      }
+
+    return bytes_sent;
+  }
+#endif
+}
+
+/**
+ * g_socket_send_messages:
+ * @socket: a #GSocket
+ * @messages: (array length=num_messages): an array of #GOutputMessage structs
+ * @num_messages: the number of elements in @messages
+ * @flags: an int containing #GSocketMsgFlags flags
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Send multiple data messages from @socket in one go.  This is the most
+ * complicated and fully-featured version of this call. For easier use, see
+ * g_socket_send(), g_socket_send_to(), and g_socket_send_message().
+ *
+ * @messages must point to an array of #GOutputMessage structs and
+ * @num_messages must be the length of this array. Each #GOutputMessage
+ * contains an address to send the data to, and a pointer to an array of
+ * #GOutputVector structs to describe the buffers that the data to be sent
+ * for each message will be gathered from. Using multiple #GOutputVectors is
+ * more memory-efficient than manually copying data from multiple sources
+ * into a single buffer, and more network-efficient than making multiple
+ * calls to g_socket_send(). Sending multiple messages in one go avoids the
+ * overhead of making a lot of syscalls in scenarios where a lot of data
+ * packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
+ * or where the same data needs to be sent to multiple recipients.
+ *
+ * @flags modify how the message is sent. The commonly available arguments
+ * for this are available in the #GSocketMsgFlags enum, but the
+ * values there are the same as the system values, and the flags
+ * are passed in as-is, so you can pass in system-specific flags too.
+ *
+ * If the socket is in blocking mode the call will block until there is
+ * space for all the data in the socket queue. If there is no space available
+ * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
+ * will be returned if no data was written at all, otherwise the number of
+ * messages sent will be returned. To be notified when space is available,
+ * wait for the %G_IO_OUT condition. Note though that you may still receive
+ * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
+ * notified of a %G_IO_OUT condition. (On Windows in particular, this is
+ * very common due to the way the underlying APIs work.)
+ *
+ * On error -1 is returned and @error is set accordingly. An error will only
+ * be returned if zero messages could be sent; otherwise the number of messages
+ * successfully sent before the error will be returned.
+ *
+ * Returns: number of messages sent, or -1 on error. Note that the number of
+ *     messages sent may be smaller than @num_messages if the socket is
+ *     non-blocking or if @num_messages was larger than UIO_MAXIOV (1024),
+ *     in which case the caller may re-try to send the remaining messages.
+ *
+ * Since: 2.44
+ */
+gint
+g_socket_send_messages (GSocket        *socket,
+		        GOutputMessage *messages,
+		        guint           num_messages,
+		        gint            flags,
+		        GCancellable   *cancellable,
+		        GError        **error)
+{
+  return g_socket_send_messages_with_timeout (socket, messages, num_messages,
+                                              flags,
+                                              socket->priv->blocking ? -1 : 0,
+                                              cancellable, error);
+}
+
+static gint
+g_socket_send_messages_with_timeout (GSocket        *socket,
+                                     GOutputMessage *messages,
+                                     guint           num_messages,
+                                     gint            flags,
+                                     gint64          timeout,
+                                     GCancellable   *cancellable,
+                                     GError        **error)
+{
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+  g_return_val_if_fail (num_messages == 0 || messages != NULL, -1);
+  g_return_val_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable), -1);
+  g_return_val_if_fail (error == NULL || *error == NULL, -1);
+
+  start_time = g_get_monotonic_time ();
+
+  if (!check_socket (socket, error))
+    return -1;
+
+  if (!check_timeout (socket, error))
+    return -1;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  if (num_messages == 0)
+    return 0;
+
+#if !defined (G_OS_WIN32) && defined (HAVE_SENDMMSG)
+  {
+    struct mmsghdr *msgvec;
+    gint i, num_sent;
+
+#ifdef UIO_MAXIOV
+#define MAX_NUM_MESSAGES UIO_MAXIOV
+#else
+#define MAX_NUM_MESSAGES 1024
+#endif
+
+    if (num_messages > MAX_NUM_MESSAGES)
+      num_messages = MAX_NUM_MESSAGES;
+
+    msgvec = g_newa (struct mmsghdr, num_messages);
+
+    for (i = 0; i < num_messages; ++i)
+      {
+        GOutputMessage *msg = &messages[i];
+        struct msghdr *msg_hdr = &msgvec[i].msg_hdr;
+        GError *child_error = NULL;
+
+        msgvec[i].msg_len = 0;
+
+        output_message_to_msghdr (msg, (i > 0) ? &messages[i - 1] : NULL,
+                                  msg_hdr, (i > 0) ? &msgvec[i - 1].msg_hdr : NULL,
+                                  &child_error);
+
+        if (child_error != NULL)
+          {
+            g_propagate_error (error, child_error);
+            return -1;
+          }
+      }
+
+    for (num_sent = 0; num_sent < num_messages;)
+      {
+        gint ret;
+
+        ret = sendmmsg (socket->priv->fd, msgvec + num_sent, num_messages - num_sent,
+                        flags | G_SOCKET_DEFAULT_SEND_FLAGS);
+
+        if (ret < 0)
+          {
+            int errsv = get_socket_errno ();
+
+            if (errsv == EINTR)
+              continue;
+
+            if (timeout != 0 &&
+                (errsv == EWOULDBLOCK ||
+                 errsv == EAGAIN))
+              {
+                if (!block_on_timeout (socket, G_IO_OUT, timeout, start_time,
+                                       cancellable, error))
+                  {
+                    if (num_sent > 0)
+                      {
+                        g_clear_error (error);
+                        break;
+                      }
+
+                    return -1;
+                  }
+
+                continue;
+              }
+
+            /* If any messages were successfully sent, do not error. */
+            if (num_sent > 0)
+              break;
+
+            socket_set_error_lazy (error, errsv, _("Error sending message: %s"));
+
+            return -1;
+          }
+
+        num_sent += ret;
+      }
+
+    for (i = 0; i < num_sent; ++i)
+      messages[i].bytes_sent = msgvec[i].msg_len;
+
+    return num_sent;
+  }
+#else
+  {
+    gssize result;
+    gint i;
+    gint64 wait_timeout;
+
+    wait_timeout = timeout;
+
+    for (i = 0; i < num_messages; ++i)
+      {
+        GOutputMessage *msg = &messages[i];
+        GError *msg_error = NULL;
+
+        result = g_socket_send_message_with_timeout (socket, msg->address,
+                                                     msg->vectors,
+                                                     msg->num_vectors,
+                                                     msg->control_messages,
+                                                     msg->num_control_messages,
+                                                     flags, wait_timeout,
+                                                     cancellable, &msg_error);
+
+        /* check if we've timed out or how much time to wait at most */
+        if (timeout > 0)
+          {
+            gint64 elapsed = g_get_monotonic_time () - start_time;
+            wait_timeout = MAX (timeout - elapsed, 1);
+          }
+
+        if (result < 0)
+          {
+            /* if we couldn't send all messages, just return how many we did
+             * manage to send, provided we managed to send at least one */
+            if (i > 0)
+              {
+                g_error_free (msg_error);
+                return i;
+              }
+            else
+              {
+                g_propagate_error (error, msg_error);
+                return -1;
+              }
+          }
+
+        msg->bytes_sent = result;
+      }
+
+    return i;
+  }
+#endif
+}
+
+static GSocketAddress *
+cache_recv_address (GSocket *socket, struct sockaddr *native, int native_len)
+{
+  GSocketAddress *saddr;
+  gint i;
+  guint64 oldest_time = G_MAXUINT64;
+  gint oldest_index = 0;
+
+  if (native_len <= 0)
+    return NULL;
+
+  saddr = NULL;
+  for (i = 0; i < RECV_ADDR_CACHE_SIZE; i++)
+    {
+      GSocketAddress *tmp = socket->priv->recv_addr_cache[i].addr;
+      gpointer tmp_native = socket->priv->recv_addr_cache[i].native;
+      gint tmp_native_len = socket->priv->recv_addr_cache[i].native_len;
+
+      if (!tmp)
+        continue;
+
+      if (tmp_native_len != native_len)
+        continue;
+
+      if (memcmp (tmp_native, native, native_len) == 0)
+        {
+          saddr = g_object_ref (tmp);
+          socket->priv->recv_addr_cache[i].last_used = g_get_monotonic_time ();
+          return saddr;
+        }
+
+      if (socket->priv->recv_addr_cache[i].last_used < oldest_time)
+        {
+          oldest_time = socket->priv->recv_addr_cache[i].last_used;
+          oldest_index = i;
+        }
+    }
+
+  saddr = g_socket_address_new_from_native (native, native_len);
+
+  if (socket->priv->recv_addr_cache[oldest_index].addr)
+    {
+      g_object_unref (socket->priv->recv_addr_cache[oldest_index].addr);
+      g_free (socket->priv->recv_addr_cache[oldest_index].native);
+    }
+
+  socket->priv->recv_addr_cache[oldest_index].native = g_memdup (native, native_len);
+  socket->priv->recv_addr_cache[oldest_index].native_len = native_len;
+  socket->priv->recv_addr_cache[oldest_index].addr = g_object_ref (saddr);
+  socket->priv->recv_addr_cache[oldest_index].last_used = g_get_monotonic_time ();
+
+  return saddr;
+}
+
+static gssize
+g_socket_receive_message_with_timeout (GSocket                 *socket,
+                                       GSocketAddress         **address,
+                                       GInputVector            *vectors,
+                                       gint                     num_vectors,
+                                       GSocketControlMessage ***messages,
+                                       gint                    *num_messages,
+                                       gint                    *flags,
+                                       gint64                   timeout,
+                                       GCancellable            *cancellable,
+                                       GError                 **error)
+{
+  GInputVector one_vector;
+  char one_byte;
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+
+  start_time = g_get_monotonic_time ();
+
+  if (!check_socket (socket, error))
+    return -1;
+
+  if (!check_timeout (socket, error))
+    return -1;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  if (num_vectors == -1)
+    {
+      for (num_vectors = 0;
+	   vectors[num_vectors].buffer != NULL;
+	   num_vectors++)
+	;
+    }
+
+  if (num_vectors == 0)
+    {
+      one_vector.buffer = &one_byte;
+      one_vector.size = 1;
+      num_vectors = 1;
+      vectors = &one_vector;
+    }
+
+#ifndef G_OS_WIN32
+  {
+    GInputMessage input_message;
+    struct msghdr msg;
+    gssize result;
+
+    input_message.address = address;
+    input_message.vectors = vectors;
+    input_message.num_vectors = num_vectors;
+    input_message.bytes_received = 0;
+    input_message.flags = (flags != NULL) ? *flags : 0;
+    input_message.control_messages = messages;
+    input_message.num_control_messages = (guint *) num_messages;
+
+    /* We always set the close-on-exec flag so we don't leak file
+     * descriptors into child processes.  Note that gunixfdmessage.c
+     * will later call fcntl (fd, FD_CLOEXEC), but that isn't atomic.
+     */
+#ifdef MSG_CMSG_CLOEXEC
+    input_message.flags |= MSG_CMSG_CLOEXEC;
+#endif
+
+    input_message_to_msghdr (&input_message, &msg);
+
+    /* do it */
+    while (1)
+      {
+	result = recvmsg (socket->priv->fd, &msg, msg.msg_flags);
+#ifdef MSG_CMSG_CLOEXEC	
+	if (result < 0 && get_socket_errno () == EINVAL)
+	  {
+	    /* We must be running on an old kernel.  Call without the flag. */
+	    msg.msg_flags &= ~(MSG_CMSG_CLOEXEC);
+	    result = recvmsg (socket->priv->fd, &msg, msg.msg_flags);
+	  }
+#endif
+
+	if (result < 0)
+	  {
+	    int errsv = get_socket_errno ();
+
+	    if (errsv == EINTR)
+	      continue;
+
+	    if (timeout != 0 &&
+		(errsv == EWOULDBLOCK ||
+		 errsv == EAGAIN))
+	      {
+                if (!block_on_timeout (socket, G_IO_IN, timeout, start_time,
+                                       cancellable, error))
+                  return -1;
+
+                continue;
+	      }
+
+	    socket_set_error_lazy (error, errsv, _("Error receiving message: %s"));
+	    return -1;
+	  }
+	break;
+      }
+
+    input_message_from_msghdr (&msg, &input_message, socket);
+
+    if (flags != NULL)
+      *flags = input_message.flags;
+
+    return result;
+  }
+#else
+  {
+    struct sockaddr_storage addr;
+    int addrlen;
+    DWORD bytes_received;
+    DWORD win_flags;
+    int result;
+    WSABUF *bufs;
+    gint i;
+
+    /* iov */
+    bufs = g_newa (WSABUF, num_vectors);
+    for (i = 0; i < num_vectors; i++)
+      {
+	bufs[i].buf = (char *)vectors[i].buffer;
+	bufs[i].len = (gulong)vectors[i].size;
+      }
+
+    /* flags */
+    if (flags != NULL)
+      win_flags = *flags;
+    else
+      win_flags = 0;
+
+    /* do it */
+    while (1)
+      {
+	addrlen = sizeof addr;
+	if (address)
+	  result = WSARecvFrom (socket->priv->fd,
+				bufs, num_vectors,
+				&bytes_received, &win_flags,
+				(struct sockaddr *)&addr, &addrlen,
+				NULL, NULL);
+	else
+	  result = WSARecv (socket->priv->fd,
+			    bufs, num_vectors,
+			    &bytes_received, &win_flags,
+			    NULL, NULL);
+	if (result != 0)
+	  {
+	    int errsv = get_socket_errno ();
+
+	    if (errsv == WSAEINTR)
+	      continue;
+
+            if (errsv == WSAEWOULDBLOCK)
+              {
+                win32_unset_event_mask (socket, FD_READ);
+
+                if (timeout != 0)
+                  {
+                    if (!block_on_timeout (socket, G_IO_IN, timeout,
+                                           start_time, cancellable, error))
+                      return -1;
+
+                    continue;
+                  }
+              }
+
+	    socket_set_error_lazy (error, errsv, _("Error receiving message: %s"));
+	    return -1;
+	  }
+	win32_unset_event_mask (socket, FD_READ);
+	break;
+      }
+
+    /* decode address */
+    if (address != NULL)
+      {
+        *address = cache_recv_address (socket, (struct sockaddr *)&addr, addrlen);
+      }
+
+    /* capture the flags */
+    if (flags != NULL)
+      *flags = win_flags;
+
+    if (messages != NULL)
+      *messages = NULL;
+    if (num_messages != NULL)
+      *num_messages = 0;
+
+    return bytes_received;
+  }
+#endif
+}
+
+/**
+ * g_socket_receive_messages:
+ * @socket: a #GSocket
+ * @messages: (array length=num_messages): an array of #GInputMessage structs
+ * @num_messages: the number of elements in @messages
+ * @flags: an int containing #GSocketMsgFlags flags for the overall operation
+ * @cancellable: (allow-none): a %GCancellable or %NULL
+ * @error: #GError for error reporting, or %NULL to ignore
+ *
+ * Receive multiple data messages from @socket in one go.  This is the most
+ * complicated and fully-featured version of this call. For easier use, see
+ * g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
+ *
+ * @messages must point to an array of #GInputMessage structs and
+ * @num_messages must be the length of this array. Each #GInputMessage
+ * contains a pointer to an array of #GInputVector structs describing the
+ * buffers that the data received in each message will be written to. Using
+ * multiple #GInputVectors is more memory-efficient than manually copying data
+ * out of a single buffer to multiple sources, and more system-call-efficient
+ * than making multiple calls to g_socket_receive(), such as in scenarios where
+ * a lot of data packets need to be received (e.g. high-bandwidth video
+ * streaming over RTP/UDP).
+ *
+ * @flags modify how all messages are received. The commonly available
+ * arguments for this are available in the #GSocketMsgFlags enum, but the
+ * values there are the same as the system values, and the flags
+ * are passed in as-is, so you can pass in system-specific flags too. These
+ * flags affect the overall receive operation. Flags affecting individual
+ * messages are returned in #GInputMessage.flags.
+ *
+ * The other members of #GInputMessage are treated as described in its
+ * documentation.
+ *
+ * If #GSocket:blocking is %TRUE the call will block until @num_messages have
+ * been received, or the end of the stream is reached.
+ *
+ * If #GSocket:blocking is %FALSE the call will return up to @num_messages
+ * without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
+ * operating system to be received.
+ *
+ * In blocking mode, if #GSocket:timeout is positive and is reached before any
+ * messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
+ * @num_messages are returned. (Note: This is effectively the
+ * behaviour of `MSG_WAITFORONE` with recvmmsg().)
+ *
+ * To be notified when messages are available, wait for the
+ * %G_IO_IN condition. Note though that you may still receive
+ * %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
+ * previously notified of a %G_IO_IN condition.
+ *
+ * If the remote peer closes the connection, any messages queued in the
+ * operating system will be returned, and subsequent calls to
+ * g_socket_receive_messages() will return 0 (with no error set).
+ *
+ * On error -1 is returned and @error is set accordingly. An error will only
+ * be returned if zero messages could be received; otherwise the number of
+ * messages successfully received before the error will be returned.
+ *
+ * Returns: number of messages received, or -1 on error. Note that the number
+ *     of messages received may be smaller than @num_messages if in non-blocking
+ *     mode, if the peer closed the connection, or if @num_messages
+ *     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
+ *     to receive the remaining messages.
+ *
+ * Since: 2.48
+ */
+gint
+g_socket_receive_messages (GSocket        *socket,
+                           GInputMessage  *messages,
+                           guint           num_messages,
+                           gint            flags,
+                           GCancellable   *cancellable,
+                           GError        **error)
+{
+  if (!check_socket (socket, error) ||
+      !check_timeout (socket, error))
+    return -1;
+
+  return g_socket_receive_messages_with_timeout (socket, messages, num_messages,
+                                                 flags,
+                                                 socket->priv->blocking ? -1 : 0,
+                                                 cancellable, error);
+}
+
+static gint
+g_socket_receive_messages_with_timeout (GSocket        *socket,
+                                        GInputMessage  *messages,
+                                        guint           num_messages,
+                                        gint            flags,
+                                        gint64          timeout,
+                                        GCancellable   *cancellable,
+                                        GError        **error)
+{
+  gint64 start_time;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), -1);
+  g_return_val_if_fail (num_messages == 0 || messages != NULL, -1);
+  g_return_val_if_fail (cancellable == NULL ||
+                        G_IS_CANCELLABLE (cancellable), -1);
+  g_return_val_if_fail (error == NULL || *error == NULL, -1);
+
+  start_time = g_get_monotonic_time ();
+
+  if (!check_socket (socket, error))
+    return -1;
+
+  if (!check_timeout (socket, error))
+    return -1;
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return -1;
+
+  if (num_messages == 0)
+    return 0;
+
+#if !defined (G_OS_WIN32) && defined (HAVE_RECVMMSG)
+  {
+    struct mmsghdr *msgvec;
+    guint i, num_received;
+
+#ifdef UIO_MAXIOV
+#define MAX_NUM_MESSAGES UIO_MAXIOV
+#else
+#define MAX_NUM_MESSAGES 1024
+#endif
+
+    if (num_messages > MAX_NUM_MESSAGES)
+      num_messages = MAX_NUM_MESSAGES;
+
+    msgvec = g_newa (struct mmsghdr, num_messages);
+
+    for (i = 0; i < num_messages; ++i)
+      {
+        GInputMessage *msg = &messages[i];
+        struct msghdr *msg_hdr = &msgvec[i].msg_hdr;
+
+        input_message_to_msghdr (msg, msg_hdr);
+        msgvec[i].msg_len = 0;
+      }
+
+    /* We always set the close-on-exec flag so we don't leak file
+     * descriptors into child processes.  Note that gunixfdmessage.c
+     * will later call fcntl (fd, FD_CLOEXEC), but that isn't atomic.
+     */
+#ifdef MSG_CMSG_CLOEXEC
+    flags |= MSG_CMSG_CLOEXEC;
+#endif
+
+    for (num_received = 0; num_received < num_messages;)
+      {
+        gint ret;
+
+        /* We operate in non-blocking mode and handle the timeout ourselves. */
+        ret = recvmmsg (socket->priv->fd,
+                        msgvec + num_received,
+                        num_messages - num_received,
+                        flags | G_SOCKET_DEFAULT_SEND_FLAGS, NULL);
+#ifdef MSG_CMSG_CLOEXEC
+        if (ret < 0 && get_socket_errno () == EINVAL)
+          {
+            /* We must be running on an old kernel. Call without the flag. */
+            flags &= ~(MSG_CMSG_CLOEXEC);
+            ret = recvmmsg (socket->priv->fd,
+                            msgvec + num_received,
+                            num_messages - num_received,
+                            flags | G_SOCKET_DEFAULT_SEND_FLAGS, NULL);
+          }
+#endif
+
+        if (ret < 0)
+          {
+            int errsv = get_socket_errno ();
+
+            if (errsv == EINTR)
+              continue;
+
+            if (timeout != 0 &&
+                (errsv == EWOULDBLOCK ||
+                 errsv == EAGAIN))
+              {
+                if (!block_on_timeout (socket, G_IO_IN, timeout, start_time,
+                                       cancellable, error))
+                  {
+                    if (num_received > 0)
+                      {
+                        g_clear_error (error);
+                        break;
+                      }
+
+                    return -1;
+                  }
+
+                continue;
+              }
+
+            /* If any messages were successfully received, do not error. */
+            if (num_received > 0)
+              break;
+
+            socket_set_error_lazy (error, errsv,
+                                   _("Error receiving message: %s"));
+
+            return -1;
+          }
+        else if (ret == 0)
+          {
+            /* EOS. */
+            break;
+          }
+
+        num_received += ret;
+      }
+
+    for (i = 0; i < num_received; ++i)
+      {
+        input_message_from_msghdr (&msgvec[i].msg_hdr, &messages[i], socket);
+        messages[i].bytes_received = msgvec[i].msg_len;
+      }
+
+    return num_received;
+  }
+#else
+  {
+    guint i;
+    gint64 wait_timeout;
+
+    wait_timeout = timeout;
+
+    for (i = 0; i < num_messages; i++)
+      {
+        GInputMessage *msg = &messages[i];
+        gssize len;
+        GError *msg_error = NULL;
+
+        msg->flags = flags;  /* in-out parameter */
+
+        len = g_socket_receive_message_with_timeout (socket,
+                                                     msg->address,
+                                                     msg->vectors,
+                                                     msg->num_vectors,
+                                                     msg->control_messages,
+                                                     (gint *) msg->num_control_messages,
+                                                     &msg->flags,
+                                                     wait_timeout,
+                                                     cancellable,
+                                                     &msg_error);
+
+        /* check if we've timed out or how much time to wait at most */
+        if (timeout > 0)
+          {
+            gint64 elapsed = g_get_monotonic_time () - start_time;
+            wait_timeout = MAX (timeout - elapsed, 1);
+          }
+
+        if (len >= 0)
+          msg->bytes_received = len;
+
+        if (i != 0 &&
+            (g_error_matches (msg_error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK) ||
+             g_error_matches (msg_error, G_IO_ERROR, G_IO_ERROR_TIMED_OUT)))
+          {
+            g_clear_error (&msg_error);
+            break;
+          }
+
+        if (msg_error != NULL)
+          {
+            g_propagate_error (error, msg_error);
+            return -1;
+          }
+
+        if (len == 0)
+          break;
+      }
+
+    return i;
+  }
+#endif
+}
+
+/**
+ * g_socket_receive_message:
+ * @socket: a #GSocket
+ * @address: (out) (nullable): a pointer to a #GSocketAddress
+ *     pointer, or %NULL
+ * @vectors: (array length=num_vectors): an array of #GInputVector structs
+ * @num_vectors: the number of elements in @vectors, or -1
+ * @messages: (array length=num_messages) (out) (nullable): a pointer which
+ *    may be filled with an array of #GSocketControlMessages, or %NULL
+ * @num_messages: (out): a pointer which will be filled with the number of
+ *    elements in @messages, or %NULL
+ * @flags: (inout): a pointer to an int containing #GSocketMsgFlags flags
+ * @cancellable: a %GCancellable or %NULL
+ * @error: a #GError pointer, or %NULL
+ *
+ * Receive data from a socket.  For receiving multiple messages, see
+ * g_socket_receive_messages(); for easier use, see
+ * g_socket_receive() and g_socket_receive_from().
+ *
+ * If @address is non-%NULL then @address will be set equal to the
+ * source address of the received packet.
+ * @address is owned by the caller.
+ *
+ * @vector must point to an array of #GInputVector structs and
+ * @num_vectors must be the length of this array.  These structs
+ * describe the buffers that received data will be scattered into.
+ * If @num_vectors is -1, then @vectors is assumed to be terminated
+ * by a #GInputVector with a %NULL buffer pointer.
+ *
+ * As a special case, if @num_vectors is 0 (in which case, @vectors
+ * may of course be %NULL), then a single byte is received and
+ * discarded. This is to facilitate the common practice of sending a
+ * single '\0' byte for the purposes of transferring ancillary data.
+ *
+ * @messages, if non-%NULL, will be set to point to a newly-allocated
+ * array of #GSocketControlMessage instances or %NULL if no such
+ * messages was received. These correspond to the control messages
+ * received from the kernel, one #GSocketControlMessage per message
+ * from the kernel. This array is %NULL-terminated and must be freed
+ * by the caller using g_free() after calling g_object_unref() on each
+ * element. If @messages is %NULL, any control messages received will
+ * be discarded.
+ *
+ * @num_messages, if non-%NULL, will be set to the number of control
+ * messages received.
+ *
+ * If both @messages and @num_messages are non-%NULL, then
+ * @num_messages gives the number of #GSocketControlMessage instances
+ * in @messages (ie: not including the %NULL terminator).
+ *
+ * @flags is an in/out parameter. The commonly available arguments
+ * for this are available in the #GSocketMsgFlags enum, but the
+ * values there are the same as the system values, and the flags
+ * are passed in as-is, so you can pass in system-specific flags too
+ * (and g_socket_receive_message() may pass system-specific flags out).
+ * Flags passed in to the parameter affect the receive operation; flags returned
+ * out of it are relevant to the specific returned message.
+ *
+ * As with g_socket_receive(), data may be discarded if @socket is
+ * %G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
+ * provide enough buffer space to read a complete message. You can pass
+ * %G_SOCKET_MSG_PEEK in @flags to peek at the current message without
+ * removing it from the receive queue, but there is no portable way to find
+ * out the length of the message other than by reading it into a
+ * sufficiently-large buffer.
+ *
+ * If the socket is in blocking mode the call will block until there
+ * is some data to receive, the connection is closed, or there is an
+ * error. If there is no data available and the socket is in
+ * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
+ * returned. To be notified when data is available, wait for the
+ * %G_IO_IN condition.
+ *
+ * On error -1 is returned and @error is set accordingly.
+ *
+ * Returns: Number of bytes read, or 0 if the connection was closed by
+ * the peer, or -1 on error
+ *
+ * Since: 2.22
+ */
+gssize
+g_socket_receive_message (GSocket                 *socket,
+			  GSocketAddress         **address,
+			  GInputVector            *vectors,
+			  gint                     num_vectors,
+			  GSocketControlMessage ***messages,
+			  gint                    *num_messages,
+			  gint                    *flags,
+			  GCancellable            *cancellable,
+			  GError                 **error)
+{
+  return g_socket_receive_message_with_timeout (socket, address, vectors,
+                                                 num_vectors, messages,
+                                                 num_messages, flags,
+                                                 socket->priv->blocking ? -1 : 0,
+                                                 cancellable, error);
+}
+
+/**
+ * g_socket_get_credentials:
+ * @socket: a #GSocket.
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Returns the credentials of the foreign process connected to this
+ * socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
+ * sockets).
+ *
+ * If this operation isn't supported on the OS, the method fails with
+ * the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
+ * by reading the %SO_PEERCRED option on the underlying socket.
+ *
+ * Other ways to obtain credentials from a foreign peer includes the
+ * #GUnixCredentialsMessage type and
+ * g_unix_connection_send_credentials() /
+ * g_unix_connection_receive_credentials() functions.
+ *
+ * Returns: (transfer full): %NULL if @error is set, otherwise a #GCredentials object
+ * that must be freed with g_object_unref().
+ *
+ * Since: 2.26
+ */
+GCredentials *
+g_socket_get_credentials (GSocket   *socket,
+                          GError   **error)
+{
+  GCredentials *ret;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), NULL);
+  g_return_val_if_fail (error == NULL || *error == NULL, NULL);
+
+  ret = NULL;
+
+#if G_CREDENTIALS_SOCKET_GET_CREDENTIALS_SUPPORTED
+
+#ifdef SO_PEERCRED
+  {
+    guint8 native_creds_buf[G_CREDENTIALS_NATIVE_SIZE];
+    socklen_t optlen = sizeof (native_creds_buf);
+
+    if (getsockopt (socket->priv->fd,
+                    SOL_SOCKET,
+                    SO_PEERCRED,
+                    native_creds_buf,
+                    &optlen) == 0)
+      {
+        ret = g_credentials_new ();
+        g_credentials_set_native (ret,
+                                  G_CREDENTIALS_NATIVE_TYPE,
+                                  native_creds_buf);
+      }
+  }
+#elif G_CREDENTIALS_USE_NETBSD_UNPCBID
+  {
+    struct unpcbid cred;
+    socklen_t optlen = sizeof (cred);
+
+    if (getsockopt (socket->priv->fd,
+                    0,
+                    LOCAL_PEEREID,
+                    &cred,
+                    &optlen) == 0)
+      {
+        ret = g_credentials_new ();
+        g_credentials_set_native (ret,
+                                  G_CREDENTIALS_NATIVE_TYPE,
+                                  &cred);
+      }
+  }
+#elif G_CREDENTIALS_USE_SOLARIS_UCRED
+  {
+    ucred_t *ucred = NULL;
+
+    if (getpeerucred (socket->priv->fd, &ucred) == 0)
+      {
+        ret = g_credentials_new ();
+        g_credentials_set_native (ret,
+                                  G_CREDENTIALS_TYPE_SOLARIS_UCRED,
+                                  ucred);
+        ucred_free (ucred);
+      }
+  }
+#else
+  #error "G_CREDENTIALS_SOCKET_GET_CREDENTIALS_SUPPORTED is set but this is no code for this platform"
+#endif
+
+  if (!ret)
+    {
+      int errsv = get_socket_errno ();
+
+      g_set_error (error,
+                   G_IO_ERROR,
+                   socket_io_error_from_errno (errsv),
+                   _("Unable to read socket credentials: %s"),
+                   socket_strerror (errsv));
+    }
+
+#else
+
+  g_set_error_literal (error,
+                       G_IO_ERROR,
+                       G_IO_ERROR_NOT_SUPPORTED,
+                       _("g_socket_get_credentials not implemented for this OS"));
+#endif
+
+  return ret;
+}
+
+/**
+ * g_socket_get_option:
+ * @socket: a #GSocket
+ * @level: the "API level" of the option (eg, `SOL_SOCKET`)
+ * @optname: the "name" of the option (eg, `SO_BROADCAST`)
+ * @value: (out): return location for the option value
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Gets the value of an integer-valued option on @socket, as with
+ * getsockopt(). (If you need to fetch a  non-integer-valued option,
+ * you will need to call getsockopt() directly.)
+ *
+ * The [<gio/gnetworking.h>][gio-gnetworking.h]
+ * header pulls in system headers that will define most of the
+ * standard/portable socket options. For unusual socket protocols or
+ * platform-dependent options, you may need to include additional
+ * headers.
+ *
+ * Note that even for socket options that are a single byte in size,
+ * @value is still a pointer to a #gint variable, not a #guchar;
+ * g_socket_get_option() will handle the conversion internally.
+ *
+ * Returns: success or failure. On failure, @error will be set, and
+ *   the system error value (`errno` or WSAGetLastError()) will still
+ *   be set to the result of the getsockopt() call.
+ *
+ * Since: 2.36
+ */
+gboolean
+g_socket_get_option (GSocket  *socket,
+		     gint      level,
+		     gint      optname,
+		     gint     *value,
+		     GError  **error)
+{
+  guint size;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  *value = 0;
+  size = sizeof (gint);
+  if (getsockopt (socket->priv->fd, level, optname, value, &size) != 0)
+    {
+      int errsv = get_socket_errno ();
+
+      g_set_error_literal (error,
+			   G_IO_ERROR,
+			   socket_io_error_from_errno (errsv),
+			   socket_strerror (errsv));
+#ifndef G_OS_WIN32
+      /* Reset errno in case the caller wants to look at it */
+      errno = errsv;
+#endif
+      return FALSE;
+    }
+
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  /* If the returned value is smaller than an int then we need to
+   * slide it over into the low-order bytes of *value.
+   */
+  if (size != sizeof (gint))
+    *value = *value >> (8 * (sizeof (gint) - size));
+#endif
+
+  return TRUE;
+}
+
+/**
+ * g_socket_set_option:
+ * @socket: a #GSocket
+ * @level: the "API level" of the option (eg, `SOL_SOCKET`)
+ * @optname: the "name" of the option (eg, `SO_BROADCAST`)
+ * @value: the value to set the option to
+ * @error: #GError for error reporting, or %NULL to ignore.
+ *
+ * Sets the value of an integer-valued option on @socket, as with
+ * setsockopt(). (If you need to set a non-integer-valued option,
+ * you will need to call setsockopt() directly.)
+ *
+ * The [<gio/gnetworking.h>][gio-gnetworking.h]
+ * header pulls in system headers that will define most of the
+ * standard/portable socket options. For unusual socket protocols or
+ * platform-dependent options, you may need to include additional
+ * headers.
+ *
+ * Returns: success or failure. On failure, @error will be set, and
+ *   the system error value (`errno` or WSAGetLastError()) will still
+ *   be set to the result of the setsockopt() call.
+ *
+ * Since: 2.36
+ */
+gboolean
+g_socket_set_option (GSocket  *socket,
+		     gint      level,
+		     gint      optname,
+		     gint      value,
+		     GError  **error)
+{
+  gint errsv;
+
+  g_return_val_if_fail (G_IS_SOCKET (socket), FALSE);
+
+  if (setsockopt (socket->priv->fd, level, optname, &value, sizeof (gint)) == 0)
+    return TRUE;
+
+#if !defined (__linux__) && !defined (G_OS_WIN32)
+  /* Linux and Windows let you set a single-byte value from an int,
+   * but most other platforms don't.
+   */
+  if (errno == EINVAL && value >= SCHAR_MIN && value <= CHAR_MAX)
+    {
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+      value = value << (8 * (sizeof (gint) - 1));
+#endif
+      if (setsockopt (socket->priv->fd, level, optname, &value, 1) == 0)
+        return TRUE;
+    }
+#endif
+
+  errsv = get_socket_errno ();
+
+  g_set_error_literal (error,
+                       G_IO_ERROR,
+                       socket_io_error_from_errno (errsv),
+                       socket_strerror (errsv));
+#ifndef G_OS_WIN32
+  errno = errsv;
+#endif
+  return FALSE;
+}
+
diff -urN glib-2.51.0.org/glib/glib-init.c glib-2.51.0/glib/glib-init.c
--- glib-2.51.0.org/glib/glib-init.c	2016-10-22 07:21:54.000000000 +0200
+++ glib-2.51.0/glib/glib-init.c	2016-10-28 22:58:56.882556646 +0200
@@ -245,12 +245,14 @@
 
 #if defined (G_OS_WIN32)
 
+HMODULE glib_dll = NULL;
+
+#if defined (DLL_EXPORT)
+
 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
-HMODULE glib_dll;
-
 BOOL WINAPI
 DllMain (HINSTANCE hinstDLL,
          DWORD     fdwReason,
@@ -260,11 +262,6 @@
     {
     case DLL_PROCESS_ATTACH:
       glib_dll = hinstDLL;
-      g_clock_win32_init ();
-#ifdef THREADS_WIN32
-      g_thread_win32_init ();
-#endif
-      glib_init ();
       break;
 
     case DLL_THREAD_DETACH:
@@ -288,7 +285,10 @@
   return TRUE;
 }
 
-#elif defined (G_HAS_CONSTRUCTORS)
+#endif /* defined (DLL_EXPORT) */
+#endif /* defined (G_OS_WIN32) */
+
+#if defined (G_HAS_CONSTRUCTORS)
 
 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(glib_init_ctor)
@@ -298,6 +298,12 @@
 static void
 glib_init_ctor (void)
 {
+#if defined (G_OS_WIN32)
+  g_clock_win32_init ();
+#ifdef THREADS_WIN32
+  g_thread_win32_init ();
+#endif /* defined (THREADS_WIN32) */
+#endif /* defined (G_OS_WIN32) */
   glib_init ();
 }
 
diff -urN glib-2.51.0.org/glib/gmacros.h glib-2.51.0/glib/gmacros.h
--- glib-2.51.0.org/glib/gmacros.h	2016-10-22 07:21:27.000000000 +0200
+++ glib-2.51.0/glib/gmacros.h	2016-10-28 22:58:56.885556623 +0200
@@ -129,9 +129,9 @@
 
 #if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
 #define G_GNUC_PRINTF( format_idx, arg_idx )    \
-  __attribute__((__format__ (__printf__, format_idx, arg_idx)))
+  __attribute__((__format__ (gnu_printf, format_idx, arg_idx)))
 #define G_GNUC_SCANF( format_idx, arg_idx )     \
-  __attribute__((__format__ (__scanf__, format_idx, arg_idx)))
+  __attribute__((__format__ (gnu_scanf, format_idx, arg_idx)))
 #define G_GNUC_FORMAT( arg_idx )                \
   __attribute__((__format_arg__ (arg_idx)))
 #define G_GNUC_NORETURN                         \
diff -urN glib-2.51.0.org/glib/gmacros.h.orig glib-2.51.0/glib/gmacros.h.orig
--- glib-2.51.0.org/glib/gmacros.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ glib-2.51.0/glib/gmacros.h.orig	2016-10-22 07:21:27.000000000 +0200
@@ -0,0 +1,470 @@
+/* GLIB - Library of useful routines for C programming
+ * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/.
+ */
+
+/* This file must not include any other glib header file and must thus
+ * not refer to variables from glibconfig.h
+ */
+
+#ifndef __G_MACROS_H__
+#define __G_MACROS_H__
+
+#if !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
+#error "Only <glib.h> can be included directly."
+#endif
+
+/* We include stddef.h to get the system's definition of NULL
+ */
+#include <stddef.h>
+
+#define G_GNUC_CHECK_VERSION(major, minor) \
+    (defined(__GNUC__) && \
+     ((__GNUC__ > (major)) || \
+      ((__GNUC__ == (major)) && \
+       (__GNUC_MINOR__ >= (minor)))))
+
+/* Here we provide G_GNUC_EXTENSION as an alias for __extension__,
+ * where this is valid. This allows for warningless compilation of
+ * "long long" types even in the presence of '-ansi -pedantic'. 
+ */
+#if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)
+#define G_GNUC_EXTENSION __extension__
+#else
+#define G_GNUC_EXTENSION
+#endif
+
+/* Every compiler that we target supports inlining, but some of them may
+ * complain about it if we don't say "__inline".  If we have C99, or if
+ * we are using C++, then we can use "inline" directly.  Unfortunately
+ * Visual Studio does not support __STDC_VERSION__, so we need to check
+ * whether we are on Visual Studio 2013 or earlier to see that we need to
+ * say "__inline" in C mode.
+ * Otherwise, we say "__inline" to avoid the warning.
+ */
+#define G_CAN_INLINE
+#ifndef __cplusplus
+# ifdef _MSC_VER
+#  if (_MSC_VER < 1900)
+#   define G_INLINE_DEFINE_NEEDED
+#  endif
+# elif !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 199900)
+#  define G_INLINE_DEFINE_NEEDED
+# endif
+#endif
+
+#ifdef G_INLINE_DEFINE_NEEDED
+# undef inline
+# define inline __inline
+#endif
+
+#undef G_INLINE_DEFINE_NEEDED
+
+/* For historical reasons we need to continue to support those who
+ * define G_IMPLEMENT_INLINES to mean "don't implement this here".
+ */
+#ifdef G_IMPLEMENT_INLINES
+#  define G_INLINE_FUNC extern
+#  undef  G_CAN_INLINE
+#else
+#  define G_INLINE_FUNC static inline
+#endif /* G_IMPLEMENT_INLINES */
+
+/* Provide macros to feature the GCC function attribute.
+ */
+#if    __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+#define G_GNUC_PURE __attribute__((__pure__))
+#define G_GNUC_MALLOC __attribute__((__malloc__))
+#else
+#define G_GNUC_PURE
+#define G_GNUC_MALLOC
+#endif
+
+#if     __GNUC__ >= 4
+#define G_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
+#else
+#define G_GNUC_NULL_TERMINATED
+#endif
+
+/* Clang feature detection: http://clang.llvm.org/docs/LanguageExtensions.html */
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
+#if     (!defined(__clang__) && ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))) || \
+        (defined(__clang__) && __has_attribute(__alloc_size__))
+#define G_GNUC_ALLOC_SIZE(x) __attribute__((__alloc_size__(x)))
+#define G_GNUC_ALLOC_SIZE2(x,y) __attribute__((__alloc_size__(x,y)))
+#else
+#define G_GNUC_ALLOC_SIZE(x)
+#define G_GNUC_ALLOC_SIZE2(x,y)
+#endif
+
+#if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+#define G_GNUC_PRINTF( format_idx, arg_idx )    \
+  __attribute__((__format__ (__printf__, format_idx, arg_idx)))
+#define G_GNUC_SCANF( format_idx, arg_idx )     \
+  __attribute__((__format__ (__scanf__, format_idx, arg_idx)))
+#define G_GNUC_FORMAT( arg_idx )                \
+  __attribute__((__format_arg__ (arg_idx)))
+#define G_GNUC_NORETURN                         \
+  __attribute__((__noreturn__))
+#define G_GNUC_CONST                            \
+  __attribute__((__const__))
+#define G_GNUC_UNUSED                           \
+  __attribute__((__unused__))
+#define G_GNUC_NO_INSTRUMENT			\
+  __attribute__((__no_instrument_function__))
+#else   /* !__GNUC__ */
+#define G_GNUC_PRINTF( format_idx, arg_idx )
+#define G_GNUC_SCANF( format_idx, arg_idx )
+#define G_GNUC_FORMAT( arg_idx )
+#define G_GNUC_NORETURN
+#define G_GNUC_CONST
+#define G_GNUC_UNUSED
+#define G_GNUC_NO_INSTRUMENT
+#endif  /* !__GNUC__ */
+
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
+#define G_GNUC_DEPRECATED __attribute__((__deprecated__))
+#else
+#define G_GNUC_DEPRECATED
+#endif /* __GNUC__ */
+
+#if    __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+#define G_GNUC_DEPRECATED_FOR(f)                        \
+  __attribute__((deprecated("Use " #f " instead")))
+#else
+#define G_GNUC_DEPRECATED_FOR(f)        G_GNUC_DEPRECATED
+#endif /* __GNUC__ */
+
+#if    __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
+#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS		\
+  _Pragma ("GCC diagnostic push")			\
+  _Pragma ("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
+#define G_GNUC_END_IGNORE_DEPRECATIONS			\
+  _Pragma ("GCC diagnostic pop")
+#elif defined (_MSC_VER) && (_MSC_VER >= 1500)
+#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS		\
+  __pragma (warning (push))  \
+  __pragma (warning (disable : 4996))
+#define G_GNUC_END_IGNORE_DEPRECATIONS			\
+  __pragma (warning (pop))
+#elif defined (__clang__)
+#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS \
+  _Pragma("clang diagnostic push") \
+  _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
+#define G_GNUC_END_IGNORE_DEPRECATIONS \
+  _Pragma("clang diagnostic pop")
+#else
+#define G_GNUC_BEGIN_IGNORE_DEPRECATIONS
+#define G_GNUC_END_IGNORE_DEPRECATIONS
+#endif
+
+#if     __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
+#define G_GNUC_MAY_ALIAS __attribute__((may_alias))
+#else
+#define G_GNUC_MAY_ALIAS
+#endif
+
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#define G_GNUC_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
+#else
+#define G_GNUC_WARN_UNUSED_RESULT
+#endif /* __GNUC__ */
+
+#ifndef G_DISABLE_DEPRECATED
+/* Wrap the gcc __PRETTY_FUNCTION__ and __FUNCTION__ variables with
+ * macros, so we can refer to them as strings unconditionally.
+ * usage not-recommended since gcc-3.0
+ */
+#if defined (__GNUC__) && (__GNUC__ < 3)
+#define G_GNUC_FUNCTION         __FUNCTION__
+#define G_GNUC_PRETTY_FUNCTION  __PRETTY_FUNCTION__
+#else   /* !__GNUC__ */
+#define G_GNUC_FUNCTION         ""
+#define G_GNUC_PRETTY_FUNCTION  ""
+#endif  /* !__GNUC__ */
+#endif  /* !G_DISABLE_DEPRECATED */
+
+#if __has_feature(attribute_analyzer_noreturn) && defined(__clang_analyzer__)
+#define G_ANALYZER_ANALYZING 1
+#define G_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
+#else
+#define G_ANALYZER_ANALYZING 0
+#define G_ANALYZER_NORETURN
+#endif
+
+#define G_STRINGIFY(macro_or_string)	G_STRINGIFY_ARG (macro_or_string)
+#define	G_STRINGIFY_ARG(contents)	#contents
+
+#ifndef __GI_SCANNER__ /* The static assert macro really confuses the introspection parser */
+#define G_PASTE_ARGS(identifier1,identifier2) identifier1 ## identifier2
+#define G_PASTE(identifier1,identifier2)      G_PASTE_ARGS (identifier1, identifier2)
+#ifdef __COUNTER__
+#define G_STATIC_ASSERT(expr) typedef char G_PASTE (_GStaticAssertCompileTimeAssertion_, __COUNTER__)[(expr) ? 1 : -1] G_GNUC_UNUSED
+#else
+#define G_STATIC_ASSERT(expr) typedef char G_PASTE (_GStaticAssertCompileTimeAssertion_, __LINE__)[(expr) ? 1 : -1] G_GNUC_UNUSED
+#endif
+#define G_STATIC_ASSERT_EXPR(expr) ((void) sizeof (char[(expr) ? 1 : -1]))
+#endif
+
+/* Provide a string identifying the current code position */
+#if defined(__GNUC__) && (__GNUC__ < 3) && !defined(__cplusplus)
+#define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__) ":" __PRETTY_FUNCTION__ "()"
+#else
+#define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
+#endif
+
+/* Provide a string identifying the current function, non-concatenatable */
+#if defined (__GNUC__) && defined (__cplusplus)
+#define G_STRFUNC     ((const char*) (__PRETTY_FUNCTION__))
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#define G_STRFUNC     ((const char*) (__func__))
+#elif defined (__GNUC__) || (defined(_MSC_VER) && (_MSC_VER > 1300))
+#define G_STRFUNC     ((const char*) (__FUNCTION__))
+#else
+#define G_STRFUNC     ((const char*) ("???"))
+#endif
+
+/* Guard C code in headers, while including them from C++ */
+#ifdef  __cplusplus
+#define G_BEGIN_DECLS  extern "C" {
+#define G_END_DECLS    }
+#else
+#define G_BEGIN_DECLS
+#define G_END_DECLS
+#endif
+
+/* Provide definitions for some commonly used macros.
+ *  Some of them are only provided if they haven't already
+ *  been defined. It is assumed that if they are already
+ *  defined then the current definition is correct.
+ */
+#ifndef NULL
+#  ifdef __cplusplus
+#  define NULL        (0L)
+#  else /* !__cplusplus */
+#  define NULL        ((void*) 0)
+#  endif /* !__cplusplus */
+#endif
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+#undef	MAX
+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
+
+#undef	MIN
+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
+
+#undef	ABS
+#define ABS(a)	   (((a) < 0) ? -(a) : (a))
+
+#undef	CLAMP
+#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
+
+/* Count the number of elements in an array. The array must be defined
+ * as such; using this with a dynamically allocated array will give
+ * incorrect results.
+ */
+#define G_N_ELEMENTS(arr)		(sizeof (arr) / sizeof ((arr)[0]))
+
+/* Macros by analogy to GINT_TO_POINTER, GPOINTER_TO_INT
+ */
+#define GPOINTER_TO_SIZE(p)	((gsize) (p))
+#define GSIZE_TO_POINTER(s)	((gpointer) (gsize) (s))
+
+/* Provide convenience macros for handling structure
+ * fields through their offsets.
+ */
+
+#if (defined(__GNUC__)  && __GNUC__ >= 4) || defined (_MSC_VER)
+#define G_STRUCT_OFFSET(struct_type, member) \
+      ((glong) offsetof (struct_type, member))
+#else
+#define G_STRUCT_OFFSET(struct_type, member)	\
+      ((glong) ((guint8*) &((struct_type*) 0)->member))
+#endif
+
+#define G_STRUCT_MEMBER_P(struct_p, struct_offset)   \
+    ((gpointer) ((guint8*) (struct_p) + (glong) (struct_offset)))
+#define G_STRUCT_MEMBER(member_type, struct_p, struct_offset)   \
+    (*(member_type*) G_STRUCT_MEMBER_P ((struct_p), (struct_offset)))
+
+/* Provide simple macro statement wrappers:
+ *   G_STMT_START { statements; } G_STMT_END;
+ * This can be used as a single statement, like:
+ *   if (x) G_STMT_START { ... } G_STMT_END; else ...
+ * This intentionally does not use compiler extensions like GCC's '({...})' to
+ * avoid portability issue or side effects when compiled with different compilers.
+ * MSVC complains about "while(0)": C4127: "Conditional expression is constant",
+ * so we use __pragma to avoid the warning since the use here is intentional.
+ */
+#if !(defined (G_STMT_START) && defined (G_STMT_END))
+#define G_STMT_START  do
+#if defined (_MSC_VER) && (_MSC_VER >= 1500)
+#define G_STMT_END \
+    __pragma(warning(push)) \
+    __pragma(warning(disable:4127)) \
+    while(0) \
+    __pragma(warning(pop))
+#else
+#define G_STMT_END    while (0)
+#endif
+#endif
+
+/* Deprecated -- do not use. */
+#ifndef G_DISABLE_DEPRECATED
+#ifdef G_DISABLE_CONST_RETURNS
+#define G_CONST_RETURN
+#else
+#define G_CONST_RETURN const
+#endif
+#endif
+
+/*
+ * The G_LIKELY and G_UNLIKELY macros let the programmer give hints to 
+ * the compiler about the expected result of an expression. Some compilers
+ * can use this information for optimizations.
+ *
+ * The _G_BOOLEAN_EXPR macro is intended to trigger a gcc warning when
+ * putting assignments in g_return_if_fail ().  
+ */
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _G_BOOLEAN_EXPR(expr)                   \
+ G_GNUC_EXTENSION ({                            \
+   int _g_boolean_var_;                         \
+   if (expr)                                    \
+      _g_boolean_var_ = 1;                      \
+   else                                         \
+      _g_boolean_var_ = 0;                      \
+   _g_boolean_var_;                             \
+})
+#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR((expr)), 1))
+#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR((expr)), 0))
+#else
+#define G_LIKELY(expr) (expr)
+#define G_UNLIKELY(expr) (expr)
+#endif
+
+#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
+#define G_DEPRECATED __attribute__((__deprecated__))
+#elif defined(_MSC_VER) && (_MSC_VER >= 1300)
+#define G_DEPRECATED __declspec(deprecated)
+#else
+#define G_DEPRECATED
+#endif
+
+#if    __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+#define G_DEPRECATED_FOR(f) __attribute__((__deprecated__("Use '" #f "' instead")))
+#elif defined(_MSC_FULL_VER) && (_MSC_FULL_VER > 140050320)
+#define G_DEPRECATED_FOR(f) __declspec(deprecated("is deprecated. Use '" #f "' instead"))
+#else
+#define G_DEPRECATED_FOR(f) G_DEPRECATED
+#endif
+
+#if    __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+#define G_UNAVAILABLE(maj,min) __attribute__((deprecated("Not available before " #maj "." #min)))
+#elif defined(_MSC_FULL_VER) && (_MSC_FULL_VER > 140050320)
+#define G_UNAVAILABLE(maj,min) __declspec(deprecated("is not available before " #maj "." #min))
+#else
+#define G_UNAVAILABLE(maj,min) G_DEPRECATED
+#endif
+
+#ifndef _GLIB_EXTERN
+#define _GLIB_EXTERN extern
+#endif
+
+/* These macros are used to mark deprecated functions in GLib headers,
+ * and thus have to be exposed in installed headers. But please
+ * do *not* use them in other projects. Instead, use G_DEPRECATED
+ * or define your own wrappers around it.
+ */
+
+#ifdef GLIB_DISABLE_DEPRECATION_WARNINGS
+#define GLIB_DEPRECATED _GLIB_EXTERN
+#define GLIB_DEPRECATED_FOR(f) _GLIB_EXTERN
+#define GLIB_UNAVAILABLE(maj,min) _GLIB_EXTERN
+#else
+#define GLIB_DEPRECATED G_DEPRECATED _GLIB_EXTERN
+#define GLIB_DEPRECATED_FOR(f) G_DEPRECATED_FOR(f) _GLIB_EXTERN
+#define GLIB_UNAVAILABLE(maj,min) G_UNAVAILABLE(maj,min) _GLIB_EXTERN
+#endif
+
+#ifdef __GNUC__
+
+/* these macros are private */
+#define _GLIB_AUTOPTR_FUNC_NAME(TypeName) glib_autoptr_cleanup_##TypeName
+#define _GLIB_AUTOPTR_TYPENAME(TypeName)  TypeName##_autoptr
+#define _GLIB_AUTO_FUNC_NAME(TypeName)    glib_auto_cleanup_##TypeName
+#define _GLIB_CLEANUP(func)               __attribute__((cleanup(func)))
+#define _GLIB_DEFINE_AUTOPTR_CHAINUP(ModuleObjName, ParentName) \
+  typedef ModuleObjName *_GLIB_AUTOPTR_TYPENAME(ModuleObjName);                                          \
+  static inline void _GLIB_AUTOPTR_FUNC_NAME(ModuleObjName) (ModuleObjName **_ptr) {                     \
+    _GLIB_AUTOPTR_FUNC_NAME(ParentName) ((ParentName **) _ptr); }                                        \
+
+
+/* these macros are API */
+#define G_DEFINE_AUTOPTR_CLEANUP_FUNC(TypeName, func) \
+  typedef TypeName *_GLIB_AUTOPTR_TYPENAME(TypeName);                                                           \
+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS                                                                              \
+  static inline void _GLIB_AUTOPTR_FUNC_NAME(TypeName) (TypeName **_ptr) { if (*_ptr) (func) (*_ptr); }         \
+  G_GNUC_END_IGNORE_DEPRECATIONS
+#define G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(TypeName, func) \
+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS                                                                              \
+  static inline void _GLIB_AUTO_FUNC_NAME(TypeName) (TypeName *_ptr) { (func) (_ptr); }                         \
+  G_GNUC_END_IGNORE_DEPRECATIONS
+#define G_DEFINE_AUTO_CLEANUP_FREE_FUNC(TypeName, func, none) \
+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS                                                                              \
+  static inline void _GLIB_AUTO_FUNC_NAME(TypeName) (TypeName *_ptr) { if (*_ptr != none) (func) (*_ptr); }     \
+  G_GNUC_END_IGNORE_DEPRECATIONS
+#define g_autoptr(TypeName) _GLIB_CLEANUP(_GLIB_AUTOPTR_FUNC_NAME(TypeName)) _GLIB_AUTOPTR_TYPENAME(TypeName)
+#define g_auto(TypeName) _GLIB_CLEANUP(_GLIB_AUTO_FUNC_NAME(TypeName)) TypeName
+#define g_autofree _GLIB_CLEANUP(g_autoptr_cleanup_generic_gfree)
+
+#else /* not GNU C */
+/* this (dummy) macro is private */
+#define _GLIB_DEFINE_AUTOPTR_CHAINUP(ModuleObjName, ParentName)
+
+/* these (dummy) macros are API */
+#define G_DEFINE_AUTOPTR_CLEANUP_FUNC(TypeName, func)
+#define G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(TypeName, func)
+#define G_DEFINE_AUTO_CLEANUP_FREE_FUNC(TypeName, func, none)
+
+/* no declaration of g_auto() or g_autoptr() here */
+#endif
+
+#endif /* __G_MACROS_H__ */
diff -urN glib-2.51.0.org/glib/gstdio.c glib-2.51.0/glib/gstdio.c
--- glib-2.51.0.org/glib/gstdio.c	2016-10-22 07:21:56.000000000 +0200
+++ glib-2.51.0/glib/gstdio.c	2016-10-28 22:58:56.880556662 +0200
@@ -195,6 +195,11 @@
 	int          mode)
 {
 #ifdef G_OS_WIN32
+  HANDLE hFile;
+  DWORD  dwDesiredAccess       = 0;
+  DWORD  dwFlagsAndAttributes  = 0;
+  DWORD  dwDisposition         = OPEN_EXISTING;
+  DWORD  dwSharedAccess        = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
   int retval;
   int save_errno;
@@ -205,12 +210,114 @@
       return -1;
     }
 
-  retval = _wopen (wfilename, flags, mode);
-  save_errno = errno;
+  /* Set up the access modes and other attributes */
+  if ((flags & _O_CREAT) && (mode & _S_IREAD))
+  {
+    if (! (mode & _S_IWRITE))
+      dwFlagsAndAttributes  = FILE_ATTRIBUTE_READONLY; /* Sets file to 'read only' after the file gets closed */
+  }
+  if ( !(flags & _O_ACCMODE))
+  {
+    /* Equates to _O_RDONLY */
+    if (flags & _O_TRUNC)
+    {
+      errno = EINVAL;
+      g_free (wfilename);
+      return -1;
+    }
 
-  g_free (wfilename);
+    dwDesiredAccess |= GENERIC_READ;
+    dwSharedAccess  |= FILE_SHARE_WRITE;
+  }
+  if (flags & _O_WRONLY)
+  {
+    if (flags & _O_RDWR)
+    {
+      errno = EINVAL;
+      g_free (wfilename);
+      return -1;
+    }
 
+    dwDesiredAccess |= GENERIC_WRITE;
+  }
+  if (flags & _O_RDWR)
+  {
+    dwDesiredAccess |= GENERIC_READ;
+    dwDesiredAccess |= GENERIC_WRITE;
+  }
+  if (flags & _O_TRUNC)
+  {
+    if (flags & _O_CREAT)
+      dwDisposition = CREATE_ALWAYS;
+    else
+      dwDisposition = TRUNCATE_EXISTING;
+  }
+  if ((flags & _O_CREAT) && !(flags & _O_TRUNC))
+  {
+    if (flags & _O_EXCL)
+      dwDisposition = CREATE_NEW;
+    else
+      dwDisposition = OPEN_ALWAYS;
+  }
+  if (flags & _O_CREAT)
+  {
+    /* Handle the other flags that can be attached to _O_CREAT */
+    if ((flags & _O_TEMPORARY) || (flags & _O_SHORT_LIVED))
+      dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY;
+
+    if (flags & _O_TEMPORARY)
+      dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
+  }
+  if ((flags & _O_SEQUENTIAL) || (flags & _O_APPEND))
+  {
+    dwFlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
+  }
+  else if (flags & _O_RANDOM)
+  {
+    dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
+  }
+
+  if (0 == dwFlagsAndAttributes)
+    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
+  hFile = CreateFileW(wfilename, dwDesiredAccess, dwSharedAccess, NULL, dwDisposition, dwFlagsAndAttributes, NULL);
+
+  if (INVALID_HANDLE_VALUE == hFile)
+  {
+    retval = (-1);
+
+    switch (GetLastError ())
+    {
+#define CASE(a,b) case ERROR_##a: errno = b; break
+      CASE (FILE_NOT_FOUND, ENOENT);
+      CASE (PATH_NOT_FOUND, ENOENT);
+      CASE (ACCESS_DENIED, EACCES);
+      CASE (NOT_SAME_DEVICE, EXDEV);
+      CASE (LOCK_VIOLATION, EACCES);
+      CASE (SHARING_VIOLATION, EACCES);
+      CASE (FILE_EXISTS, EEXIST);
+      CASE (ALREADY_EXISTS, EEXIST);
+#undef CASE
+      default: errno = EIO;
+    }
+  }
+  else
+    retval = _open_osfhandle((long)hFile, flags);
+
+  if ((-1) != retval)
+  {
+    /* We have a valid file handle. Set its translation mode to text or binary, as appropriate */
+    if ((!(flags & _O_TEXT)) && (_fmode == _O_BINARY))
+      _setmode(retval, _O_BINARY);
+    else if ((flags & _O_TEXT) || (_fmode == _O_TEXT))
+      _setmode(retval, _O_TEXT);
+    else
+      _setmode(retval, _O_BINARY);
+  }
+
+  save_errno = errno;
+  g_free (wfilename);
   errno = save_errno;
+
   return retval;
 #else
   int fd;
@@ -258,6 +365,8 @@
 	 int          mode)
 {
 #ifdef G_OS_WIN32
+  HANDLE hFile;
+  DWORD  dwFlagsAndAttributes  = FILE_ATTRIBUTE_NORMAL;
   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
   int retval;
   int save_errno;
@@ -268,12 +377,41 @@
       return -1;
     }
 
-  retval = _wcreat (wfilename, mode);
-  save_errno = errno;
+  if (mode & _S_IREAD)
+  {
+    if (! (mode & _S_IWRITE))
+      dwFlagsAndAttributes  = FILE_ATTRIBUTE_READONLY; /* Sets file to 'read only' after the file gets closed */
+  }
+
+  hFile = CreateFileW(wfilename, (GENERIC_READ | GENERIC_WRITE), (FILE_SHARE_READ | FILE_SHARE_DELETE),
+                                  NULL, CREATE_ALWAYS, dwFlagsAndAttributes, NULL);
+
+  if (INVALID_HANDLE_VALUE == hFile)
+  {
+    retval = (-1);
+
+    switch (GetLastError ())
+    {
+#define CASE(a,b) case ERROR_##a: errno = b; break
+      CASE (FILE_NOT_FOUND, ENOENT);
+      CASE (PATH_NOT_FOUND, ENOENT);
+      CASE (ACCESS_DENIED, EACCES);
+      CASE (NOT_SAME_DEVICE, EXDEV);
+      CASE (LOCK_VIOLATION, EACCES);
+      CASE (SHARING_VIOLATION, EACCES);
+      CASE (FILE_EXISTS, EEXIST);
+      CASE (ALREADY_EXISTS, EEXIST);
+#undef CASE
+      default: errno = EIO;
+    }
+  }
+  else
+    retval = _open_osfhandle((long)hFile, _O_RDWR);
 
+  save_errno = errno;
   g_free (wfilename);
-
   errno = save_errno;
+
   return retval;
 #else
   return creat (filename, mode);
@@ -715,33 +853,102 @@
 	 const gchar *mode)
 {
 #ifdef G_OS_WIN32
-  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
-  wchar_t *wmode;
-  FILE *retval;
-  int save_errno;
-
-  if (wfilename == NULL)
-    {
-      errno = EINVAL;
-      return NULL;
-    }
-
-  wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);
-
-  if (wmode == NULL)
-    {
-      g_free (wfilename);
-      errno = EINVAL;
-      return NULL;
-    }
-
-  retval = _wfopen (wfilename, wmode);
-  save_errno = errno;
-
-  g_free (wfilename);
-  g_free (wmode);
+  int   hFile;
+  int   flags  = 0;
+  gchar priv_mode[4];
+  FILE *retval = NULL;
+
+  if ((NULL == filename) || (NULL == mode))
+  {
+    errno = EINVAL;
+    goto out;
+  }
+  if ((strlen(mode) < 1) || (strlen(mode) > 3))
+  {
+    errno = EINVAL;
+    goto out;
+  }
+
+  strncpy(priv_mode, mode, 3);
+  priv_mode[3] = '\0';
+
+  /* Set up any flags to pass to 'g_open()' */
+  if (3 == strlen(priv_mode))
+  {
+    if (('c' == priv_mode[2]) || ('n' == priv_mode[2]))
+      priv_mode[2] = '\0';
+    else
+    {
+      if (0 == strcmp(priv_mode, "a+b"))
+        flags = _O_RDWR | _O_CREAT | _O_APPEND | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "a+t"))
+        flags = _O_RDWR | _O_CREAT | _O_APPEND | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "r+b"))
+        flags = _O_RDWR | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "r+t"))
+        flags = _O_RDWR | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "w+b"))
+        flags = _O_RDWR | _O_CREAT |_O_TRUNC | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "w+t"))
+        flags = _O_RDWR | _O_CREAT |_O_TRUNC | _O_TEXT;
+      else
+      {
+        errno = EINVAL;
+        goto out;
+      }
+    }
+  }
+  if (2 == strlen(priv_mode))
+  {
+    if (('c' == priv_mode[1]) || ('n' == priv_mode[1]))
+      priv_mode[1] = '\0';
+    else
+    {
+      if (0 == strcmp(priv_mode, "a+"))
+        flags = _O_RDWR | _O_CREAT | _O_APPEND;
+      else if (0 == strcmp(priv_mode, "ab"))
+        flags = _O_WRONLY | _O_CREAT | _O_APPEND | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "at"))
+        flags = _O_WRONLY | _O_CREAT | _O_APPEND | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "rb"))
+        flags = _O_RDONLY | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "rt"))
+        flags = _O_RDONLY | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "wb"))
+        flags = _O_WRONLY | _O_CREAT | _O_TRUNC | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "wt"))
+        flags = _O_WRONLY | _O_CREAT | _O_TRUNC | _O_TEXT;
+      else
+      {
+        errno = EINVAL;
+        goto out;
+      }
+    }
+  }
+  if (1 == strlen(priv_mode))
+  {
+    if (0 == strcmp(priv_mode, "a"))
+      flags = _O_WRONLY | _O_CREAT | _O_APPEND;
+    else if (0 == strcmp(priv_mode, "r"))
+      flags = _O_RDONLY;
+    else if (0 == strcmp(priv_mode, "w"))
+      flags = _O_WRONLY | _O_CREAT | _O_TRUNC;
+    else if ( !((0 == strcmp(priv_mode, "c")) || (0 == strcmp(priv_mode, "n"))))
+    {
+      errno = EINVAL;
+      goto out;
+    }
+  }
+
+  hFile = g_open (filename, flags, (_S_IREAD | _S_IWRITE));
+
+  if (INVALID_HANDLE_VALUE == (HANDLE)hFile)
+    /* 'errno' will have already been set by 'g_open()' */
+    retval = NULL;
+  else
+    retval = _fdopen(hFile, mode);
 
-  errno = save_errno;
+out:
   return retval;
 #else
   return fopen (filename, mode);
diff -urN glib-2.51.0.org/glib/gstdio.c.orig glib-2.51.0/glib/gstdio.c.orig
--- glib-2.51.0.org/glib/gstdio.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ glib-2.51.0/glib/gstdio.c.orig	2016-10-22 07:21:56.000000000 +0200
@@ -0,0 +1,895 @@
+/* gstdio.c - wrappers for C library functions
+ *
+ * Copyright 2004 Tor Lillqvist
+ *
+ * GLib is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * GLib is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with GLib; see the file COPYING.LIB.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+#include "glibconfig.h"
+
+#define G_STDIO_NO_WRAP_ON_UNIX
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#ifdef G_OS_UNIX
+#include <unistd.h>
+#endif
+
+#ifdef G_OS_WIN32
+#include <windows.h>
+#include <errno.h>
+#include <wchar.h>
+#include <direct.h>
+#include <io.h>
+#include <sys/utime.h>
+#else
+#include <utime.h>
+#include <errno.h>
+#endif
+
+#include "gstdio.h"
+
+
+#if !defined (G_OS_UNIX) && !defined (G_OS_WIN32)
+#error Please port this to your operating system
+#endif
+
+#if defined (_MSC_VER) && !defined(_WIN64)
+#undef _wstat
+#define _wstat _wstat32
+#endif
+
+/**
+ * g_access:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @mode: as in access()
+ *
+ * A wrapper for the POSIX access() function. This function is used to
+ * test a pathname for one or several of read, write or execute
+ * permissions, or just existence.
+ *
+ * On Windows, the file protection mechanism is not at all POSIX-like,
+ * and the underlying function in the C library only checks the
+ * FAT-style READONLY attribute, and does not look at the ACL of a
+ * file at all. This function is this in practise almost useless on
+ * Windows. Software that needs to handle file permissions on Windows
+ * more exactly should use the Win32 API.
+ *
+ * See your C library manual for more details about access().
+ *
+ * Returns: zero if the pathname refers to an existing file system
+ *     object that has all the tested permissions, or -1 otherwise
+ *     or on error.
+ * 
+ * Since: 2.8
+ */
+int
+g_access (const gchar *filename,
+	  int          mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+    
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+#ifndef X_OK
+#define X_OK 1
+#endif
+
+  retval = _waccess (wfilename, mode & ~X_OK);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return access (filename, mode);
+#endif
+}
+
+/**
+ * g_chmod:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @mode: as in chmod()
+ *
+ * A wrapper for the POSIX chmod() function. The chmod() function is
+ * used to set the permissions of a file system object.
+ * 
+ * On Windows the file protection mechanism is not at all POSIX-like,
+ * and the underlying chmod() function in the C library just sets or
+ * clears the FAT-style READONLY attribute. It does not touch any
+ * ACL. Software that needs to manage file permissions on Windows
+ * exactly should use the Win32 API.
+ *
+ * See your C library manual for more details about chmod().
+ *
+ * Returns: 0 if the operation succeeded, -1 on error
+ * 
+ * Since: 2.8
+ */
+int
+g_chmod (const gchar *filename,
+	 int          mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+    
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wchmod (wfilename, mode);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return chmod (filename, mode);
+#endif
+}
+/**
+ * g_open:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @flags: as in open()
+ * @mode: as in open()
+ *
+ * A wrapper for the POSIX open() function. The open() function is
+ * used to convert a pathname into a file descriptor.
+ *
+ * On POSIX systems file descriptors are implemented by the operating
+ * system. On Windows, it's the C library that implements open() and
+ * file descriptors. The actual Win32 API for opening files is quite
+ * different, see MSDN documentation for CreateFile(). The Win32 API
+ * uses file handles, which are more randomish integers, not small
+ * integers like file descriptors.
+ *
+ * Because file descriptors are specific to the C library on Windows,
+ * the file descriptor returned by this function makes sense only to
+ * functions in the same C library. Thus if the GLib-using code uses a
+ * different C library than GLib does, the file descriptor returned by
+ * this function cannot be passed to C library functions like write()
+ * or read().
+ *
+ * See your C library manual for more details about open().
+ *
+ * Returns: a new file descriptor, or -1 if an error occurred.
+ *     The return value can be used exactly like the return value
+ *     from open().
+ * 
+ * Since: 2.6
+ */
+int
+g_open (const gchar *filename,
+	int          flags,
+	int          mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+    
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wopen (wfilename, flags, mode);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  int fd;
+  do
+    fd = open (filename, flags, mode);
+  while (G_UNLIKELY (fd == -1 && errno == EINTR));
+  return fd;
+#endif
+}
+
+/**
+ * g_creat:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @mode: as in creat()
+ *
+ * A wrapper for the POSIX creat() function. The creat() function is
+ * used to convert a pathname into a file descriptor, creating a file
+ * if necessary.
+
+ * On POSIX systems file descriptors are implemented by the operating
+ * system. On Windows, it's the C library that implements creat() and
+ * file descriptors. The actual Windows API for opening files is
+ * different, see MSDN documentation for CreateFile(). The Win32 API
+ * uses file handles, which are more randomish integers, not small
+ * integers like file descriptors.
+ *
+ * Because file descriptors are specific to the C library on Windows,
+ * the file descriptor returned by this function makes sense only to
+ * functions in the same C library. Thus if the GLib-using code uses a
+ * different C library than GLib does, the file descriptor returned by
+ * this function cannot be passed to C library functions like write()
+ * or read().
+ *
+ * See your C library manual for more details about creat().
+ *
+ * Returns: a new file descriptor, or -1 if an error occurred.
+ *     The return value can be used exactly like the return value
+ *     from creat().
+ * 
+ * Since: 2.8
+ */
+int
+g_creat (const gchar *filename,
+	 int          mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+    
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wcreat (wfilename, mode);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return creat (filename, mode);
+#endif
+}
+
+/**
+ * g_rename:
+ * @oldfilename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @newfilename: (type filename): a pathname in the GLib file name encoding
+ *
+ * A wrapper for the POSIX rename() function. The rename() function 
+ * renames a file, moving it between directories if required.
+ * 
+ * See your C library manual for more details about how rename() works
+ * on your system. It is not possible in general on Windows to rename
+ * a file that is open to some process.
+ *
+ * Returns: 0 if the renaming succeeded, -1 if an error occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_rename (const gchar *oldfilename,
+	  const gchar *newfilename)
+{
+#ifdef G_OS_WIN32
+  wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
+  wchar_t *wnewfilename;
+  int retval;
+  int save_errno = 0;
+
+  if (woldfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL);
+
+  if (wnewfilename == NULL)
+    {
+      g_free (woldfilename);
+      errno = EINVAL;
+      return -1;
+    }
+
+  if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
+    retval = 0;
+  else
+    {
+      retval = -1;
+      switch (GetLastError ())
+	{
+#define CASE(a,b) case ERROR_##a: save_errno = b; break
+	  CASE (FILE_NOT_FOUND, ENOENT);
+	  CASE (PATH_NOT_FOUND, ENOENT);
+	  CASE (ACCESS_DENIED, EACCES);
+	  CASE (NOT_SAME_DEVICE, EXDEV);
+	  CASE (LOCK_VIOLATION, EACCES);
+	  CASE (SHARING_VIOLATION, EACCES);
+	  CASE (FILE_EXISTS, EEXIST);
+	  CASE (ALREADY_EXISTS, EEXIST);
+#undef CASE
+	default: save_errno = EIO;
+	}
+    }
+
+  g_free (woldfilename);
+  g_free (wnewfilename);
+    
+  errno = save_errno;
+  return retval;
+#else
+  return rename (oldfilename, newfilename);
+#endif
+}
+
+/**
+ * g_mkdir: 
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @mode: permissions to use for the newly created directory
+ *
+ * A wrapper for the POSIX mkdir() function. The mkdir() function 
+ * attempts to create a directory with the given name and permissions.
+ * The mode argument is ignored on Windows.
+ * 
+ * See your C library manual for more details about mkdir().
+ *
+ * Returns: 0 if the directory was successfully created, -1 if an error 
+ *    occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_mkdir (const gchar *filename,
+	 int          mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wmkdir (wfilename);
+  save_errno = errno;
+
+  g_free (wfilename);
+    
+  errno = save_errno;
+  return retval;
+#else
+  return mkdir (filename, mode);
+#endif
+}
+
+/**
+ * g_chdir: 
+ * @path: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ *
+ * A wrapper for the POSIX chdir() function. The function changes the
+ * current directory of the process to @path.
+ * 
+ * See your C library manual for more details about chdir().
+ *
+ * Returns: 0 on success, -1 if an error occurred.
+ * 
+ * Since: 2.8
+ */
+int
+g_chdir (const gchar *path)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wpath = g_utf8_to_utf16 (path, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+
+  if (wpath == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wchdir (wpath);
+  save_errno = errno;
+
+  g_free (wpath);
+    
+  errno = save_errno;
+  return retval;
+#else
+  return chdir (path);
+#endif
+}
+
+/**
+ * GStatBuf:
+ *
+ * A type corresponding to the appropriate struct type for the stat()
+ * system call, depending on the platform and/or compiler being used.
+ *
+ * See g_stat() for more information.
+ */
+/**
+ * g_stat: 
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @buf: a pointer to a stat struct, which will be filled with the file
+ *     information
+ *
+ * A wrapper for the POSIX stat() function. The stat() function
+ * returns information about a file. On Windows the stat() function in
+ * the C library checks only the FAT-style READONLY attribute and does
+ * not look at the ACL at all. Thus on Windows the protection bits in
+ * the @st_mode field are a fabrication of little use.
+ * 
+ * On Windows the Microsoft C libraries have several variants of the
+ * stat struct and stat() function with names like _stat(), _stat32(),
+ * _stat32i64() and _stat64i32(). The one used here is for 32-bit code
+ * the one with 32-bit size and time fields, specifically called _stat32().
+ *
+ * In Microsoft's compiler, by default struct stat means one with
+ * 64-bit time fields while in MinGW struct stat is the legacy one
+ * with 32-bit fields. To hopefully clear up this messs, the gstdio.h
+ * header defines a type #GStatBuf which is the appropriate struct type
+ * depending on the platform and/or compiler being used. On POSIX it
+ * is just struct stat, but note that even on POSIX platforms, stat()
+ * might be a macro.
+ *
+ * See your C library manual for more details about stat().
+ *
+ * Returns: 0 if the information was successfully retrieved,
+ *     -1 if an error occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_stat (const gchar *filename,
+	GStatBuf    *buf)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+  int len;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  len = wcslen (wfilename);
+  while (len > 0 && G_IS_DIR_SEPARATOR (wfilename[len-1]))
+    len--;
+  if (len > 0 &&
+      (!g_path_is_absolute (filename) || len > g_path_skip_root (filename) - filename))
+    wfilename[len] = '\0';
+
+  retval = _wstat (wfilename, buf);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return stat (filename, buf);
+#endif
+}
+
+/**
+ * g_lstat: 
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @buf: a pointer to a stat struct, which will be filled with the file
+ *     information
+ *
+ * A wrapper for the POSIX lstat() function. The lstat() function is
+ * like stat() except that in the case of symbolic links, it returns
+ * information about the symbolic link itself and not the file that it
+ * refers to. If the system does not support symbolic links g_lstat()
+ * is identical to g_stat().
+ * 
+ * See your C library manual for more details about lstat().
+ *
+ * Returns: 0 if the information was successfully retrieved,
+ *     -1 if an error occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_lstat (const gchar *filename,
+	 GStatBuf    *buf)
+{
+#ifdef HAVE_LSTAT
+  /* This can't be Win32, so don't do the widechar dance. */
+  return lstat (filename, buf);
+#else
+  return g_stat (filename, buf);
+#endif
+}
+
+/**
+ * g_unlink:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ *
+ * A wrapper for the POSIX unlink() function. The unlink() function 
+ * deletes a name from the filesystem. If this was the last link to the 
+ * file and no processes have it opened, the diskspace occupied by the
+ * file is freed.
+ * 
+ * See your C library manual for more details about unlink(). Note
+ * that on Windows, it is in general not possible to delete files that
+ * are open to some process, or mapped into memory.
+ *
+ * Returns: 0 if the name was successfully deleted, -1 if an error 
+ *    occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_unlink (const gchar *filename)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wunlink (wfilename);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return unlink (filename);
+#endif
+}
+
+/**
+ * g_remove:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ *
+ * A wrapper for the POSIX remove() function. The remove() function
+ * deletes a name from the filesystem.
+ * 
+ * See your C library manual for more details about how remove() works
+ * on your system. On Unix, remove() removes also directories, as it
+ * calls unlink() for files and rmdir() for directories. On Windows,
+ * although remove() in the C library only works for files, this
+ * function tries first remove() and then if that fails rmdir(), and
+ * thus works for both files and directories. Note however, that on
+ * Windows, it is in general not possible to remove a file that is
+ * open to some process, or mapped into memory.
+ *
+ * If this function fails on Windows you can't infer too much from the
+ * errno value. rmdir() is tried regardless of what caused remove() to
+ * fail. Any errno value set by remove() will be overwritten by that
+ * set by rmdir().
+ *
+ * Returns: 0 if the file was successfully removed, -1 if an error 
+ *    occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_remove (const gchar *filename)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  retval = _wremove (wfilename);
+  if (retval == -1)
+    retval = _wrmdir (wfilename);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return remove (filename);
+#endif
+}
+
+/**
+ * g_rmdir:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ *
+ * A wrapper for the POSIX rmdir() function. The rmdir() function
+ * deletes a directory from the filesystem.
+ * 
+ * See your C library manual for more details about how rmdir() works
+ * on your system.
+ *
+ * Returns: 0 if the directory was successfully removed, -1 if an error 
+ *    occurred
+ * 
+ * Since: 2.6
+ */
+int
+g_rmdir (const gchar *filename)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  
+  retval = _wrmdir (wfilename);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return rmdir (filename);
+#endif
+}
+
+/**
+ * g_fopen:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @mode: a string describing the mode in which the file should be opened
+ *
+ * A wrapper for the stdio fopen() function. The fopen() function
+ * opens a file and associates a new stream with it.
+ * 
+ * Because file descriptors are specific to the C library on Windows,
+ * and a file descriptor is part of the FILE struct, the FILE* returned
+ * by this function makes sense only to functions in the same C library.
+ * Thus if the GLib-using code uses a different C library than GLib does,
+ * the FILE* returned by this function cannot be passed to C library
+ * functions like fprintf() or fread().
+ *
+ * See your C library manual for more details about fopen().
+ *
+ * Returns: A FILE* if the file was successfully opened, or %NULL if
+ *     an error occurred
+ * 
+ * Since: 2.6
+ */
+FILE *
+g_fopen (const gchar *filename,
+	 const gchar *mode)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  wchar_t *wmode;
+  FILE *retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return NULL;
+    }
+
+  wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);
+
+  if (wmode == NULL)
+    {
+      g_free (wfilename);
+      errno = EINVAL;
+      return NULL;
+    }
+
+  retval = _wfopen (wfilename, wmode);
+  save_errno = errno;
+
+  g_free (wfilename);
+  g_free (wmode);
+
+  errno = save_errno;
+  return retval;
+#else
+  return fopen (filename, mode);
+#endif
+}
+
+/**
+ * g_freopen:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @mode: a string describing the mode in which the file should be  opened
+ * @stream: (allow-none): an existing stream which will be reused, or %NULL
+ *
+ * A wrapper for the POSIX freopen() function. The freopen() function
+ * opens a file and associates it with an existing stream.
+ * 
+ * See your C library manual for more details about freopen().
+ *
+ * Returns: A FILE* if the file was successfully opened, or %NULL if
+ *     an error occurred.
+ * 
+ * Since: 2.6
+ */
+FILE *
+g_freopen (const gchar *filename,
+	   const gchar *mode,
+	   FILE        *stream)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  wchar_t *wmode;
+  FILE *retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return NULL;
+    }
+  
+  wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);
+
+  if (wmode == NULL)
+    {
+      g_free (wfilename);
+      errno = EINVAL;
+      return NULL;
+    }
+  
+  retval = _wfreopen (wfilename, wmode, stream);
+  save_errno = errno;
+
+  g_free (wfilename);
+  g_free (wmode);
+
+  errno = save_errno;
+  return retval;
+#else
+  return freopen (filename, mode, stream);
+#endif
+}
+
+/**
+ * g_utime:
+ * @filename: (type filename): a pathname in the GLib file name encoding
+ *     (UTF-8 on Windows)
+ * @utb: a pointer to a struct utimbuf.
+ *
+ * A wrapper for the POSIX utime() function. The utime() function
+ * sets the access and modification timestamps of a file.
+ * 
+ * See your C library manual for more details about how utime() works
+ * on your system.
+ *
+ * Returns: 0 if the operation was successful, -1 if an error occurred
+ * 
+ * Since: 2.18
+ */
+int
+g_utime (const gchar    *filename,
+	 struct utimbuf *utb)
+{
+#ifdef G_OS_WIN32
+  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
+  int retval;
+  int save_errno;
+
+  if (wfilename == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  
+  retval = _wutime (wfilename, (struct _utimbuf*) utb);
+  save_errno = errno;
+
+  g_free (wfilename);
+
+  errno = save_errno;
+  return retval;
+#else
+  return utime (filename, utb);
+#endif
+}
+
+/**
+ * g_close:
+ * @fd: A file descriptor
+ * @error: a #GError
+ *
+ * This wraps the close() call; in case of error, %errno will be
+ * preserved, but the error will also be stored as a #GError in @error.
+ *
+ * Besides using #GError, there is another major reason to prefer this
+ * function over the call provided by the system; on Unix, it will
+ * attempt to correctly handle %EINTR, which has platform-specific
+ * semantics.
+ *
+ * Returns: %TRUE on success, %FALSE if there was an error.
+ *
+ * Since: 2.36
+ */
+gboolean
+g_close (gint       fd,
+         GError   **error)
+{
+  int res;
+  res = close (fd);
+  /* Just ignore EINTR for now; a retry loop is the wrong thing to do
+   * on Linux at least.  Anyone who wants to add a conditional check
+   * for e.g. HP-UX is welcome to do so later...
+   *
+   * http://lkml.indiana.edu/hypermail/linux/kernel/0509.1/0877.html
+   * https://bugzilla.gnome.org/show_bug.cgi?id=682819
+   * http://utcc.utoronto.ca/~cks/space/blog/unix/CloseEINTR
+   * https://sites.google.com/site/michaelsafyan/software-engineering/checkforeintrwheninvokingclosethinkagain
+   */
+  if (G_UNLIKELY (res == -1 && errno == EINTR))
+    return TRUE;
+  else if (res == -1)
+    {
+      int errsv = errno;
+      g_set_error_literal (error, G_FILE_ERROR,
+                           g_file_error_from_errno (errsv),
+                           g_strerror (errsv));
+      errno = errsv;
+      return FALSE;
+    }
+  return TRUE;
+}
+
diff -urN glib-2.51.0.org/glib/tests/test-printf.c glib-2.51.0/glib/tests/test-printf.c
--- glib-2.51.0.org/glib/tests/test-printf.c	2016-10-22 07:21:40.000000000 +0200
+++ glib-2.51.0/glib/tests/test-printf.c	2016-10-28 22:58:56.887556607 +0200
@@ -24,6 +24,9 @@
 #include <string.h>
 #include "glib.h"
 #include "gstdio.h"
+#ifdef G_OS_WIN32
+#include <fcntl.h>
+#endif
 
 static void
 test_retval_and_trunc (void)
@@ -907,6 +910,9 @@
 main (int   argc,
       char *argv[])
 {
+#ifdef G_OS_WIN32
+  _setmode (fileno (stdout), _O_BINARY);
+#endif
   g_test_init (&argc, &argv, NULL);
 
   g_test_add_func ("/snprintf/retval-and-trunc", test_retval_and_trunc);
diff -urN glib-2.51.0.org/gobject/gtype.c glib-2.51.0/gobject/gtype.c
--- glib-2.51.0.org/gobject/gtype.c	2016-10-22 07:22:20.000000000 +0200
+++ glib-2.51.0/gobject/gtype.c	2016-10-28 22:58:56.883556639 +0200
@@ -4450,7 +4450,7 @@
   _g_signal_init ();
 }
 
-#if defined (G_OS_WIN32)
+#if defined (G_OS_WIN32) && defined (DLL_EXPORT)
 
 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
diff -urN glib-2.51.0.org/gobject/gtype.c.orig glib-2.51.0/gobject/gtype.c.orig
--- glib-2.51.0.org/gobject/gtype.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ glib-2.51.0/gobject/gtype.c.orig	2016-10-22 07:22:20.000000000 +0200
@@ -0,0 +1,4902 @@
+/* GObject - GLib Type, Object, Parameter and Signal Library
+ * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * MT safe
+ */
+
+#include "config.h"
+
+#include "../glib/valgrind.h"
+#include <string.h>
+
+#include "gtype.h"
+#include "gtype-private.h"
+#include "gtypeplugin.h"
+#include "gvaluecollector.h"
+#include "gatomicarray.h"
+#include "gobject_trace.h"
+
+#include "glib-private.h"
+#include "gconstructor.h"
+
+#ifdef G_OS_WIN32
+#include <windows.h>
+#endif
+
+#ifdef	G_ENABLE_DEBUG
+#define	IF_DEBUG(debug_type)	if (_g_type_debug_flags & G_TYPE_DEBUG_ ## debug_type)
+#endif
+
+/**
+ * SECTION:gtype
+ * @short_description: The GLib Runtime type identification and
+ *     management system
+ * @title:Type Information
+ *
+ * The GType API is the foundation of the GObject system.  It provides the
+ * facilities for registering and managing all fundamental data types,
+ * user-defined object and interface types.
+ *
+ * For type creation and registration purposes, all types fall into one of
+ * two categories: static or dynamic.  Static types are never loaded or
+ * unloaded at run-time as dynamic types may be.  Static types are created
+ * with g_type_register_static() that gets type specific information passed
+ * in via a #GTypeInfo structure.
+ *
+ * Dynamic types are created with g_type_register_dynamic() which takes a
+ * #GTypePlugin structure instead. The remaining type information (the
+ * #GTypeInfo structure) is retrieved during runtime through #GTypePlugin
+ * and the g_type_plugin_*() API.
+ *
+ * These registration functions are usually called only once from a
+ * function whose only purpose is to return the type identifier for a
+ * specific class.  Once the type (or class or interface) is registered,
+ * it may be instantiated, inherited, or implemented depending on exactly
+ * what sort of type it is.
+ *
+ * There is also a third registration function for registering fundamental
+ * types called g_type_register_fundamental() which requires both a #GTypeInfo
+ * structure and a #GTypeFundamentalInfo structure but it is seldom used
+ * since most fundamental types are predefined rather than user-defined.
+ *
+ * Type instance and class structs are limited to a total of 64 KiB,
+ * including all parent types. Similarly, type instances' private data
+ * (as created by g_type_class_add_private()) are limited to a total of
+ * 64 KiB. If a type instance needs a large static buffer, allocate it
+ * separately (typically by using #GArray or #GPtrArray) and put a pointer
+ * to the buffer in the structure.
+ *
+ * As mentioned in the [GType conventions][gtype-conventions], type names must
+ * be at least three characters long. There is no upper length limit. The first
+ * character must be a letter (az or AZ) or an underscore (_). Subsequent
+ * characters can be letters, numbers or any of -_+.
+ */
+
+
+/* NOTE: some functions (some internal variants and exported ones)
+ * invalidate data portions of the TypeNodes. if external functions/callbacks
+ * are called, pointers to memory maintained by TypeNodes have to be looked up
+ * again. this affects most of the struct TypeNode fields, e.g. ->children or
+ * CLASSED_NODE_IFACES_ENTRIES() respectively IFACE_NODE_PREREQUISITES() (but
+ * not ->supers[]), as all those memory portions can get realloc()ed during
+ * callback invocation.
+ *
+ * LOCKING:
+ * lock handling issues when calling static functions are indicated by
+ * uppercase letter postfixes, all static functions have to have
+ * one of the below postfixes:
+ * - _I:	[Indifferent about locking]
+ *   function doesn't care about locks at all
+ * - _U:	[Unlocked invocation]
+ *   no read or write lock has to be held across function invocation
+ *   (locks may be acquired and released during invocation though)
+ * - _L:	[Locked invocation]
+ *   a write lock or more than 0 read locks have to be held across
+ *   function invocation
+ * - _W:	[Write-locked invocation]
+ *   a write lock has to be held across function invocation
+ * - _Wm:	[Write-locked invocation, mutatable]
+ *   like _W, but the write lock might be released and reacquired
+ *   during invocation, watch your pointers
+ * - _WmREC:    [Write-locked invocation, mutatable, recursive]
+ *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
+ */
+
+#ifdef LOCK_DEBUG
+#define G_READ_LOCK(rw_lock)    do { g_printerr (G_STRLOC ": readL++\n"); g_rw_lock_reader_lock (rw_lock); } while (0)
+#define G_READ_UNLOCK(rw_lock)  do { g_printerr (G_STRLOC ": readL--\n"); g_rw_lock_reader_unlock (rw_lock); } while (0)
+#define G_WRITE_LOCK(rw_lock)   do { g_printerr (G_STRLOC ": writeL++\n"); g_rw_lock_writer_lock (rw_lock); } while (0)
+#define G_WRITE_UNLOCK(rw_lock) do { g_printerr (G_STRLOC ": writeL--\n"); g_rw_lock_writer_unlock (rw_lock); } while (0)
+#else
+#define G_READ_LOCK(rw_lock)    g_rw_lock_reader_lock (rw_lock)
+#define G_READ_UNLOCK(rw_lock)  g_rw_lock_reader_unlock (rw_lock)
+#define G_WRITE_LOCK(rw_lock)   g_rw_lock_writer_lock (rw_lock)
+#define G_WRITE_UNLOCK(rw_lock) g_rw_lock_writer_unlock (rw_lock)
+#endif
+#define	INVALID_RECURSION(func, arg, type_name) G_STMT_START{ \
+    static const gchar _action[] = " invalidly modified type ";  \
+    gpointer _arg = (gpointer) (arg); const gchar *_tname = (type_name), *_fname = (func); \
+    if (_arg) \
+      g_error ("%s(%p)%s'%s'", _fname, _arg, _action, _tname); \
+    else \
+      g_error ("%s()%s'%s'", _fname, _action, _tname); \
+}G_STMT_END
+#define g_assert_type_system_initialized() \
+  g_assert (static_quark_type_flags)
+
+#define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
+				    G_TYPE_FLAG_INSTANTIATABLE | \
+				    G_TYPE_FLAG_DERIVABLE | \
+				    G_TYPE_FLAG_DEEP_DERIVABLE)
+#define	TYPE_FLAG_MASK		   (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)
+#define	SIZEOF_FUNDAMENTAL_INFO	   ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
+						       sizeof (gpointer)), \
+                                                  sizeof (glong)))
+
+/* The 2*sizeof(size_t) alignment here is borrowed from
+ * GNU libc, so it should be good most everywhere.
+ * It is more conservative than is needed on some 64-bit
+ * platforms, but ia64 does require a 16-byte alignment.
+ * The SIMD extensions for x86 and ppc32 would want a
+ * larger alignment than this, but we don't need to
+ * do better than malloc.
+ */
+#define STRUCT_ALIGNMENT (2 * sizeof (gsize))
+#define ALIGN_STRUCT(offset) \
+      ((offset + (STRUCT_ALIGNMENT - 1)) & -STRUCT_ALIGNMENT)
+
+
+/* --- typedefs --- */
+typedef struct _TypeNode        TypeNode;
+typedef struct _CommonData      CommonData;
+typedef struct _BoxedData       BoxedData;
+typedef struct _IFaceData       IFaceData;
+typedef struct _ClassData       ClassData;
+typedef struct _InstanceData    InstanceData;
+typedef union  _TypeData        TypeData;
+typedef struct _IFaceEntries    IFaceEntries;
+typedef struct _IFaceEntry      IFaceEntry;
+typedef struct _IFaceHolder	IFaceHolder;
+
+
+/* --- prototypes --- */
+static inline GTypeFundamentalInfo*	type_node_fundamental_info_I	(TypeNode		*node);
+static	      void			type_add_flags_W		(TypeNode		*node,
+									 GTypeFlags		 flags);
+static	      void			type_data_make_W		(TypeNode		*node,
+									 const GTypeInfo	*info,
+									 const GTypeValueTable	*value_table);
+static inline void			type_data_ref_Wm		(TypeNode		*node);
+static inline void			type_data_unref_U               (TypeNode		*node,
+									 gboolean		 uncached);
+static void				type_data_last_unref_Wm		(TypeNode *              node,
+									 gboolean		 uncached);
+static inline gpointer			type_get_qdata_L		(TypeNode		*node,
+									 GQuark			 quark);
+static inline void			type_set_qdata_W		(TypeNode		*node,
+									 GQuark			 quark,
+									 gpointer		 data);
+static IFaceHolder*			type_iface_peek_holder_L	(TypeNode		*iface,
+									 GType			 instance_type);
+static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
+                                                                         TypeNode               *node);
+static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
+                                                                         TypeNode               *node);
+static gboolean				type_node_is_a_L		(TypeNode		*node,
+									 TypeNode		*iface_node);
+
+
+/* --- enumeration --- */
+
+/* The InitState enumeration is used to track the progress of initializing
+ * both classes and interface vtables. Keeping the state of initialization
+ * is necessary to handle new interfaces being added while we are initializing
+ * the class or other interfaces.
+ */
+typedef enum
+{
+  UNINITIALIZED,
+  BASE_CLASS_INIT,
+  BASE_IFACE_INIT,
+  CLASS_INIT,
+  IFACE_INIT,
+  INITIALIZED
+} InitState;
+
+/* --- structures --- */
+struct _TypeNode
+{
+  guint volatile ref_count;
+#ifdef G_ENABLE_DEBUG
+  guint volatile instance_count;
+#endif
+  GTypePlugin *plugin;
+  guint        n_children; /* writable with lock */
+  guint        n_supers : 8;
+  guint        n_prerequisites : 9;
+  guint        is_classed : 1;
+  guint        is_instantiatable : 1;
+  guint        mutatable_check_cache : 1;	/* combines some common path checks */
+  GType       *children; /* writable with lock */
+  TypeData * volatile data;
+  GQuark       qname;
+  GData       *global_gdata;
+  union {
+    GAtomicArray iface_entries;		/* for !iface types */
+    GAtomicArray offsets;
+  } _prot;
+  GType       *prerequisites;
+  GType        supers[1]; /* flexible array */
+};
+
+#define SIZEOF_BASE_TYPE_NODE()			(G_STRUCT_OFFSET (TypeNode, supers))
+#define MAX_N_SUPERS				(255)
+#define MAX_N_CHILDREN				(G_MAXUINT)
+#define	MAX_N_INTERFACES			(255) /* Limited by offsets being 8 bits */
+#define	MAX_N_PREREQUISITES			(511)
+#define NODE_TYPE(node)				(node->supers[0])
+#define NODE_PARENT_TYPE(node)			(node->supers[1])
+#define NODE_FUNDAMENTAL_TYPE(node)		(node->supers[node->n_supers])
+#define NODE_NAME(node)				(g_quark_to_string (node->qname))
+#define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &(node)->ref_count))
+#define	NODE_IS_BOXED(node)			(NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)
+#define	NODE_IS_IFACE(node)			(NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)
+#define	CLASSED_NODE_IFACES_ENTRIES(node)	(&(node)->_prot.iface_entries)
+#define	CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
+#define	IFACE_NODE_N_PREREQUISITES(node)	((node)->n_prerequisites)
+#define	IFACE_NODE_PREREQUISITES(node)		((node)->prerequisites)
+#define	iface_node_get_holders_L(node)		((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))
+#define	iface_node_set_holders_W(node, holders)	(type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
+#define	iface_node_get_dependants_array_L(n)	((GType*) type_get_qdata_L ((n), static_quark_dependants_array))
+#define	iface_node_set_dependants_array_W(n,d)	(type_set_qdata_W ((n), static_quark_dependants_array, (d)))
+#define	TYPE_ID_MASK				((GType) ((1 << G_TYPE_FUNDAMENTAL_SHIFT) - 1))
+
+#define NODE_IS_ANCESTOR(ancestor, node)                                                    \
+        ((ancestor)->n_supers <= (node)->n_supers &&                                        \
+	 (node)->supers[(node)->n_supers - (ancestor)->n_supers] == NODE_TYPE (ancestor))
+
+struct _IFaceHolder
+{
+  GType           instance_type;
+  GInterfaceInfo *info;
+  GTypePlugin    *plugin;
+  IFaceHolder    *next;
+};
+
+struct _IFaceEntry
+{
+  GType           iface_type;
+  GTypeInterface *vtable;
+  InitState       init_state;
+};
+
+struct _IFaceEntries {
+  guint offset_index;
+  IFaceEntry entry[1];
+};
+
+#define IFACE_ENTRIES_HEADER_SIZE (sizeof(IFaceEntries) - sizeof(IFaceEntry))
+#define IFACE_ENTRIES_N_ENTRIES(_entries) ( (G_ATOMIC_ARRAY_DATA_SIZE((_entries)) - IFACE_ENTRIES_HEADER_SIZE) / sizeof(IFaceEntry) )
+
+struct _CommonData
+{
+  GTypeValueTable  *value_table;
+};
+
+struct _BoxedData
+{
+  CommonData         data;
+  GBoxedCopyFunc     copy_func;
+  GBoxedFreeFunc     free_func;
+};
+
+struct _IFaceData
+{
+  CommonData         common;
+  guint16            vtable_size;
+  GBaseInitFunc      vtable_init_base;
+  GBaseFinalizeFunc  vtable_finalize_base;
+  GClassInitFunc     dflt_init;
+  GClassFinalizeFunc dflt_finalize;
+  gconstpointer      dflt_data;
+  gpointer           dflt_vtable;
+};
+
+struct _ClassData
+{
+  CommonData         common;
+  guint16            class_size;
+  guint16            class_private_size;
+  int volatile       init_state; /* atomic - g_type_class_ref reads it unlocked */
+  GBaseInitFunc      class_init_base;
+  GBaseFinalizeFunc  class_finalize_base;
+  GClassInitFunc     class_init;
+  GClassFinalizeFunc class_finalize;
+  gconstpointer      class_data;
+  gpointer           class;
+};
+
+struct _InstanceData
+{
+  CommonData         common;
+  guint16            class_size;
+  guint16            class_private_size;
+  int volatile       init_state; /* atomic - g_type_class_ref reads it unlocked */
+  GBaseInitFunc      class_init_base;
+  GBaseFinalizeFunc  class_finalize_base;
+  GClassInitFunc     class_init;
+  GClassFinalizeFunc class_finalize;
+  gconstpointer      class_data;
+  gpointer           class;
+  guint16            instance_size;
+  guint16            private_size;
+  guint16            n_preallocs;
+  GInstanceInitFunc  instance_init;
+};
+
+union _TypeData
+{
+  CommonData         common;
+  BoxedData          boxed;
+  IFaceData          iface;
+  ClassData          class;
+  InstanceData       instance;
+};
+
+typedef struct {
+  gpointer            cache_data;
+  GTypeClassCacheFunc cache_func;
+} ClassCacheFunc;
+
+typedef struct {
+  gpointer                check_data;
+  GTypeInterfaceCheckFunc check_func;
+} IFaceCheckFunc;
+
+
+/* --- variables --- */
+static GRWLock         type_rw_lock;
+static GRecMutex       class_init_rec_mutex;
+static guint           static_n_class_cache_funcs = 0;
+static ClassCacheFunc *static_class_cache_funcs = NULL;
+static guint           static_n_iface_check_funcs = 0;
+static IFaceCheckFunc *static_iface_check_funcs = NULL;
+static GQuark          static_quark_type_flags = 0;
+static GQuark          static_quark_iface_holder = 0;
+static GQuark          static_quark_dependants_array = 0;
+static guint           type_registration_serial = 0;
+GTypeDebugFlags	       _g_type_debug_flags = 0;
+
+/* --- type nodes --- */
+static GHashTable       *static_type_nodes_ht = NULL;
+static TypeNode		*static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX >> G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };
+static GType		 static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;
+
+static inline TypeNode*
+lookup_type_node_I (GType utype)
+{
+  if (utype > G_TYPE_FUNDAMENTAL_MAX)
+    return (TypeNode*) (utype & ~TYPE_ID_MASK);
+  else
+    return static_fundamental_type_nodes[utype >> G_TYPE_FUNDAMENTAL_SHIFT];
+}
+
+/**
+ * g_type_get_type_registration_serial:
+ *
+ * Returns an opaque serial number that represents the state of the set
+ * of registered types. Any time a type is registered this serial changes,
+ * which means you can cache information based on type lookups (such as
+ * g_type_from_name()) and know if the cache is still valid at a later
+ * time by comparing the current serial with the one at the type lookup.
+ *
+ * Since: 2.36
+ *
+ * Returns: An unsigned int, representing the state of type registrations
+ */
+guint
+g_type_get_type_registration_serial (void)
+{
+  return (guint)g_atomic_int_get ((gint *)&type_registration_serial);
+}
+
+static TypeNode*
+type_node_any_new_W (TypeNode             *pnode,
+		     GType                 ftype,
+		     const gchar          *name,
+		     GTypePlugin          *plugin,
+		     GTypeFundamentalFlags type_flags)
+{
+  guint n_supers;
+  GType type;
+  TypeNode *node;
+  guint i, node_size = 0;
+
+  n_supers = pnode ? pnode->n_supers + 1 : 0;
+  
+  if (!pnode)
+    node_size += SIZEOF_FUNDAMENTAL_INFO;	      /* fundamental type info */
+  node_size += SIZEOF_BASE_TYPE_NODE ();	      /* TypeNode structure */
+  node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for ->supers[] */
+  node = g_malloc0 (node_size);
+  if (!pnode)					      /* offset fundamental types */
+    {
+      node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
+      static_fundamental_type_nodes[ftype >> G_TYPE_FUNDAMENTAL_SHIFT] = node;
+      type = ftype;
+    }
+  else
+    type = (GType) node;
+  
+  g_assert ((type & TYPE_ID_MASK) == 0);
+  
+  node->n_supers = n_supers;
+  if (!pnode)
+    {
+      node->supers[0] = type;
+      node->supers[1] = 0;
+      
+      node->is_classed = (type_flags & G_TYPE_FLAG_CLASSED) != 0;
+      node->is_instantiatable = (type_flags & G_TYPE_FLAG_INSTANTIATABLE) != 0;
+      
+      if (NODE_IS_IFACE (node))
+	{
+          IFACE_NODE_N_PREREQUISITES (node) = 0;
+	  IFACE_NODE_PREREQUISITES (node) = NULL;
+	}
+      else
+	_g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));
+    }
+  else
+    {
+      node->supers[0] = type;
+      memcpy (node->supers + 1, pnode->supers, sizeof (GType) * (1 + pnode->n_supers + 1));
+      
+      node->is_classed = pnode->is_classed;
+      node->is_instantiatable = pnode->is_instantiatable;
+      
+      if (NODE_IS_IFACE (node))
+	{
+	  IFACE_NODE_N_PREREQUISITES (node) = 0;
+	  IFACE_NODE_PREREQUISITES (node) = NULL;
+	}
+      else
+	{
+	  guint j;
+	  IFaceEntries *entries;
+
+	  entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),
+					  IFACE_ENTRIES_HEADER_SIZE,
+					  0);
+	  if (entries)
+	    {
+	      for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (entries); j++)
+		{
+		  entries->entry[j].vtable = NULL;
+		  entries->entry[j].init_state = UNINITIALIZED;
+		}
+	      _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),
+				      entries);
+	    }
+	}
+
+      i = pnode->n_children++;
+      pnode->children = g_renew (GType, pnode->children, pnode->n_children);
+      pnode->children[i] = type;
+    }
+
+  TRACE(GOBJECT_TYPE_NEW(name, node->supers[1], type));
+
+  node->plugin = plugin;
+  node->n_children = 0;
+  node->children = NULL;
+  node->data = NULL;
+  node->qname = g_quark_from_string (name);
+  node->global_gdata = NULL;
+  g_hash_table_insert (static_type_nodes_ht,
+		       (gpointer) g_quark_to_string (node->qname),
+		       (gpointer) type);
+
+  g_atomic_int_inc ((gint *)&type_registration_serial);
+
+  return node;
+}
+
+static inline GTypeFundamentalInfo*
+type_node_fundamental_info_I (TypeNode *node)
+{
+  GType ftype = NODE_FUNDAMENTAL_TYPE (node);
+  
+  if (ftype != NODE_TYPE (node))
+    node = lookup_type_node_I (ftype);
+  
+  return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
+}
+
+static TypeNode*
+type_node_fundamental_new_W (GType                 ftype,
+			     const gchar          *name,
+			     GTypeFundamentalFlags type_flags)
+{
+  GTypeFundamentalInfo *finfo;
+  TypeNode *node;
+  
+  g_assert ((ftype & TYPE_ID_MASK) == 0);
+  g_assert (ftype <= G_TYPE_FUNDAMENTAL_MAX);
+  
+  if (ftype >> G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)
+    static_fundamental_next++;
+  
+  type_flags &= TYPE_FUNDAMENTAL_FLAG_MASK;
+  
+  node = type_node_any_new_W (NULL, ftype, name, NULL, type_flags);
+  
+  finfo = type_node_fundamental_info_I (node);
+  finfo->type_flags = type_flags;
+  
+  return node;
+}
+
+static TypeNode*
+type_node_new_W (TypeNode    *pnode,
+		 const gchar *name,
+		 GTypePlugin *plugin)
+     
+{
+  g_assert (pnode);
+  g_assert (pnode->n_supers < MAX_N_SUPERS);
+  g_assert (pnode->n_children < MAX_N_CHILDREN);
+  
+  return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
+}
+
+static inline IFaceEntry*
+lookup_iface_entry_I (volatile IFaceEntries *entries,
+		      TypeNode *iface_node)
+{
+  guint8 *offsets;
+  guint offset_index;
+  IFaceEntry *check;
+  int index;
+  IFaceEntry *entry;
+
+  if (entries == NULL)
+    return NULL;
+
+  G_ATOMIC_ARRAY_DO_TRANSACTION
+    (&iface_node->_prot.offsets, guint8,
+
+     entry = NULL;
+     offsets = transaction_data;
+     offset_index = entries->offset_index;
+     if (offsets != NULL &&
+	 offset_index < G_ATOMIC_ARRAY_DATA_SIZE(offsets))
+       {
+	 index = offsets[offset_index];
+	 if (index > 0)
+	   {
+	     /* zero means unset, subtract one to get real index */
+	     index -= 1;
+
+	     if (index < IFACE_ENTRIES_N_ENTRIES (entries))
+	       {
+		 check = (IFaceEntry *)&entries->entry[index];
+		 if (check->iface_type == NODE_TYPE (iface_node))
+		   entry = check;
+	       }
+	   }
+       }
+     );
+
+ return entry;
+}
+
+static inline IFaceEntry*
+type_lookup_iface_entry_L (TypeNode *node,
+			   TypeNode *iface_node)
+{
+  if (!NODE_IS_IFACE (iface_node))
+    return NULL;
+
+  return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
+			       iface_node);
+}
+
+
+static inline gboolean
+type_lookup_iface_vtable_I (TypeNode *node,
+			    TypeNode *iface_node,
+			    gpointer *vtable_ptr)
+{
+  IFaceEntry *entry;
+  gboolean res;
+
+  if (!NODE_IS_IFACE (iface_node))
+    {
+      if (vtable_ptr)
+	*vtable_ptr = NULL;
+      return FALSE;
+    }
+
+  G_ATOMIC_ARRAY_DO_TRANSACTION
+    (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
+
+     entry = lookup_iface_entry_I (transaction_data, iface_node);
+     res = entry != NULL;
+     if (vtable_ptr)
+       {
+	 if (entry)
+	   *vtable_ptr = entry->vtable;
+	 else
+	   *vtable_ptr = NULL;
+       }
+     );
+
+  return res;
+}
+
+static inline gboolean
+type_lookup_prerequisite_L (TypeNode *iface,
+			    GType     prerequisite_type)
+{
+  if (NODE_IS_IFACE (iface) && IFACE_NODE_N_PREREQUISITES (iface))
+    {
+      GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
+      guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
+      
+      do
+	{
+	  guint i;
+	  GType *check;
+	  
+	  i = (n_prerequisites + 1) >> 1;
+	  check = prerequisites + i;
+	  if (prerequisite_type == *check)
+	    return TRUE;
+	  else if (prerequisite_type > *check)
+	    {
+	      n_prerequisites -= i;
+	      prerequisites = check;
+	    }
+	  else /* if (prerequisite_type < *check) */
+	    n_prerequisites = i - 1;
+	}
+      while (n_prerequisites);
+    }
+  return FALSE;
+}
+
+static const gchar*
+type_descriptive_name_I (GType type)
+{
+  if (type)
+    {
+      TypeNode *node = lookup_type_node_I (type);
+      
+      return node ? NODE_NAME (node) : "<unknown>";
+    }
+  else
+    return "<invalid>";
+}
+
+
+/* --- type consistency checks --- */
+static gboolean
+check_plugin_U (GTypePlugin *plugin,
+		gboolean     need_complete_type_info,
+		gboolean     need_complete_interface_info,
+		const gchar *type_name)
+{
+  /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U 
+   */
+  if (!plugin)
+    {
+      g_warning ("plugin handle for type '%s' is NULL",
+		 type_name);
+      return FALSE;
+    }
+  if (!G_IS_TYPE_PLUGIN (plugin))
+    {
+      g_warning ("plugin pointer (%p) for type '%s' is invalid",
+		 plugin, type_name);
+      return FALSE;
+    }
+  if (need_complete_type_info && !G_TYPE_PLUGIN_GET_CLASS (plugin)->complete_type_info)
+    {
+      g_warning ("plugin for type '%s' has no complete_type_info() implementation",
+		 type_name);
+      return FALSE;
+    }
+  if (need_complete_interface_info && !G_TYPE_PLUGIN_GET_CLASS (plugin)->complete_interface_info)
+    {
+      g_warning ("plugin for type '%s' has no complete_interface_info() implementation",
+		 type_name);
+      return FALSE;
+    }
+  return TRUE;
+}
+
+static gboolean
+check_type_name_I (const gchar *type_name)
+{
+  static const gchar extra_chars[] = "-_+";
+  const gchar *p = type_name;
+  gboolean name_valid;
+  
+  if (!type_name[0] || !type_name[1] || !type_name[2])
+    {
+      g_warning ("type name '%s' is too short", type_name);
+      return FALSE;
+    }
+  /* check the first letter */
+  name_valid = (p[0] >= 'A' && p[0] <= 'Z') || (p[0] >= 'a' && p[0] <= 'z') || p[0] == '_';
+  for (p = type_name + 1; *p; p++)
+    name_valid &= ((p[0] >= 'A' && p[0] <= 'Z') ||
+		   (p[0] >= 'a' && p[0] <= 'z') ||
+		   (p[0] >= '0' && p[0] <= '9') ||
+		   strchr (extra_chars, p[0]));
+  if (!name_valid)
+    {
+      g_warning ("type name '%s' contains invalid characters", type_name);
+      return FALSE;
+    }
+  if (g_type_from_name (type_name))
+    {
+      g_warning ("cannot register existing type '%s'", type_name);
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+
+static gboolean
+check_derivation_I (GType        parent_type,
+		    const gchar *type_name)
+{
+  TypeNode *pnode;
+  GTypeFundamentalInfo* finfo;
+  
+  pnode = lookup_type_node_I (parent_type);
+  if (!pnode)
+    {
+      g_warning ("cannot derive type '%s' from invalid parent type '%s'",
+		 type_name,
+		 type_descriptive_name_I (parent_type));
+      return FALSE;
+    }
+  finfo = type_node_fundamental_info_I (pnode);
+  /* ensure flat derivability */
+  if (!(finfo->type_flags & G_TYPE_FLAG_DERIVABLE))
+    {
+      g_warning ("cannot derive '%s' from non-derivable parent type '%s'",
+		 type_name,
+		 NODE_NAME (pnode));
+      return FALSE;
+    }
+  /* ensure deep derivability */
+  if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &&
+      !(finfo->type_flags & G_TYPE_FLAG_DEEP_DERIVABLE))
+    {
+      g_warning ("cannot derive '%s' from non-fundamental parent type '%s'",
+		 type_name,
+		 NODE_NAME (pnode));
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+
+static gboolean
+check_collect_format_I (const gchar *collect_format)
+{
+  const gchar *p = collect_format;
+  gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
+			   G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,
+			   G_VALUE_COLLECT_POINTER, 0 };
+  
+  while (*p)
+    if (!strchr (valid_format, *p++))
+      return FALSE;
+  return p - collect_format <= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
+}
+
+static gboolean
+check_value_table_I (const gchar           *type_name,
+		     const GTypeValueTable *value_table)
+{
+  if (!value_table)
+    return FALSE;
+  else if (value_table->value_init == NULL)
+    {
+      if (value_table->value_free || value_table->value_copy ||
+	  value_table->value_peek_pointer ||
+	  value_table->collect_format || value_table->collect_value ||
+	  value_table->lcopy_format || value_table->lcopy_value)
+	g_warning ("cannot handle uninitializable values of type '%s'",
+		   type_name);
+      return FALSE;
+    }
+  else /* value_table->value_init != NULL */
+    {
+      if (!value_table->value_free)
+	{
+	  /* +++ optional +++
+	   * g_warning ("missing 'value_free()' for type '%s'", type_name);
+	   * return FALSE;
+	   */
+	}
+      if (!value_table->value_copy)
+	{
+	  g_warning ("missing 'value_copy()' for type '%s'", type_name);
+	  return FALSE;
+	}
+      if ((value_table->collect_format || value_table->collect_value) &&
+	  (!value_table->collect_format || !value_table->collect_value))
+	{
+	  g_warning ("one of 'collect_format' and 'collect_value()' is unspecified for type '%s'",
+		     type_name);
+	  return FALSE;
+	}
+      if (value_table->collect_format && !check_collect_format_I (value_table->collect_format))
+	{
+	  g_warning ("the '%s' specification for type '%s' is too long or invalid",
+		     "collect_format",
+		     type_name);
+	  return FALSE;
+	}
+      if ((value_table->lcopy_format || value_table->lcopy_value) &&
+	  (!value_table->lcopy_format || !value_table->lcopy_value))
+	{
+	  g_warning ("one of 'lcopy_format' and 'lcopy_value()' is unspecified for type '%s'",
+		     type_name);
+	  return FALSE;
+	}
+      if (value_table->lcopy_format && !check_collect_format_I (value_table->lcopy_format))
+	{
+	  g_warning ("the '%s' specification for type '%s' is too long or invalid",
+		     "lcopy_format",
+		     type_name);
+	  return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+static gboolean
+check_type_info_I (TypeNode        *pnode,
+		   GType            ftype,
+		   const gchar     *type_name,
+		   const GTypeInfo *info)
+{
+  GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
+  gboolean is_interface = ftype == G_TYPE_INTERFACE;
+  
+  g_assert (ftype <= G_TYPE_FUNDAMENTAL_MAX && !(ftype & TYPE_ID_MASK));
+  
+  /* check instance members */
+  if (!(finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE) &&
+      (info->instance_size || info->n_preallocs || info->instance_init))
+    {
+      if (pnode)
+	g_warning ("cannot instantiate '%s', derived from non-instantiatable parent type '%s'",
+		   type_name,
+		   NODE_NAME (pnode));
+      else
+	g_warning ("cannot instantiate '%s' as non-instantiatable fundamental",
+		   type_name);
+      return FALSE;
+    }
+  /* check class & interface members */
+  if (!((finfo->type_flags & G_TYPE_FLAG_CLASSED) || is_interface) &&
+      (info->class_init || info->class_finalize || info->class_data ||
+       info->class_size || info->base_init || info->base_finalize))
+    {
+      if (pnode)
+	g_warning ("cannot create class for '%s', derived from non-classed parent type '%s'",
+		   type_name,
+                   NODE_NAME (pnode));
+      else
+	g_warning ("cannot create class for '%s' as non-classed fundamental",
+		   type_name);
+      return FALSE;
+    }
+  /* check interface size */
+  if (is_interface && info->class_size < sizeof (GTypeInterface))
+    {
+      g_warning ("specified interface size for type '%s' is smaller than 'GTypeInterface' size",
+		 type_name);
+      return FALSE;
+    }
+  /* check class size */
+  if (finfo->type_flags & G_TYPE_FLAG_CLASSED)
+    {
+      if (info->class_size < sizeof (GTypeClass))
+	{
+	  g_warning ("specified class size for type '%s' is smaller than 'GTypeClass' size",
+		     type_name);
+	  return FALSE;
+	}
+      if (pnode && info->class_size < pnode->data->class.class_size)
+	{
+	  g_warning ("specified class size for type '%s' is smaller "
+		     "than the parent type's '%s' class size",
+		     type_name,
+		     NODE_NAME (pnode));
+	  return FALSE;
+	}
+    }
+  /* check instance size */
+  if (finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE)
+    {
+      if (info->instance_size < sizeof (GTypeInstance))
+	{
+	  g_warning ("specified instance size for type '%s' is smaller than 'GTypeInstance' size",
+		     type_name);
+	  return FALSE;
+	}
+      if (pnode && info->instance_size < pnode->data->instance.instance_size)
+	{
+	  g_warning ("specified instance size for type '%s' is smaller "
+		     "than the parent type's '%s' instance size",
+		     type_name,
+		     NODE_NAME (pnode));
+	  return FALSE;
+	}
+    }
+  
+  return TRUE;
+}
+
+static TypeNode*
+find_conforming_child_type_L (TypeNode *pnode,
+			      TypeNode *iface)
+{
+  TypeNode *node = NULL;
+  guint i;
+  
+  if (type_lookup_iface_entry_L (pnode, iface))
+    return pnode;
+  
+  for (i = 0; i < pnode->n_children && !node; i++)
+    node = find_conforming_child_type_L (lookup_type_node_I (pnode->children[i]), iface);
+  
+  return node;
+}
+
+static gboolean
+check_add_interface_L (GType instance_type,
+		       GType iface_type)
+{
+  TypeNode *node = lookup_type_node_I (instance_type);
+  TypeNode *iface = lookup_type_node_I (iface_type);
+  IFaceEntry *entry;
+  TypeNode *tnode;
+  GType *prerequisites;
+  guint i;
+
+  
+  if (!node || !node->is_instantiatable)
+    {
+      g_warning ("cannot add interfaces to invalid (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (instance_type));
+      return FALSE;
+    }
+  if (!iface || !NODE_IS_IFACE (iface))
+    {
+      g_warning ("cannot add invalid (non-interface) type '%s' to type '%s'",
+		 type_descriptive_name_I (iface_type),
+		 NODE_NAME (node));
+      return FALSE;
+    }
+  if (node->data && node->data->class.class)
+    {
+      g_warning ("attempting to add an interface (%s) to class (%s) after class_init",
+                 NODE_NAME (iface), NODE_NAME (node));
+      return FALSE;
+    }
+  tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
+  if (NODE_PARENT_TYPE (tnode) && !type_lookup_iface_entry_L (node, tnode))
+    {
+      /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
+      g_warning ("cannot add sub-interface '%s' to type '%s' which does not conform to super-interface '%s'",
+		 NODE_NAME (iface),
+		 NODE_NAME (node),
+		 NODE_NAME (tnode));
+      return FALSE;
+    }
+  /* allow overriding of interface type introduced for parent type */
+  entry = type_lookup_iface_entry_L (node, iface);
+  if (entry && entry->vtable == NULL && !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
+    {
+      /* ok, we do conform to this interface already, but the interface vtable was not
+       * yet intialized, and we just conform to the interface because it got added to
+       * one of our parents. so we allow overriding of holder info here.
+       */
+      return TRUE;
+    }
+  /* check whether one of our children already conforms (or whether the interface
+   * got added to this node already)
+   */
+  tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
+  if (tnode)
+    {
+      g_warning ("cannot add interface type '%s' to type '%s', since type '%s' already conforms to interface",
+		 NODE_NAME (iface),
+		 NODE_NAME (node),
+		 NODE_NAME (tnode));
+      return FALSE;
+    }
+  prerequisites = IFACE_NODE_PREREQUISITES (iface);
+  for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
+    {
+      tnode = lookup_type_node_I (prerequisites[i]);
+      if (!type_node_is_a_L (node, tnode))
+	{
+	  g_warning ("cannot add interface type '%s' to type '%s' which does not conform to prerequisite '%s'",
+		     NODE_NAME (iface),
+		     NODE_NAME (node),
+		     NODE_NAME (tnode));
+	  return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+static gboolean
+check_interface_info_I (TypeNode             *iface,
+			GType                 instance_type,
+			const GInterfaceInfo *info)
+{
+  if ((info->interface_finalize || info->interface_data) && !info->interface_init)
+    {
+      g_warning ("interface type '%s' for type '%s' comes without initializer",
+		 NODE_NAME (iface),
+		 type_descriptive_name_I (instance_type));
+      return FALSE;
+    }
+  
+  return TRUE;
+}
+
+/* --- type info (type node data) --- */
+static void
+type_data_make_W (TypeNode              *node,
+		  const GTypeInfo       *info,
+		  const GTypeValueTable *value_table)
+{
+  TypeData *data;
+  GTypeValueTable *vtable = NULL;
+  guint vtable_size = 0;
+  
+  g_assert (node->data == NULL && info != NULL);
+  
+  if (!value_table)
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+      
+      if (pnode)
+	vtable = pnode->data->common.value_table;
+      else
+	{
+	  static const GTypeValueTable zero_vtable = { NULL, };
+	  
+	  value_table = &zero_vtable;
+	}
+    }
+  if (value_table)
+    {
+      /* need to setup vtable_size since we have to allocate it with data in one chunk */
+      vtable_size = sizeof (GTypeValueTable);
+      if (value_table->collect_format)
+	vtable_size += strlen (value_table->collect_format);
+      if (value_table->lcopy_format)
+	vtable_size += strlen (value_table->lcopy_format);
+      vtable_size += 2;
+    }
+   
+  if (node->is_instantiatable) /* careful, is_instantiatable is also is_classed */
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+
+      data = g_malloc0 (sizeof (InstanceData) + vtable_size);
+      if (vtable_size)
+	vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));
+      data->instance.class_size = info->class_size;
+      data->instance.class_init_base = info->base_init;
+      data->instance.class_finalize_base = info->base_finalize;
+      data->instance.class_init = info->class_init;
+      data->instance.class_finalize = info->class_finalize;
+      data->instance.class_data = info->class_data;
+      data->instance.class = NULL;
+      data->instance.init_state = UNINITIALIZED;
+      data->instance.instance_size = info->instance_size;
+      /* We'll set the final value for data->instance.private size
+       * after the parent class has been initialized
+       */
+      data->instance.private_size = 0;
+      data->instance.class_private_size = 0;
+      if (pnode)
+        data->instance.class_private_size = pnode->data->instance.class_private_size;
+#ifdef	DISABLE_MEM_POOLS
+      data->instance.n_preallocs = 0;
+#else	/* !DISABLE_MEM_POOLS */
+      data->instance.n_preallocs = MIN (info->n_preallocs, 1024);
+#endif	/* !DISABLE_MEM_POOLS */
+      data->instance.instance_init = info->instance_init;
+    }
+  else if (node->is_classed) /* only classed */
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+
+      data = g_malloc0 (sizeof (ClassData) + vtable_size);
+      if (vtable_size)
+	vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));
+      data->class.class_size = info->class_size;
+      data->class.class_init_base = info->base_init;
+      data->class.class_finalize_base = info->base_finalize;
+      data->class.class_init = info->class_init;
+      data->class.class_finalize = info->class_finalize;
+      data->class.class_data = info->class_data;
+      data->class.class = NULL;
+      data->class.class_private_size = 0;
+      if (pnode)
+        data->class.class_private_size = pnode->data->class.class_private_size;
+      data->class.init_state = UNINITIALIZED;
+    }
+  else if (NODE_IS_IFACE (node))
+    {
+      data = g_malloc0 (sizeof (IFaceData) + vtable_size);
+      if (vtable_size)
+	vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));
+      data->iface.vtable_size = info->class_size;
+      data->iface.vtable_init_base = info->base_init;
+      data->iface.vtable_finalize_base = info->base_finalize;
+      data->iface.dflt_init = info->class_init;
+      data->iface.dflt_finalize = info->class_finalize;
+      data->iface.dflt_data = info->class_data;
+      data->iface.dflt_vtable = NULL;
+    }
+  else if (NODE_IS_BOXED (node))
+    {
+      data = g_malloc0 (sizeof (BoxedData) + vtable_size);
+      if (vtable_size)
+	vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));
+    }
+  else
+    {
+      data = g_malloc0 (sizeof (CommonData) + vtable_size);
+      if (vtable_size)
+	vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));
+    }
+  
+  node->data = data;
+  
+  if (vtable_size)
+    {
+      gchar *p;
+      
+      /* we allocate the vtable and its strings together with the type data, so
+       * children can take over their parent's vtable pointer, and we don't
+       * need to worry freeing it or not when the child data is destroyed
+       */
+      *vtable = *value_table;
+      p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
+      p[0] = 0;
+      vtable->collect_format = p;
+      if (value_table->collect_format)
+	{
+	  strcat (p, value_table->collect_format);
+	  p += strlen (value_table->collect_format);
+	}
+      p++;
+      p[0] = 0;
+      vtable->lcopy_format = p;
+      if (value_table->lcopy_format)
+	strcat  (p, value_table->lcopy_format);
+    }
+  node->data->common.value_table = vtable;
+  node->mutatable_check_cache = (node->data->common.value_table->value_init != NULL &&
+				 !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &
+				   GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));
+  
+  g_assert (node->data->common.value_table != NULL); /* paranoid */
+
+  g_atomic_int_set ((int *) &node->ref_count, 1);
+}
+
+static inline void
+type_data_ref_Wm (TypeNode *node)
+{
+  if (!node->data)
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+      GTypeInfo tmp_info;
+      GTypeValueTable tmp_value_table;
+      
+      g_assert (node->plugin != NULL);
+      
+      if (pnode)
+	{
+	  type_data_ref_Wm (pnode);
+	  if (node->data)
+	    INVALID_RECURSION ("g_type_plugin_*", node->plugin, NODE_NAME (node));
+	}
+      
+      memset (&tmp_info, 0, sizeof (tmp_info));
+      memset (&tmp_value_table, 0, sizeof (tmp_value_table));
+      
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_type_plugin_use (node->plugin);
+      g_type_plugin_complete_type_info (node->plugin, NODE_TYPE (node), &tmp_info, &tmp_value_table);
+      G_WRITE_LOCK (&type_rw_lock);
+      if (node->data)
+	INVALID_RECURSION ("g_type_plugin_*", node->plugin, NODE_NAME (node));
+      
+      check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &tmp_info);
+      type_data_make_W (node, &tmp_info,
+			check_value_table_I (NODE_NAME (node),
+					     &tmp_value_table) ? &tmp_value_table : NULL);
+    }
+  else
+    {
+      g_assert (NODE_REFCOUNT (node) > 0);
+      
+      g_atomic_int_inc ((int *) &node->ref_count);
+    }
+}
+
+static inline gboolean
+type_data_ref_U (TypeNode *node)
+{
+  guint current;
+
+  do {
+    current = NODE_REFCOUNT (node);
+
+    if (current < 1)
+      return FALSE;
+  } while (!g_atomic_int_compare_and_exchange ((int *) &node->ref_count, current, current + 1));
+
+  return TRUE;
+}
+
+static gboolean
+iface_node_has_available_offset_L (TypeNode *iface_node,
+				   int offset,
+				   int for_index)
+{
+  guint8 *offsets;
+
+  offsets = G_ATOMIC_ARRAY_GET_LOCKED (&iface_node->_prot.offsets, guint8);
+  if (offsets == NULL)
+    return TRUE;
+
+  if (G_ATOMIC_ARRAY_DATA_SIZE (offsets) <= offset)
+    return TRUE;
+
+  if (offsets[offset] == 0 ||
+      offsets[offset] == for_index+1)
+    return TRUE;
+
+  return FALSE;
+}
+
+static int
+find_free_iface_offset_L (IFaceEntries *entries)
+{
+  IFaceEntry *entry;
+  TypeNode *iface_node;
+  int offset;
+  int i;
+  int n_entries;
+
+  n_entries = IFACE_ENTRIES_N_ENTRIES (entries);
+  offset = -1;
+  do
+    {
+      offset++;
+      for (i = 0; i < n_entries; i++)
+	{
+	  entry = &entries->entry[i];
+	  iface_node = lookup_type_node_I (entry->iface_type);
+
+	  if (!iface_node_has_available_offset_L (iface_node, offset, i))
+	    break;
+	}
+    }
+  while (i != n_entries);
+
+  return offset;
+}
+
+static void
+iface_node_set_offset_L (TypeNode *iface_node,
+			 int offset,
+			 int index)
+{
+  guint8 *offsets, *old_offsets;
+  int new_size, old_size;
+  int i;
+
+  old_offsets = G_ATOMIC_ARRAY_GET_LOCKED (&iface_node->_prot.offsets, guint8);
+  if (old_offsets == NULL)
+    old_size = 0;
+  else
+    {
+      old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
+      if (offset < old_size &&
+	  old_offsets[offset] == index + 1)
+	return; /* Already set to this index, return */
+    }
+  new_size = MAX (old_size, offset + 1);
+
+  offsets = _g_atomic_array_copy (&iface_node->_prot.offsets,
+				  0, new_size - old_size);
+
+  /* Mark new area as unused */
+  for (i = old_size; i < new_size; i++)
+    offsets[i] = 0;
+
+  offsets[offset] = index + 1;
+
+  _g_atomic_array_update (&iface_node->_prot.offsets, offsets);
+}
+
+static void
+type_node_add_iface_entry_W (TypeNode   *node,
+			     GType       iface_type,
+                             IFaceEntry *parent_entry)
+{
+  IFaceEntries *entries;
+  IFaceEntry *entry;
+  TypeNode *iface_node;
+  guint i, j;
+  int num_entries;
+
+  g_assert (node->is_instantiatable);
+
+  entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
+  if (entries != NULL)
+    {
+      num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
+
+      g_assert (num_entries < MAX_N_INTERFACES);
+
+      for (i = 0; i < num_entries; i++)
+	{
+	  entry = &entries->entry[i];
+	  if (entry->iface_type == iface_type)
+	    {
+	      /* this can happen in two cases:
+	       * - our parent type already conformed to iface_type and node
+	       *   got its own holder info. here, our children already have
+	       *   entries and NULL vtables, since this will only work for
+	       *   uninitialized classes.
+	       * - an interface type is added to an ancestor after it was
+	       *   added to a child type.
+	       */
+	      if (!parent_entry)
+		g_assert (entry->vtable == NULL && entry->init_state == UNINITIALIZED);
+	      else
+		{
+		  /* sick, interface is added to ancestor *after* child type;
+		   * nothing todo, the entry and our children were already setup correctly
+		   */
+		}
+	      return;
+	    }
+	}
+    }
+
+  entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
+				  IFACE_ENTRIES_HEADER_SIZE,
+				  sizeof (IFaceEntry));
+  num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
+  i = num_entries - 1;
+  if (i == 0)
+    entries->offset_index = 0;
+  entries->entry[i].iface_type = iface_type;
+  entries->entry[i].vtable = NULL;
+  entries->entry[i].init_state = UNINITIALIZED;
+
+  if (parent_entry)
+    {
+      if (node->data && node->data->class.init_state >= BASE_IFACE_INIT)
+        {
+          entries->entry[i].init_state = INITIALIZED;
+          entries->entry[i].vtable = parent_entry->vtable;
+        }
+    }
+
+  /* Update offsets in iface */
+  iface_node = lookup_type_node_I (iface_type);
+
+  if (iface_node_has_available_offset_L (iface_node,
+					 entries->offset_index,
+					 i))
+    {
+      iface_node_set_offset_L (iface_node,
+			       entries->offset_index, i);
+    }
+  else
+   {
+      entries->offset_index =
+	find_free_iface_offset_L (entries);
+      for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (entries); j++)
+	{
+	  entry = &entries->entry[j];
+	  iface_node =
+	    lookup_type_node_I (entry->iface_type);
+	  iface_node_set_offset_L (iface_node,
+				   entries->offset_index, j);
+	}
+    }
+
+  _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
+
+  if (parent_entry)
+    {
+      for (i = 0; i < node->n_children; i++)
+        type_node_add_iface_entry_W (lookup_type_node_I (node->children[i]), iface_type, &entries->entry[i]);
+    }
+}
+
+static void
+type_add_interface_Wm (TypeNode             *node,
+                       TypeNode             *iface,
+                       const GInterfaceInfo *info,
+                       GTypePlugin          *plugin)
+{
+  IFaceHolder *iholder = g_new0 (IFaceHolder, 1);
+  IFaceEntry *entry;
+  guint i;
+
+  g_assert (node->is_instantiatable && NODE_IS_IFACE (iface) && ((info && !plugin) || (!info && plugin)));
+  
+  iholder->next = iface_node_get_holders_L (iface);
+  iface_node_set_holders_W (iface, iholder);
+  iholder->instance_type = NODE_TYPE (node);
+  iholder->info = info ? g_memdup (info, sizeof (*info)) : NULL;
+  iholder->plugin = plugin;
+
+  /* create an iface entry for this type */
+  type_node_add_iface_entry_W (node, NODE_TYPE (iface), NULL);
+  
+  /* if the class is already (partly) initialized, we may need to base
+   * initalize and/or initialize the new interface.
+   */
+  if (node->data)
+    {
+      InitState class_state = node->data->class.init_state;
+      
+      if (class_state >= BASE_IFACE_INIT)
+        type_iface_vtable_base_init_Wm (iface, node);
+      
+      if (class_state >= IFACE_INIT)
+        type_iface_vtable_iface_init_Wm (iface, node);
+    }
+  
+  /* create iface entries for children of this type */
+  entry = type_lookup_iface_entry_L (node, iface);
+  for (i = 0; i < node->n_children; i++)
+    type_node_add_iface_entry_W (lookup_type_node_I (node->children[i]), NODE_TYPE (iface), entry);
+}
+
+static void
+type_iface_add_prerequisite_W (TypeNode *iface,
+			       TypeNode *prerequisite_node)
+{
+  GType prerequisite_type = NODE_TYPE (prerequisite_node);
+  GType *prerequisites, *dependants;
+  guint n_dependants, i;
+  
+  g_assert (NODE_IS_IFACE (iface) &&
+	    IFACE_NODE_N_PREREQUISITES (iface) < MAX_N_PREREQUISITES &&
+	    (prerequisite_node->is_instantiatable || NODE_IS_IFACE (prerequisite_node)));
+  
+  prerequisites = IFACE_NODE_PREREQUISITES (iface);
+  for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
+    if (prerequisites[i] == prerequisite_type)
+      return;			/* we already have that prerequisiste */
+    else if (prerequisites[i] > prerequisite_type)
+      break;
+  IFACE_NODE_N_PREREQUISITES (iface) += 1;
+  IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
+					      IFACE_NODE_PREREQUISITES (iface),
+					      IFACE_NODE_N_PREREQUISITES (iface));
+  prerequisites = IFACE_NODE_PREREQUISITES (iface);
+  memmove (prerequisites + i + 1, prerequisites + i,
+           sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
+  prerequisites[i] = prerequisite_type;
+  
+  /* we want to get notified when prerequisites get added to prerequisite_node */
+  if (NODE_IS_IFACE (prerequisite_node))
+    {
+      dependants = iface_node_get_dependants_array_L (prerequisite_node);
+      n_dependants = dependants ? dependants[0] : 0;
+      n_dependants += 1;
+      dependants = g_renew (GType, dependants, n_dependants + 1);
+      dependants[n_dependants] = NODE_TYPE (iface);
+      dependants[0] = n_dependants;
+      iface_node_set_dependants_array_W (prerequisite_node, dependants);
+    }
+  
+  /* we need to notify all dependants */
+  dependants = iface_node_get_dependants_array_L (iface);
+  n_dependants = dependants ? dependants[0] : 0;
+  for (i = 1; i <= n_dependants; i++)
+    type_iface_add_prerequisite_W (lookup_type_node_I (dependants[i]), prerequisite_node);
+}
+
+/**
+ * g_type_interface_add_prerequisite:
+ * @interface_type: #GType value of an interface type
+ * @prerequisite_type: #GType value of an interface or instantiatable type
+ *
+ * Adds @prerequisite_type to the list of prerequisites of @interface_type.
+ * This means that any type implementing @interface_type must also implement
+ * @prerequisite_type. Prerequisites can be thought of as an alternative to
+ * interface derivation (which GType doesn't support). An interface can have
+ * at most one instantiatable prerequisite type.
+ */
+void
+g_type_interface_add_prerequisite (GType interface_type,
+				   GType prerequisite_type)
+{
+  TypeNode *iface, *prerequisite_node;
+  IFaceHolder *holders;
+  
+  g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));	/* G_TYPE_IS_INTERFACE() is an external call: _U */
+  g_return_if_fail (!g_type_is_a (interface_type, prerequisite_type));
+  g_return_if_fail (!g_type_is_a (prerequisite_type, interface_type));
+  
+  iface = lookup_type_node_I (interface_type);
+  prerequisite_node = lookup_type_node_I (prerequisite_type);
+  if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
+    {
+      g_warning ("interface type '%s' or prerequisite type '%s' invalid",
+		 type_descriptive_name_I (interface_type),
+		 type_descriptive_name_I (prerequisite_type));
+      return;
+    }
+  G_WRITE_LOCK (&type_rw_lock);
+  holders = iface_node_get_holders_L (iface);
+  if (holders)
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_warning ("unable to add prerequisite '%s' to interface '%s' which is already in use for '%s'",
+		 type_descriptive_name_I (prerequisite_type),
+		 type_descriptive_name_I (interface_type),
+		 type_descriptive_name_I (holders->instance_type));
+      return;
+    }
+  if (prerequisite_node->is_instantiatable)
+    {
+      guint i;
+      
+      /* can have at most one publicly installable instantiatable prerequisite */
+      for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
+	{
+	  TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);
+	  
+	  if (prnode->is_instantiatable)
+	    {
+	      G_WRITE_UNLOCK (&type_rw_lock);
+	      g_warning ("adding prerequisite '%s' to interface '%s' conflicts with existing prerequisite '%s'",
+			 type_descriptive_name_I (prerequisite_type),
+			 type_descriptive_name_I (interface_type),
+			 type_descriptive_name_I (NODE_TYPE (prnode)));
+	      return;
+	    }
+	}
+      
+      for (i = 0; i < prerequisite_node->n_supers + 1; i++)
+	type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node->supers[i]));
+      G_WRITE_UNLOCK (&type_rw_lock);
+    }
+  else if (NODE_IS_IFACE (prerequisite_node))
+    {
+      GType *prerequisites;
+      guint i;
+      
+      prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
+      for (i = 0; i < IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
+	type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));
+      type_iface_add_prerequisite_W (iface, prerequisite_node);
+      G_WRITE_UNLOCK (&type_rw_lock);
+    }
+  else
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_warning ("prerequisite '%s' for interface '%s' is neither instantiatable nor interface",
+		 type_descriptive_name_I (prerequisite_type),
+		 type_descriptive_name_I (interface_type));
+    }
+}
+
+/**
+ * g_type_interface_prerequisites:
+ * @interface_type: an interface type
+ * @n_prerequisites: (out) (allow-none): location to return the number
+ *     of prerequisites, or %NULL
+ *
+ * Returns the prerequisites of an interfaces type.
+ *
+ * Since: 2.2
+ *
+ * Returns: (array length=n_prerequisites) (transfer full): a
+ *     newly-allocated zero-terminated array of #GType containing
+ *     the prerequisites of @interface_type
+ */
+GType*
+g_type_interface_prerequisites (GType  interface_type,
+				guint *n_prerequisites)
+{
+  TypeNode *iface;
+  
+  g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
+
+  iface = lookup_type_node_I (interface_type);
+  if (iface)
+    {
+      GType *types;
+      TypeNode *inode = NULL;
+      guint i, n = 0;
+      
+      G_READ_LOCK (&type_rw_lock);
+      types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
+      for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
+	{
+	  GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];
+	  TypeNode *node = lookup_type_node_I (prerequisite);
+	  if (node->is_instantiatable)
+            {
+              if (!inode || type_node_is_a_L (node, inode))
+	        inode = node;
+            }
+	  else
+	    types[n++] = NODE_TYPE (node);
+	}
+      if (inode)
+	types[n++] = NODE_TYPE (inode);
+      
+      if (n_prerequisites)
+	*n_prerequisites = n;
+      G_READ_UNLOCK (&type_rw_lock);
+      
+      return types;
+    }
+  else
+    {
+      if (n_prerequisites)
+	*n_prerequisites = 0;
+      
+      return NULL;
+    }
+}
+
+
+static IFaceHolder*
+type_iface_peek_holder_L (TypeNode *iface,
+			  GType     instance_type)
+{
+  IFaceHolder *iholder;
+  
+  g_assert (NODE_IS_IFACE (iface));
+  
+  iholder = iface_node_get_holders_L (iface);
+  while (iholder && iholder->instance_type != instance_type)
+    iholder = iholder->next;
+  return iholder;
+}
+
+static IFaceHolder*
+type_iface_retrieve_holder_info_Wm (TypeNode *iface,
+				    GType     instance_type,
+				    gboolean  need_info)
+{
+  IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
+  
+  if (iholder && !iholder->info && need_info)
+    {
+      GInterfaceInfo tmp_info;
+      
+      g_assert (iholder->plugin != NULL);
+      
+      type_data_ref_Wm (iface);
+      if (iholder->info)
+	INVALID_RECURSION ("g_type_plugin_*", iface->plugin, NODE_NAME (iface));
+      
+      memset (&tmp_info, 0, sizeof (tmp_info));
+      
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_type_plugin_use (iholder->plugin);
+      g_type_plugin_complete_interface_info (iholder->plugin, instance_type, NODE_TYPE (iface), &tmp_info);
+      G_WRITE_LOCK (&type_rw_lock);
+      if (iholder->info)
+        INVALID_RECURSION ("g_type_plugin_*", iholder->plugin, NODE_NAME (iface));
+      
+      check_interface_info_I (iface, instance_type, &tmp_info);
+      iholder->info = g_memdup (&tmp_info, sizeof (tmp_info));
+    }
+  
+  return iholder;	/* we don't modify write lock upon returning NULL */
+}
+
+static void
+type_iface_blow_holder_info_Wm (TypeNode *iface,
+				GType     instance_type)
+{
+  IFaceHolder *iholder = iface_node_get_holders_L (iface);
+  
+  g_assert (NODE_IS_IFACE (iface));
+  
+  while (iholder->instance_type != instance_type)
+    iholder = iholder->next;
+  
+  if (iholder->info && iholder->plugin)
+    {
+      g_free (iholder->info);
+      iholder->info = NULL;
+      
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_type_plugin_unuse (iholder->plugin);
+      type_data_unref_U (iface, FALSE);
+      G_WRITE_LOCK (&type_rw_lock);
+    }
+}
+
+/**
+ * g_type_create_instance: (skip)
+ * @type: an instantiatable type to create an instance for
+ *
+ * Creates and initializes an instance of @type if @type is valid and
+ * can be instantiated. The type system only performs basic allocation
+ * and structure setups for instances: actual instance creation should
+ * happen through functions supplied by the type's fundamental type
+ * implementation.  So use of g_type_create_instance() is reserved for
+ * implementators of fundamental types only. E.g. instances of the
+ * #GObject hierarchy should be created via g_object_new() and never
+ * directly through g_type_create_instance() which doesn't handle things
+ * like singleton objects or object construction.
+ *
+ * The extended members of the returned instance are guaranteed to be filled
+ * with zeros.
+ *
+ * Note: Do not use this function, unless you're implementing a
+ * fundamental type. Also language bindings should not use this
+ * function, but g_object_new() instead.
+ *
+ * Returns: an allocated and initialized instance, subject to further
+ *     treatment by the fundamental type implementation
+ */
+GTypeInstance*
+g_type_create_instance (GType type)
+{
+  TypeNode *node;
+  GTypeInstance *instance;
+  GTypeClass *class;
+  gchar *allocated;
+  gint private_size;
+  gint ivar_size;
+  guint i;
+
+  node = lookup_type_node_I (type);
+  if (!node || !node->is_instantiatable)
+    {
+      g_error ("cannot create new instance of invalid (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (type));
+    }
+  /* G_TYPE_IS_ABSTRACT() is an external call: _U */
+  if (!node->mutatable_check_cache && G_TYPE_IS_ABSTRACT (type))
+    {
+      g_error ("cannot create instance of abstract (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (type));
+    }
+  
+  class = g_type_class_ref (type);
+
+  /* We allocate the 'private' areas before the normal instance data, in
+   * reverse order.  This allows the private area of a particular class
+   * to always be at a constant relative address to the instance data.
+   * If we stored the private data after the instance data this would
+   * not be the case (since a subclass that added more instance
+   * variables would push the private data further along).
+   *
+   * This presents problems for valgrindability, of course, so we do a
+   * workaround for that case.  We identify the start of the object to
+   * valgrind as an allocated block (so that pointers to objects show up
+   * as 'reachable' instead of 'possibly lost').  We then add an extra
+   * pointer at the end of the object, after all instance data, back to
+   * the start of the private area so that it is also recorded as
+   * reachable.  We also add extra private space at the start because
+   * valgrind doesn't seem to like us claiming to have allocated an
+   * address that it saw allocated by malloc().
+   */
+  private_size = node->data->instance.private_size;
+  ivar_size = node->data->instance.instance_size;
+
+  if (private_size && RUNNING_ON_VALGRIND)
+    {
+      private_size += ALIGN_STRUCT (1);
+
+      /* Allocate one extra pointer size... */
+      allocated = g_slice_alloc0 (private_size + ivar_size + sizeof (gpointer));
+      /* ... and point it back to the start of the private data. */
+      *(gpointer *) (allocated + private_size + ivar_size) = allocated + ALIGN_STRUCT (1);
+
+      /* Tell valgrind that it should treat the object itself as such */
+      VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, ivar_size + sizeof (gpointer), 0, TRUE);
+      VALGRIND_MALLOCLIKE_BLOCK (allocated + ALIGN_STRUCT (1), private_size - ALIGN_STRUCT (1), 0, TRUE);
+    }
+  else
+    allocated = g_slice_alloc0 (private_size + ivar_size);
+
+  instance = (GTypeInstance *) (allocated + private_size);
+
+  for (i = node->n_supers; i > 0; i--)
+    {
+      TypeNode *pnode;
+      
+      pnode = lookup_type_node_I (node->supers[i]);
+      if (pnode->data->instance.instance_init)
+	{
+	  instance->g_class = pnode->data->instance.class;
+	  pnode->data->instance.instance_init (instance, class);
+	}
+    }
+
+  instance->g_class = class;
+  if (node->data->instance.instance_init)
+    node->data->instance.instance_init (instance, class);
+
+#ifdef	G_ENABLE_DEBUG
+  IF_DEBUG (INSTANCE_COUNT)
+    {
+      g_atomic_int_inc ((int *) &node->instance_count);
+    }
+#endif
+
+  TRACE(GOBJECT_OBJECT_NEW(instance, type));
+
+  return instance;
+}
+
+/**
+ * g_type_free_instance:
+ * @instance: an instance of a type
+ *
+ * Frees an instance of a type, returning it to the instance pool for
+ * the type, if there is one.
+ *
+ * Like g_type_create_instance(), this function is reserved for
+ * implementors of fundamental types.
+ */
+void
+g_type_free_instance (GTypeInstance *instance)
+{
+  TypeNode *node;
+  GTypeClass *class;
+  gchar *allocated;
+  gint private_size;
+  gint ivar_size;
+
+  g_return_if_fail (instance != NULL && instance->g_class != NULL);
+  
+  class = instance->g_class;
+  node = lookup_type_node_I (class->g_type);
+  if (!node || !node->is_instantiatable || !node->data || node->data->class.class != (gpointer) class)
+    {
+      g_warning ("cannot free instance of invalid (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (class->g_type));
+      return;
+    }
+  /* G_TYPE_IS_ABSTRACT() is an external call: _U */
+  if (!node->mutatable_check_cache && G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
+    {
+      g_warning ("cannot free instance of abstract (non-instantiatable) type '%s'",
+		 NODE_NAME (node));
+      return;
+    }
+  
+  instance->g_class = NULL;
+  private_size = node->data->instance.private_size;
+  ivar_size = node->data->instance.instance_size;
+  allocated = ((gchar *) instance) - private_size;
+
+#ifdef G_ENABLE_DEBUG
+  memset (allocated, 0xaa, ivar_size + private_size);
+#endif
+
+  /* See comment in g_type_create_instance() about what's going on here.
+   * We're basically unwinding what we put into motion there.
+   */
+  if (private_size && RUNNING_ON_VALGRIND)
+    {
+      private_size += ALIGN_STRUCT (1);
+      allocated -= ALIGN_STRUCT (1);
+
+      /* Clear out the extra pointer... */
+      *(gpointer *) (allocated + private_size + ivar_size) = NULL;
+      /* ... and ensure we include it in the size we free. */
+      g_slice_free1 (private_size + ivar_size + sizeof (gpointer), allocated);
+
+      VALGRIND_FREELIKE_BLOCK (allocated + ALIGN_STRUCT (1), 0);
+      VALGRIND_FREELIKE_BLOCK (instance, 0);
+    }
+  else
+    g_slice_free1 (private_size + ivar_size, allocated);
+
+#ifdef	G_ENABLE_DEBUG
+  IF_DEBUG (INSTANCE_COUNT)
+    {
+      g_atomic_int_add ((int *) &node->instance_count, -1);
+    }
+#endif
+
+  g_type_class_unref (class);
+}
+
+static void
+type_iface_ensure_dflt_vtable_Wm (TypeNode *iface)
+{
+  g_assert (iface->data);
+
+  if (!iface->data->iface.dflt_vtable)
+    {
+      GTypeInterface *vtable = g_malloc0 (iface->data->iface.vtable_size);
+      iface->data->iface.dflt_vtable = vtable;
+      vtable->g_type = NODE_TYPE (iface);
+      vtable->g_instance_type = 0;
+      if (iface->data->iface.vtable_init_base ||
+          iface->data->iface.dflt_init)
+        {
+          G_WRITE_UNLOCK (&type_rw_lock);
+          if (iface->data->iface.vtable_init_base)
+            iface->data->iface.vtable_init_base (vtable);
+          if (iface->data->iface.dflt_init)
+            iface->data->iface.dflt_init (vtable, (gpointer) iface->data->iface.dflt_data);
+          G_WRITE_LOCK (&type_rw_lock);
+        }
+    }
+}
+
+
+/* This is called to allocate and do the first part of initializing
+ * the interface vtable; type_iface_vtable_iface_init_Wm() does the remainder.
+ *
+ * A FALSE return indicates that we didn't find an init function for
+ * this type/iface pair, so the vtable from the parent type should
+ * be used. Note that the write lock is not modified upon a FALSE
+ * return.
+ */
+static gboolean
+type_iface_vtable_base_init_Wm (TypeNode *iface,
+				TypeNode *node)
+{
+  IFaceEntry *entry;
+  IFaceHolder *iholder;
+  GTypeInterface *vtable = NULL;
+  TypeNode *pnode;
+  
+  /* type_iface_retrieve_holder_info_Wm() doesn't modify write lock for returning NULL */
+  iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
+  if (!iholder)
+    return FALSE;	/* we don't modify write lock upon FALSE */
+
+  type_iface_ensure_dflt_vtable_Wm (iface);
+
+  entry = type_lookup_iface_entry_L (node, iface);
+
+  g_assert (iface->data && entry && entry->vtable == NULL && iholder && iholder->info);
+  
+  entry->init_state = IFACE_INIT;
+
+  pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+  if (pnode)	/* want to copy over parent iface contents */
+    {
+      IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
+      
+      if (pentry)
+	vtable = g_memdup (pentry->vtable, iface->data->iface.vtable_size);
+    }
+  if (!vtable)
+    vtable = g_memdup (iface->data->iface.dflt_vtable, iface->data->iface.vtable_size);
+  entry->vtable = vtable;
+  vtable->g_type = NODE_TYPE (iface);
+  vtable->g_instance_type = NODE_TYPE (node);
+  
+  if (iface->data->iface.vtable_init_base)
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      iface->data->iface.vtable_init_base (vtable);
+      G_WRITE_LOCK (&type_rw_lock);
+    }
+  return TRUE;	/* initialized the vtable */
+}
+
+/* Finishes what type_iface_vtable_base_init_Wm started by
+ * calling the interface init function.
+ * this function may only be called for types with their
+ * own interface holder info, i.e. types for which
+ * g_type_add_interface*() was called and not children thereof.
+ */
+static void
+type_iface_vtable_iface_init_Wm (TypeNode *iface,
+				 TypeNode *node)
+{
+  IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
+  IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
+  GTypeInterface *vtable = NULL;
+  guint i;
+  
+  /* iholder->info should have been filled in by type_iface_vtable_base_init_Wm() */
+  g_assert (iface->data && entry && iholder && iholder->info);
+  g_assert (entry->init_state == IFACE_INIT); /* assert prior base_init() */
+  
+  entry->init_state = INITIALIZED;
+      
+  vtable = entry->vtable;
+
+  if (iholder->info->interface_init)
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      if (iholder->info->interface_init)
+	iholder->info->interface_init (vtable, iholder->info->interface_data);
+      G_WRITE_LOCK (&type_rw_lock);
+    }
+  
+  for (i = 0; i < static_n_iface_check_funcs; i++)
+    {
+      GTypeInterfaceCheckFunc check_func = static_iface_check_funcs[i].check_func;
+      gpointer check_data = static_iface_check_funcs[i].check_data;
+
+      G_WRITE_UNLOCK (&type_rw_lock);
+      check_func (check_data, (gpointer)vtable);
+      G_WRITE_LOCK (&type_rw_lock);      
+    }
+}
+
+static gboolean
+type_iface_vtable_finalize_Wm (TypeNode       *iface,
+			       TypeNode       *node,
+			       GTypeInterface *vtable)
+{
+  IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
+  IFaceHolder *iholder;
+  
+  /* type_iface_retrieve_holder_info_Wm() doesn't modify write lock for returning NULL */
+  iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
+  if (!iholder)
+    return FALSE;	/* we don't modify write lock upon FALSE */
+  
+  g_assert (entry && entry->vtable == vtable && iholder->info);
+  
+  entry->vtable = NULL;
+  entry->init_state = UNINITIALIZED;
+  if (iholder->info->interface_finalize || iface->data->iface.vtable_finalize_base)
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      if (iholder->info->interface_finalize)
+	iholder->info->interface_finalize (vtable, iholder->info->interface_data);
+      if (iface->data->iface.vtable_finalize_base)
+	iface->data->iface.vtable_finalize_base (vtable);
+      G_WRITE_LOCK (&type_rw_lock);
+    }
+  vtable->g_type = 0;
+  vtable->g_instance_type = 0;
+  g_free (vtable);
+  
+  type_iface_blow_holder_info_Wm (iface, NODE_TYPE (node));
+  
+  return TRUE;	/* write lock modified */
+}
+
+static void
+type_class_init_Wm (TypeNode   *node,
+		    GTypeClass *pclass)
+{
+  GSList *slist, *init_slist = NULL;
+  GTypeClass *class;
+  IFaceEntries *entries;
+  IFaceEntry *entry;
+  TypeNode *bnode, *pnode;
+  guint i;
+  
+  /* Accessing data->class will work for instantiable types
+   * too because ClassData is a subset of InstanceData
+   */
+  g_assert (node->is_classed && node->data &&
+	    node->data->class.class_size &&
+	    !node->data->class.class &&
+	    node->data->class.init_state == UNINITIALIZED);
+  if (node->data->class.class_private_size)
+    class = g_malloc0 (ALIGN_STRUCT (node->data->class.class_size) + node->data->class.class_private_size);
+  else
+    class = g_malloc0 (node->data->class.class_size);
+  node->data->class.class = class;
+  g_atomic_int_set (&node->data->class.init_state, BASE_CLASS_INIT);
+  
+  if (pclass)
+    {
+      TypeNode *pnode = lookup_type_node_I (pclass->g_type);
+      
+      memcpy (class, pclass, pnode->data->class.class_size);
+      memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node->data->class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode->data->class.class_size)), pnode->data->class.class_private_size);
+
+      if (node->is_instantiatable)
+	{
+	  /* We need to initialize the private_size here rather than in
+	   * type_data_make_W() since the class init for the parent
+	   * class may have changed pnode->data->instance.private_size.
+	   */
+	  node->data->instance.private_size = pnode->data->instance.private_size;
+	}
+    }
+  class->g_type = NODE_TYPE (node);
+  
+  G_WRITE_UNLOCK (&type_rw_lock);
+  
+  /* stack all base class initialization functions, so we
+   * call them in ascending order.
+   */
+  for (bnode = node; bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
+    if (bnode->data->class.class_init_base)
+      init_slist = g_slist_prepend (init_slist, (gpointer) bnode->data->class.class_init_base);
+  for (slist = init_slist; slist; slist = slist->next)
+    {
+      GBaseInitFunc class_init_base = (GBaseInitFunc) slist->data;
+      
+      class_init_base (class);
+    }
+  g_slist_free (init_slist);
+  
+  G_WRITE_LOCK (&type_rw_lock);
+
+  g_atomic_int_set (&node->data->class.init_state, BASE_IFACE_INIT);
+  
+  /* Before we initialize the class, base initialize all interfaces, either
+   * from parent, or through our holder info
+   */
+  pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+
+  i = 0;
+  while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &&
+	  i < IFACE_ENTRIES_N_ENTRIES (entries))
+    {
+      entry = &entries->entry[i];
+      while (i < IFACE_ENTRIES_N_ENTRIES (entries) &&
+	     entry->init_state == IFACE_INIT)
+	{
+	  entry++;
+	  i++;
+	}
+
+      if (i == IFACE_ENTRIES_N_ENTRIES (entries))
+	break;
+
+      if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry->iface_type), node))
+	{
+	  guint j;
+	  IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);
+	  
+	  /* need to get this interface from parent, type_iface_vtable_base_init_Wm()
+	   * doesn't modify write lock upon FALSE, so entry is still valid; 
+	   */
+	  g_assert (pnode != NULL);
+
+	  if (pentries)
+	    for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (pentries); j++)
+	      {
+		IFaceEntry *pentry = &pentries->entry[j];
+
+		if (pentry->iface_type == entry->iface_type)
+		  {
+		    entry->vtable = pentry->vtable;
+		    entry->init_state = INITIALIZED;
+		    break;
+		  }
+	      }
+	  g_assert (entry->vtable != NULL);
+	}
+
+      /* If the write lock was released, additional interface entries might
+       * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they'll
+       * be base-initialized when inserted, so we don't have to worry that
+       * we might miss them. Uninitialized entries can only be moved higher
+       * when new ones are inserted.
+       */
+      i++;
+    }
+  
+  g_atomic_int_set (&node->data->class.init_state, CLASS_INIT);
+  
+  G_WRITE_UNLOCK (&type_rw_lock);
+
+  if (node->data->class.class_init)
+    node->data->class.class_init (class, (gpointer) node->data->class.class_data);
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  
+  g_atomic_int_set (&node->data->class.init_state, IFACE_INIT);
+  
+  /* finish initializing the interfaces through our holder info.
+   * inherited interfaces are already init_state == INITIALIZED, because
+   * they either got setup in the above base_init loop, or during
+   * class_init from within type_add_interface_Wm() for this or
+   * an anchestor type.
+   */
+  i = 0;
+  while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
+    {
+      entry = &entries->entry[i];
+      while (i < IFACE_ENTRIES_N_ENTRIES (entries) &&
+	     entry->init_state == INITIALIZED)
+	{
+	  entry++;
+	  i++;
+	}
+
+      if (i == IFACE_ENTRIES_N_ENTRIES (entries))
+	break;
+
+      type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry->iface_type), node);
+      
+      /* As in the loop above, additional initialized entries might be inserted
+       * if the write lock is released, but that's harmless because the entries
+       * we need to initialize only move higher in the list.
+       */
+      i++;
+    }
+  
+  g_atomic_int_set (&node->data->class.init_state, INITIALIZED);
+}
+
+static void
+type_data_finalize_class_ifaces_Wm (TypeNode *node)
+{
+  guint i;
+  IFaceEntries *entries;
+
+  g_assert (node->is_instantiatable && node->data && node->data->class.class && NODE_REFCOUNT (node) == 0);
+
+ reiterate:
+  entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
+  for (i = 0; entries != NULL && i < IFACE_ENTRIES_N_ENTRIES (entries); i++)
+    {
+      IFaceEntry *entry = &entries->entry[i];
+      if (entry->vtable)
+	{
+          if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry->iface_type), node, entry->vtable))
+            {
+              /* refetch entries, IFACES_ENTRIES might be modified */
+              goto reiterate;
+            }
+          else
+            {
+              /* type_iface_vtable_finalize_Wm() doesn't modify write lock upon FALSE,
+               * iface vtable came from parent
+               */
+              entry->vtable = NULL;
+              entry->init_state = UNINITIALIZED;
+            }
+	}
+    }
+}
+
+static void
+type_data_finalize_class_U (TypeNode  *node,
+			    ClassData *cdata)
+{
+  GTypeClass *class = cdata->class;
+  TypeNode *bnode;
+  
+  g_assert (cdata->class && NODE_REFCOUNT (node) == 0);
+  
+  if (cdata->class_finalize)
+    cdata->class_finalize (class, (gpointer) cdata->class_data);
+  
+  /* call all base class destruction functions in descending order
+   */
+  if (cdata->class_finalize_base)
+    cdata->class_finalize_base (class);
+  for (bnode = lookup_type_node_I (NODE_PARENT_TYPE (node)); bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
+    if (bnode->data->class.class_finalize_base)
+      bnode->data->class.class_finalize_base (class);
+  
+  g_free (cdata->class);
+}
+
+static void
+type_data_last_unref_Wm (TypeNode *node,
+			 gboolean  uncached)
+{
+  g_return_if_fail (node != NULL && node->plugin != NULL);
+  
+  if (!node->data || NODE_REFCOUNT (node) == 0)
+    {
+      g_warning ("cannot drop last reference to unreferenced type '%s'",
+		 NODE_NAME (node));
+      return;
+    }
+
+  /* call class cache hooks */
+  if (node->is_classed && node->data && node->data->class.class && static_n_class_cache_funcs && !uncached)
+    {
+      guint i;
+      
+      G_WRITE_UNLOCK (&type_rw_lock);
+      G_READ_LOCK (&type_rw_lock);
+      for (i = 0; i < static_n_class_cache_funcs; i++)
+	{
+	  GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;
+	  gpointer cache_data = static_class_cache_funcs[i].cache_data;
+	  gboolean need_break;
+	  
+	  G_READ_UNLOCK (&type_rw_lock);
+	  need_break = cache_func (cache_data, node->data->class.class);
+	  G_READ_LOCK (&type_rw_lock);
+	  if (!node->data || NODE_REFCOUNT (node) == 0)
+	    INVALID_RECURSION ("GType class cache function ", cache_func, NODE_NAME (node));
+	  if (need_break)
+	    break;
+	}
+      G_READ_UNLOCK (&type_rw_lock);
+      G_WRITE_LOCK (&type_rw_lock);
+    }
+  
+  /* may have been re-referenced meanwhile */
+  if (g_atomic_int_dec_and_test ((int *) &node->ref_count))
+    {
+      GType ptype = NODE_PARENT_TYPE (node);
+      TypeData *tdata;
+      
+      if (node->is_instantiatable)
+	{
+	  /* destroy node->data->instance.mem_chunk */
+	}
+      
+      tdata = node->data;
+      if (node->is_classed && tdata->class.class)
+	{
+	  if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)
+	    type_data_finalize_class_ifaces_Wm (node);
+	  node->mutatable_check_cache = FALSE;
+	  node->data = NULL;
+	  G_WRITE_UNLOCK (&type_rw_lock);
+	  type_data_finalize_class_U (node, &tdata->class);
+	  G_WRITE_LOCK (&type_rw_lock);
+	}
+      else if (NODE_IS_IFACE (node) && tdata->iface.dflt_vtable)
+        {
+          node->mutatable_check_cache = FALSE;
+          node->data = NULL;
+          if (tdata->iface.dflt_finalize || tdata->iface.vtable_finalize_base)
+            {
+              G_WRITE_UNLOCK (&type_rw_lock);
+              if (tdata->iface.dflt_finalize)
+                tdata->iface.dflt_finalize (tdata->iface.dflt_vtable, (gpointer) tdata->iface.dflt_data);
+              if (tdata->iface.vtable_finalize_base)
+                tdata->iface.vtable_finalize_base (tdata->iface.dflt_vtable);
+              G_WRITE_LOCK (&type_rw_lock);
+            }
+          g_free (tdata->iface.dflt_vtable);
+        }
+      else
+        {
+          node->mutatable_check_cache = FALSE;
+          node->data = NULL;
+        }
+
+      /* freeing tdata->common.value_table and its contents is taken care of
+       * by allocating it in one chunk with tdata
+       */
+      g_free (tdata);
+      
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_type_plugin_unuse (node->plugin);
+      if (ptype)
+	type_data_unref_U (lookup_type_node_I (ptype), FALSE);
+      G_WRITE_LOCK (&type_rw_lock);
+    }
+}
+
+static inline void
+type_data_unref_U (TypeNode *node,
+                   gboolean  uncached)
+{
+  guint current;
+
+  do {
+    current = NODE_REFCOUNT (node);
+
+    if (current <= 1)
+    {
+      if (!node->plugin)
+	{
+	  g_warning ("static type '%s' unreferenced too often",
+		     NODE_NAME (node));
+	  return;
+	}
+      else
+        {
+          /* This is the last reference of a type from a plugin.  We are
+           * experimentally disabling support for unloading type
+           * plugins, so don't allow the last ref to drop.
+           */
+          return;
+        }
+
+      g_assert (current > 0);
+
+      g_rec_mutex_lock (&class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
+      G_WRITE_LOCK (&type_rw_lock);
+      type_data_last_unref_Wm (node, uncached);
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_rec_mutex_unlock (&class_init_rec_mutex);
+      return;
+    }
+  } while (!g_atomic_int_compare_and_exchange ((int *) &node->ref_count, current, current - 1));
+}
+
+/**
+ * g_type_add_class_cache_func: (skip)
+ * @cache_data: data to be passed to @cache_func
+ * @cache_func: a #GTypeClassCacheFunc
+ *
+ * Adds a #GTypeClassCacheFunc to be called before the reference count of a
+ * class goes from one to zero. This can be used to prevent premature class
+ * destruction. All installed #GTypeClassCacheFunc functions will be chained
+ * until one of them returns %TRUE. The functions have to check the class id
+ * passed in to figure whether they actually want to cache the class of this
+ * type, since all classes are routed through the same #GTypeClassCacheFunc
+ * chain.
+ */
+void
+g_type_add_class_cache_func (gpointer            cache_data,
+			     GTypeClassCacheFunc cache_func)
+{
+  guint i;
+  
+  g_return_if_fail (cache_func != NULL);
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  i = static_n_class_cache_funcs++;
+  static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
+  static_class_cache_funcs[i].cache_data = cache_data;
+  static_class_cache_funcs[i].cache_func = cache_func;
+  G_WRITE_UNLOCK (&type_rw_lock);
+}
+
+/**
+ * g_type_remove_class_cache_func: (skip)
+ * @cache_data: data that was given when adding @cache_func
+ * @cache_func: a #GTypeClassCacheFunc
+ *
+ * Removes a previously installed #GTypeClassCacheFunc. The cache
+ * maintained by @cache_func has to be empty when calling
+ * g_type_remove_class_cache_func() to avoid leaks.
+ */
+void
+g_type_remove_class_cache_func (gpointer            cache_data,
+				GTypeClassCacheFunc cache_func)
+{
+  gboolean found_it = FALSE;
+  guint i;
+  
+  g_return_if_fail (cache_func != NULL);
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  for (i = 0; i < static_n_class_cache_funcs; i++)
+    if (static_class_cache_funcs[i].cache_data == cache_data &&
+	static_class_cache_funcs[i].cache_func == cache_func)
+      {
+	static_n_class_cache_funcs--;
+	memmove (static_class_cache_funcs + i,
+                 static_class_cache_funcs + i + 1,
+                 sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
+	static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
+	found_it = TRUE;
+	break;
+      }
+  G_WRITE_UNLOCK (&type_rw_lock);
+  
+  if (!found_it)
+    g_warning (G_STRLOC ": cannot remove unregistered class cache func %p with data %p",
+	       cache_func, cache_data);
+}
+
+
+/**
+ * g_type_add_interface_check: (skip)
+ * @check_data: data to pass to @check_func
+ * @check_func: function to be called after each interface
+ *     is initialized
+ *
+ * Adds a function to be called after an interface vtable is
+ * initialized for any class (i.e. after the @interface_init
+ * member of #GInterfaceInfo has been called).
+ *
+ * This function is useful when you want to check an invariant
+ * that depends on the interfaces of a class. For instance, the
+ * implementation of #GObject uses this facility to check that an
+ * object implements all of the properties that are defined on its
+ * interfaces.
+ *
+ * Since: 2.4
+ */
+void
+g_type_add_interface_check (gpointer	            check_data,
+			    GTypeInterfaceCheckFunc check_func)
+{
+  guint i;
+  
+  g_return_if_fail (check_func != NULL);
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  i = static_n_iface_check_funcs++;
+  static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
+  static_iface_check_funcs[i].check_data = check_data;
+  static_iface_check_funcs[i].check_func = check_func;
+  G_WRITE_UNLOCK (&type_rw_lock);
+}
+
+/**
+ * g_type_remove_interface_check: (skip)
+ * @check_data: callback data passed to g_type_add_interface_check()
+ * @check_func: callback function passed to g_type_add_interface_check()
+ *
+ * Removes an interface check function added with
+ * g_type_add_interface_check().
+ *
+ * Since: 2.4
+ */
+void
+g_type_remove_interface_check (gpointer                check_data,
+			       GTypeInterfaceCheckFunc check_func)
+{
+  gboolean found_it = FALSE;
+  guint i;
+  
+  g_return_if_fail (check_func != NULL);
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  for (i = 0; i < static_n_iface_check_funcs; i++)
+    if (static_iface_check_funcs[i].check_data == check_data &&
+	static_iface_check_funcs[i].check_func == check_func)
+      {
+	static_n_iface_check_funcs--;
+	memmove (static_iface_check_funcs + i,
+                 static_iface_check_funcs + i + 1,
+                 sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
+	static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
+	found_it = TRUE;
+	break;
+      }
+  G_WRITE_UNLOCK (&type_rw_lock);
+  
+  if (!found_it)
+    g_warning (G_STRLOC ": cannot remove unregistered class check func %p with data %p",
+	       check_func, check_data);
+}
+
+/* --- type registration --- */
+/**
+ * g_type_register_fundamental:
+ * @type_id: a predefined type identifier
+ * @type_name: 0-terminated string used as the name of the new type
+ * @info: #GTypeInfo structure for this type
+ * @finfo: #GTypeFundamentalInfo structure for this type
+ * @flags: bitwise combination of #GTypeFlags values
+ *
+ * Registers @type_id as the predefined identifier and @type_name as the
+ * name of a fundamental type. If @type_id is already registered, or a
+ * type named @type_name is already registered, the behaviour is undefined.
+ * The type system uses the information contained in the #GTypeInfo structure
+ * pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
+ * @finfo to manage the type and its instances. The value of @flags determines
+ * additional characteristics of the fundamental type.
+ *
+ * Returns: the predefined type identifier
+ */
+GType
+g_type_register_fundamental (GType                       type_id,
+			     const gchar                *type_name,
+			     const GTypeInfo            *info,
+			     const GTypeFundamentalInfo *finfo,
+			     GTypeFlags			 flags)
+{
+  TypeNode *node;
+  
+  g_assert_type_system_initialized ();
+  g_return_val_if_fail (type_id > 0, 0);
+  g_return_val_if_fail (type_name != NULL, 0);
+  g_return_val_if_fail (info != NULL, 0);
+  g_return_val_if_fail (finfo != NULL, 0);
+  
+  if (!check_type_name_I (type_name))
+    return 0;
+  if ((type_id & TYPE_ID_MASK) ||
+      type_id > G_TYPE_FUNDAMENTAL_MAX)
+    {
+      g_warning ("attempt to register fundamental type '%s' with invalid type id (%" G_GSIZE_FORMAT ")",
+		 type_name,
+		 type_id);
+      return 0;
+    }
+  if ((finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE) &&
+      !(finfo->type_flags & G_TYPE_FLAG_CLASSED))
+    {
+      g_warning ("cannot register instantiatable fundamental type '%s' as non-classed",
+		 type_name);
+      return 0;
+    }
+  if (lookup_type_node_I (type_id))
+    {
+      g_warning ("cannot register existing fundamental type '%s' (as '%s')",
+		 type_descriptive_name_I (type_id),
+		 type_name);
+      return 0;
+    }
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  node = type_node_fundamental_new_W (type_id, type_name, finfo->type_flags);
+  type_add_flags_W (node, flags);
+  
+  if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
+    type_data_make_W (node, info,
+		      check_value_table_I (type_name, info->value_table) ? info->value_table : NULL);
+  G_WRITE_UNLOCK (&type_rw_lock);
+  
+  return NODE_TYPE (node);
+}
+
+/**
+ * g_type_register_static_simple: (skip)
+ * @parent_type: type from which this type will be derived
+ * @type_name: 0-terminated string used as the name of the new type
+ * @class_size: size of the class structure (see #GTypeInfo)
+ * @class_init: location of the class initialization function (see #GTypeInfo)
+ * @instance_size: size of the instance structure (see #GTypeInfo)
+ * @instance_init: location of the instance initialization function (see #GTypeInfo)
+ * @flags: bitwise combination of #GTypeFlags values
+ *
+ * Registers @type_name as the name of a new static type derived from
+ * @parent_type.  The value of @flags determines the nature (e.g.
+ * abstract or not) of the type. It works by filling a #GTypeInfo
+ * struct and calling g_type_register_static().
+ *
+ * Since: 2.12
+ *
+ * Returns: the new type identifier
+ */
+GType
+g_type_register_static_simple (GType             parent_type,
+			       const gchar      *type_name,
+			       guint             class_size,
+			       GClassInitFunc    class_init,
+			       guint             instance_size,
+			       GInstanceInitFunc instance_init,
+			       GTypeFlags	 flags)
+{
+  GTypeInfo info;
+
+  /* Instances are not allowed to be larger than this. If you have a big
+   * fixed-length array or something, point to it instead.
+   */
+  g_return_val_if_fail (class_size <= G_MAXUINT16, G_TYPE_INVALID);
+  g_return_val_if_fail (instance_size <= G_MAXUINT16, G_TYPE_INVALID);
+
+  info.class_size = class_size;
+  info.base_init = NULL;
+  info.base_finalize = NULL;
+  info.class_init = class_init;
+  info.class_finalize = NULL;
+  info.class_data = NULL;
+  info.instance_size = instance_size;
+  info.n_preallocs = 0;
+  info.instance_init = instance_init;
+  info.value_table = NULL;
+
+  return g_type_register_static (parent_type, type_name, &info, flags);
+}
+
+/**
+ * g_type_register_static:
+ * @parent_type: type from which this type will be derived
+ * @type_name: 0-terminated string used as the name of the new type
+ * @info: #GTypeInfo structure for this type
+ * @flags: bitwise combination of #GTypeFlags values
+ *
+ * Registers @type_name as the name of a new static type derived from
+ * @parent_type. The type system uses the information contained in the
+ * #GTypeInfo structure pointed to by @info to manage the type and its
+ * instances (if not abstract). The value of @flags determines the nature
+ * (e.g. abstract or not) of the type.
+ *
+ * Returns: the new type identifier
+ */
+GType
+g_type_register_static (GType            parent_type,
+			const gchar     *type_name,
+			const GTypeInfo *info,
+			GTypeFlags	 flags)
+{
+  TypeNode *pnode, *node;
+  GType type = 0;
+  
+  g_assert_type_system_initialized ();
+  g_return_val_if_fail (parent_type > 0, 0);
+  g_return_val_if_fail (type_name != NULL, 0);
+  g_return_val_if_fail (info != NULL, 0);
+  
+  if (!check_type_name_I (type_name) ||
+      !check_derivation_I (parent_type, type_name))
+    return 0;
+  if (info->class_finalize)
+    {
+      g_warning ("class finalizer specified for static type '%s'",
+		 type_name);
+      return 0;
+    }
+  
+  pnode = lookup_type_node_I (parent_type);
+  G_WRITE_LOCK (&type_rw_lock);
+  type_data_ref_Wm (pnode);
+  if (check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (pnode), type_name, info))
+    {
+      node = type_node_new_W (pnode, type_name, NULL);
+      type_add_flags_W (node, flags);
+      type = NODE_TYPE (node);
+      type_data_make_W (node, info,
+			check_value_table_I (type_name, info->value_table) ? info->value_table : NULL);
+    }
+  G_WRITE_UNLOCK (&type_rw_lock);
+  
+  return type;
+}
+
+/**
+ * g_type_register_dynamic:
+ * @parent_type: type from which this type will be derived
+ * @type_name: 0-terminated string used as the name of the new type
+ * @plugin: #GTypePlugin structure to retrieve the #GTypeInfo from
+ * @flags: bitwise combination of #GTypeFlags values
+ *
+ * Registers @type_name as the name of a new dynamic type derived from
+ * @parent_type.  The type system uses the information contained in the
+ * #GTypePlugin structure pointed to by @plugin to manage the type and its
+ * instances (if not abstract).  The value of @flags determines the nature
+ * (e.g. abstract or not) of the type.
+ *
+ * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
+ */
+GType
+g_type_register_dynamic (GType        parent_type,
+			 const gchar *type_name,
+			 GTypePlugin *plugin,
+			 GTypeFlags   flags)
+{
+  TypeNode *pnode, *node;
+  GType type;
+  
+  g_assert_type_system_initialized ();
+  g_return_val_if_fail (parent_type > 0, 0);
+  g_return_val_if_fail (type_name != NULL, 0);
+  g_return_val_if_fail (plugin != NULL, 0);
+  
+  if (!check_type_name_I (type_name) ||
+      !check_derivation_I (parent_type, type_name) ||
+      !check_plugin_U (plugin, TRUE, FALSE, type_name))
+    return 0;
+  
+  G_WRITE_LOCK (&type_rw_lock);
+  pnode = lookup_type_node_I (parent_type);
+  node = type_node_new_W (pnode, type_name, plugin);
+  type_add_flags_W (node, flags);
+  type = NODE_TYPE (node);
+  G_WRITE_UNLOCK (&type_rw_lock);
+  
+  return type;
+}
+
+/**
+ * g_type_add_interface_static:
+ * @instance_type: #GType value of an instantiable type
+ * @interface_type: #GType value of an interface type
+ * @info: #GInterfaceInfo structure for this
+ *        (@instance_type, @interface_type) combination
+ *
+ * Adds the static @interface_type to @instantiable_type.
+ * The information contained in the #GInterfaceInfo structure
+ * pointed to by @info is used to manage the relationship.
+ */
+void
+g_type_add_interface_static (GType                 instance_type,
+			     GType                 interface_type,
+			     const GInterfaceInfo *info)
+{
+  /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
+  g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
+  g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
+
+  /* we only need to lock class_init_rec_mutex if instance_type already has its
+   * class initialized, however this function is rarely enough called to take
+   * the simple route and always acquire class_init_rec_mutex.
+   */
+  g_rec_mutex_lock (&class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
+  G_WRITE_LOCK (&type_rw_lock);
+  if (check_add_interface_L (instance_type, interface_type))
+    {
+      TypeNode *node = lookup_type_node_I (instance_type);
+      TypeNode *iface = lookup_type_node_I (interface_type);
+      if (check_interface_info_I (iface, NODE_TYPE (node), info))
+        type_add_interface_Wm (node, iface, info, NULL);
+    }
+  G_WRITE_UNLOCK (&type_rw_lock);
+  g_rec_mutex_unlock (&class_init_rec_mutex);
+}
+
+/**
+ * g_type_add_interface_dynamic:
+ * @instance_type: #GType value of an instantiable type
+ * @interface_type: #GType value of an interface type
+ * @plugin: #GTypePlugin structure to retrieve the #GInterfaceInfo from
+ *
+ * Adds the dynamic @interface_type to @instantiable_type. The information
+ * contained in the #GTypePlugin structure pointed to by @plugin
+ * is used to manage the relationship.
+ */
+void
+g_type_add_interface_dynamic (GType        instance_type,
+			      GType        interface_type,
+			      GTypePlugin *plugin)
+{
+  TypeNode *node;
+  /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
+  g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
+  g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
+
+  node = lookup_type_node_I (instance_type);
+  if (!check_plugin_U (plugin, FALSE, TRUE, NODE_NAME (node)))
+    return;
+
+  /* see comment in g_type_add_interface_static() about class_init_rec_mutex */
+  g_rec_mutex_lock (&class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
+  G_WRITE_LOCK (&type_rw_lock);
+  if (check_add_interface_L (instance_type, interface_type))
+    {
+      TypeNode *iface = lookup_type_node_I (interface_type);
+      type_add_interface_Wm (node, iface, NULL, plugin);
+    }
+  G_WRITE_UNLOCK (&type_rw_lock);
+  g_rec_mutex_unlock (&class_init_rec_mutex);
+}
+
+
+/* --- public API functions --- */
+/**
+ * g_type_class_ref:
+ * @type: type ID of a classed type
+ *
+ * Increments the reference count of the class structure belonging to
+ * @type. This function will demand-create the class if it doesn't
+ * exist already.
+ *
+ * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
+ *     structure for the given type ID
+ */
+gpointer
+g_type_class_ref (GType type)
+{
+  TypeNode *node;
+  GType ptype;
+  gboolean holds_ref;
+  GTypeClass *pclass;
+
+  /* optimize for common code path */
+  node = lookup_type_node_I (type);
+  if (!node || !node->is_classed)
+    {
+      g_warning ("cannot retrieve class for invalid (unclassed) type '%s'",
+		 type_descriptive_name_I (type));
+      return NULL;
+    }
+
+  if (G_LIKELY (type_data_ref_U (node)))
+    {
+      if (G_LIKELY (g_atomic_int_get (&node->data->class.init_state) == INITIALIZED))
+        return node->data->class.class;
+      holds_ref = TRUE;
+    }
+  else
+    holds_ref = FALSE;
+  
+  /* here, we either have node->data->class.class == NULL, or a recursive
+   * call to g_type_class_ref() with a partly initialized class, or
+   * node->data->class.init_state == INITIALIZED, because any
+   * concurrently running initialization was guarded by class_init_rec_mutex.
+   */
+  g_rec_mutex_lock (&class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
+
+  /* we need an initialized parent class for initializing derived classes */
+  ptype = NODE_PARENT_TYPE (node);
+  pclass = ptype ? g_type_class_ref (ptype) : NULL;
+
+  G_WRITE_LOCK (&type_rw_lock);
+
+  if (!holds_ref)
+    type_data_ref_Wm (node);
+
+  if (!node->data->class.class) /* class uninitialized */
+    type_class_init_Wm (node, pclass);
+
+  G_WRITE_UNLOCK (&type_rw_lock);
+
+  if (pclass)
+    g_type_class_unref (pclass);
+
+  g_rec_mutex_unlock (&class_init_rec_mutex);
+
+  return node->data->class.class;
+}
+
+/**
+ * g_type_class_unref:
+ * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
+ *
+ * Decrements the reference count of the class structure being passed in.
+ * Once the last reference count of a class has been released, classes
+ * may be finalized by the type system, so further dereferencing of a
+ * class pointer after g_type_class_unref() are invalid.
+ */
+void
+g_type_class_unref (gpointer g_class)
+{
+  TypeNode *node;
+  GTypeClass *class = g_class;
+  
+  g_return_if_fail (g_class != NULL);
+  
+  node = lookup_type_node_I (class->g_type);
+  if (node && node->is_classed && NODE_REFCOUNT (node))
+    type_data_unref_U (node, FALSE);
+  else
+    g_warning ("cannot unreference class of invalid (unclassed) type '%s'",
+	       type_descriptive_name_I (class->g_type));
+}
+
+/**
+ * g_type_class_unref_uncached: (skip)
+ * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
+ *
+ * A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
+ * implementations. It unreferences a class without consulting the chain
+ * of #GTypeClassCacheFuncs, avoiding the recursion which would occur
+ * otherwise.
+ */
+void
+g_type_class_unref_uncached (gpointer g_class)
+{
+  TypeNode *node;
+  GTypeClass *class = g_class;
+  
+  g_return_if_fail (g_class != NULL);
+  
+  node = lookup_type_node_I (class->g_type);
+  if (node && node->is_classed && NODE_REFCOUNT (node))
+    type_data_unref_U (node, TRUE);
+  else
+    g_warning ("cannot unreference class of invalid (unclassed) type '%s'",
+	       type_descriptive_name_I (class->g_type));
+}
+
+/**
+ * g_type_class_peek:
+ * @type: type ID of a classed type
+ *
+ * This function is essentially the same as g_type_class_ref(),
+ * except that the classes reference count isn't incremented.
+ * As a consequence, this function may return %NULL if the class
+ * of the type passed in does not currently exist (hasn't been
+ * referenced before).
+ *
+ * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
+ *     structure for the given type ID or %NULL if the class does not
+ *     currently exist
+ */
+gpointer
+g_type_class_peek (GType type)
+{
+  TypeNode *node;
+  gpointer class;
+  
+  node = lookup_type_node_I (type);
+  if (node && node->is_classed && NODE_REFCOUNT (node) &&
+      g_atomic_int_get (&node->data->class.init_state) == INITIALIZED)
+    /* ref_count _may_ be 0 */
+    class = node->data->class.class;
+  else
+    class = NULL;
+  
+  return class;
+}
+
+/**
+ * g_type_class_peek_static:
+ * @type: type ID of a classed type
+ *
+ * A more efficient version of g_type_class_peek() which works only for
+ * static types.
+ * 
+ * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
+ *     structure for the given type ID or %NULL if the class does not
+ *     currently exist or is dynamically loaded
+ *
+ * Since: 2.4
+ */
+gpointer
+g_type_class_peek_static (GType type)
+{
+  TypeNode *node;
+  gpointer class;
+  
+  node = lookup_type_node_I (type);
+  if (node && node->is_classed && NODE_REFCOUNT (node) &&
+      /* peek only static types: */ node->plugin == NULL &&
+      g_atomic_int_get (&node->data->class.init_state) == INITIALIZED)
+    /* ref_count _may_ be 0 */
+    class = node->data->class.class;
+  else
+    class = NULL;
+  
+  return class;
+}
+
+/**
+ * g_type_class_peek_parent:
+ * @g_class: (type GObject.TypeClass): the #GTypeClass structure to
+ *     retrieve the parent class for
+ *
+ * This is a convenience function often needed in class initializers.
+ * It returns the class structure of the immediate parent type of the
+ * class passed in.  Since derived classes hold a reference count on
+ * their parent classes as long as they are instantiated, the returned
+ * class will always exist.
+ *
+ * This function is essentially equivalent to:
+ * g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))
+ *
+ * Returns: (type GObject.TypeClass) (transfer none): the parent class
+ *     of @g_class
+ */
+gpointer
+g_type_class_peek_parent (gpointer g_class)
+{
+  TypeNode *node;
+  gpointer class = NULL;
+  
+  g_return_val_if_fail (g_class != NULL, NULL);
+  
+  node = lookup_type_node_I (G_TYPE_FROM_CLASS (g_class));
+  /* We used to acquire a read lock here. That is not necessary, since 
+   * parent->data->class.class is constant as long as the derived class
+   * exists. 
+   */
+  if (node && node->is_classed && node->data && NODE_PARENT_TYPE (node))
+    {
+      node = lookup_type_node_I (NODE_PARENT_TYPE (node));
+      class = node->data->class.class;
+    }
+  else if (NODE_PARENT_TYPE (node))
+    g_warning (G_STRLOC ": invalid class pointer '%p'", g_class);
+  
+  return class;
+}
+
+/**
+ * g_type_interface_peek:
+ * @instance_class: (type GObject.TypeClass): a #GTypeClass structure
+ * @iface_type: an interface ID which this class conforms to
+ *
+ * Returns the #GTypeInterface structure of an interface to which the
+ * passed in class conforms.
+ *
+ * Returns: (type GObject.TypeInterface) (transfer none): the #GTypeInterface
+ *     structure of @iface_type if implemented by @instance_class, %NULL
+ *     otherwise
+ */
+gpointer
+g_type_interface_peek (gpointer instance_class,
+		       GType    iface_type)
+{
+  TypeNode *node;
+  TypeNode *iface;
+  gpointer vtable = NULL;
+  GTypeClass *class = instance_class;
+  
+  g_return_val_if_fail (instance_class != NULL, NULL);
+  
+  node = lookup_type_node_I (class->g_type);
+  iface = lookup_type_node_I (iface_type);
+  if (node && node->is_instantiatable && iface)
+    type_lookup_iface_vtable_I (node, iface, &vtable);
+  else
+    g_warning (G_STRLOC ": invalid class pointer '%p'", class);
+  
+  return vtable;
+}
+
+/**
+ * g_type_interface_peek_parent:
+ * @g_iface: (type GObject.TypeInterface): a #GTypeInterface structure
+ *
+ * Returns the corresponding #GTypeInterface structure of the parent type
+ * of the instance type to which @g_iface belongs. This is useful when
+ * deriving the implementation of an interface from the parent type and
+ * then possibly overriding some methods.
+ *
+ * Returns: (transfer none) (type GObject.TypeInterface): the
+ *     corresponding #GTypeInterface structure of the parent type of the
+ *     instance type to which @g_iface belongs, or %NULL if the parent
+ *     type doesn't conform to the interface
+ */
+gpointer
+g_type_interface_peek_parent (gpointer g_iface)
+{
+  TypeNode *node;
+  TypeNode *iface;
+  gpointer vtable = NULL;
+  GTypeInterface *iface_class = g_iface;
+  
+  g_return_val_if_fail (g_iface != NULL, NULL);
+  
+  iface = lookup_type_node_I (iface_class->g_type);
+  node = lookup_type_node_I (iface_class->g_instance_type);
+  if (node)
+    node = lookup_type_node_I (NODE_PARENT_TYPE (node));
+  if (node && node->is_instantiatable && iface)
+    type_lookup_iface_vtable_I (node, iface, &vtable);
+  else if (node)
+    g_warning (G_STRLOC ": invalid interface pointer '%p'", g_iface);
+  
+  return vtable;
+}
+
+/**
+ * g_type_default_interface_ref:
+ * @g_type: an interface type
+ *
+ * Increments the reference count for the interface type @g_type,
+ * and returns the default interface vtable for the type.
+ *
+ * If the type is not currently in use, then the default vtable
+ * for the type will be created and initalized by calling
+ * the base interface init and default vtable init functions for
+ * the type (the @base_init and @class_init members of #GTypeInfo).
+ * Calling g_type_default_interface_ref() is useful when you
+ * want to make sure that signals and properties for an interface
+ * have been installed.
+ *
+ * Since: 2.4
+ *
+ * Returns: (type GObject.TypeInterface) (transfer none): the default
+ *     vtable for the interface; call g_type_default_interface_unref()
+ *     when you are done using the interface.
+ */
+gpointer
+g_type_default_interface_ref (GType g_type)
+{
+  TypeNode *node;
+  gpointer dflt_vtable;
+
+  G_WRITE_LOCK (&type_rw_lock);
+
+  node = lookup_type_node_I (g_type);
+  if (!node || !NODE_IS_IFACE (node) ||
+      (node->data && NODE_REFCOUNT (node) == 0))
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_warning ("cannot retrieve default vtable for invalid or non-interface type '%s'",
+		 type_descriptive_name_I (g_type));
+      return NULL;
+    }
+
+  if (!node->data || !node->data->iface.dflt_vtable)
+    {
+      G_WRITE_UNLOCK (&type_rw_lock);
+      g_rec_mutex_lock (&class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
+      G_WRITE_LOCK (&type_rw_lock);
+      node = lookup_type_node_I (g_type);
+      type_data_ref_Wm (node);
+      type_iface_ensure_dflt_vtable_Wm (node);
+      g_rec_mutex_unlock (&class_init_rec_mutex);
+    }
+  else
+    type_data_ref_Wm (node); /* ref_count >= 1 already */
+
+  dflt_vtable = node->data->iface.dflt_vtable;
+  G_WRITE_UNLOCK (&type_rw_lock);
+
+  return dflt_vtable;
+}
+
+/**
+ * g_type_default_interface_peek:
+ * @g_type: an interface type
+ *
+ * If the interface type @g_type is currently in use, returns its
+ * default interface vtable.
+ *
+ * Since: 2.4
+ *
+ * Returns: (type GObject.TypeInterface) (transfer none): the default
+ *     vtable for the interface, or %NULL if the type is not currently
+ *     in use
+ */
+gpointer
+g_type_default_interface_peek (GType g_type)
+{
+  TypeNode *node;
+  gpointer vtable;
+  
+  node = lookup_type_node_I (g_type);
+  if (node && NODE_IS_IFACE (node) && NODE_REFCOUNT (node))
+    vtable = node->data->iface.dflt_vtable;
+  else
+    vtable = NULL;
+  
+  return vtable;
+}
+
+/**
+ * g_type_default_interface_unref:
+ * @g_iface: (type GObject.TypeInterface): the default vtable
+ *     structure for a interface, as returned by g_type_default_interface_ref()
+ *
+ * Decrements the reference count for the type corresponding to the
+ * interface default vtable @g_iface. If the type is dynamic, then
+ * when no one is using the interface and all references have
+ * been released, the finalize function for the interface's default
+ * vtable (the @class_finalize member of #GTypeInfo) will be called.
+ *
+ * Since: 2.4
+ */
+void
+g_type_default_interface_unref (gpointer g_iface)
+{
+  TypeNode *node;
+  GTypeInterface *vtable = g_iface;
+  
+  g_return_if_fail (g_iface != NULL);
+  
+  node = lookup_type_node_I (vtable->g_type);
+  if (node && NODE_IS_IFACE (node))
+    type_data_unref_U (node, FALSE);
+  else
+    g_warning ("cannot unreference invalid interface default vtable for '%s'",
+	       type_descriptive_name_I (vtable->g_type));
+}
+
+/**
+ * g_type_name:
+ * @type: type to return name for
+ *
+ * Get the unique name that is assigned to a type ID.  Note that this
+ * function (like all other GType API) cannot cope with invalid type
+ * IDs. %G_TYPE_INVALID may be passed to this function, as may be any
+ * other validly registered type ID, but randomized type IDs should
+ * not be passed in and will most likely lead to a crash.
+ *
+ * Returns: static type name or %NULL
+ */
+const gchar *
+g_type_name (GType type)
+{
+  TypeNode *node;
+  
+  g_assert_type_system_initialized ();
+  
+  node = lookup_type_node_I (type);
+  
+  return node ? NODE_NAME (node) : NULL;
+}
+
+/**
+ * g_type_qname:
+ * @type: type to return quark of type name for
+ *
+ * Get the corresponding quark of the type IDs name.
+ *
+ * Returns: the type names quark or 0
+ */
+GQuark
+g_type_qname (GType type)
+{
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  
+  return node ? node->qname : 0;
+}
+
+/**
+ * g_type_from_name:
+ * @name: type name to lookup
+ *
+ * Lookup the type ID from a given type name, returning 0 if no type
+ * has been registered under this name (this is the preferred method
+ * to find out by name whether a specific type has been registered
+ * yet).
+ *
+ * Returns: corresponding type ID or 0
+ */
+GType
+g_type_from_name (const gchar *name)
+{
+  GType type = 0;
+  
+  g_return_val_if_fail (name != NULL, 0);
+  
+  G_READ_LOCK (&type_rw_lock);
+  type = (GType) g_hash_table_lookup (static_type_nodes_ht, name);
+  G_READ_UNLOCK (&type_rw_lock);
+  
+  return type;
+}
+
+/**
+ * g_type_parent:
+ * @type: the derived type
+ *
+ * Return the direct parent type of the passed in type. If the passed
+ * in type has no parent, i.e. is a fundamental type, 0 is returned.
+ *
+ * Returns: the parent type
+ */
+GType
+g_type_parent (GType type)
+{
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  
+  return node ? NODE_PARENT_TYPE (node) : 0;
+}
+
+/**
+ * g_type_depth:
+ * @type: a #GType
+ *
+ * Returns the length of the ancestry of the passed in type. This
+ * includes the type itself, so that e.g. a fundamental type has depth 1.
+ *
+ * Returns: the depth of @type
+ */
+guint
+g_type_depth (GType type)
+{
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  
+  return node ? node->n_supers + 1 : 0;
+}
+
+/**
+ * g_type_next_base:
+ * @leaf_type: descendant of @root_type and the type to be returned
+ * @root_type: immediate parent of the returned type
+ *
+ * Given a @leaf_type and a @root_type which is contained in its
+ * anchestry, return the type that @root_type is the immediate parent
+ * of. In other words, this function determines the type that is
+ * derived directly from @root_type which is also a base class of
+ * @leaf_type.  Given a root type and a leaf type, this function can
+ * be used to determine the types and order in which the leaf type is
+ * descended from the root type.
+ *
+ * Returns: immediate child of @root_type and anchestor of @leaf_type
+ */
+GType
+g_type_next_base (GType type,
+		  GType base_type)
+{
+  GType atype = 0;
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  if (node)
+    {
+      TypeNode *base_node = lookup_type_node_I (base_type);
+      
+      if (base_node && base_node->n_supers < node->n_supers)
+	{
+	  guint n = node->n_supers - base_node->n_supers;
+	  
+	  if (node->supers[n] == base_type)
+	    atype = node->supers[n - 1];
+	}
+    }
+  
+  return atype;
+}
+
+static inline gboolean
+type_node_check_conformities_UorL (TypeNode *node,
+				   TypeNode *iface_node,
+				   /*        support_inheritance */
+				   gboolean  support_interfaces,
+				   gboolean  support_prerequisites,
+				   gboolean  have_lock)
+{
+  gboolean match;
+
+  if (/* support_inheritance && */
+      NODE_IS_ANCESTOR (iface_node, node))
+    return TRUE;
+
+  support_interfaces = support_interfaces && node->is_instantiatable && NODE_IS_IFACE (iface_node);
+  support_prerequisites = support_prerequisites && NODE_IS_IFACE (node);
+  match = FALSE;
+  if (support_interfaces)
+    {
+      if (have_lock)
+	{
+	  if (type_lookup_iface_entry_L (node, iface_node))
+	    match = TRUE;
+	}
+      else
+	{
+	  if (type_lookup_iface_vtable_I (node, iface_node, NULL))
+	    match = TRUE;
+	}
+    }
+  if (!match &&
+      support_prerequisites)
+    {
+      if (!have_lock)
+	G_READ_LOCK (&type_rw_lock);
+      if (support_prerequisites && type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
+	match = TRUE;
+      if (!have_lock)
+	G_READ_UNLOCK (&type_rw_lock);
+    }
+  return match;
+}
+
+static gboolean
+type_node_is_a_L (TypeNode *node,
+		  TypeNode *iface_node)
+{
+  return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
+}
+
+static inline gboolean
+type_node_conforms_to_U (TypeNode *node,
+			 TypeNode *iface_node,
+			 gboolean  support_interfaces,
+			 gboolean  support_prerequisites)
+{
+  return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
+}
+
+/**
+ * g_type_is_a:
+ * @type: type to check anchestry for
+ * @is_a_type: possible anchestor of @type or interface that @type
+ *     could conform to
+ *
+ * If @is_a_type is a derivable type, check whether @type is a
+ * descendant of @is_a_type. If @is_a_type is an interface, check
+ * whether @type conforms to it.
+ *
+ * Returns: %TRUE if @type is a @is_a_type
+ */
+gboolean
+g_type_is_a (GType type,
+	     GType iface_type)
+{
+  TypeNode *node, *iface_node;
+  gboolean is_a;
+
+  if (type == iface_type)
+    return TRUE;
+  
+  node = lookup_type_node_I (type);
+  iface_node = lookup_type_node_I (iface_type);
+  is_a = node && iface_node && type_node_conforms_to_U (node, iface_node, TRUE, TRUE);
+  
+  return is_a;
+}
+
+/**
+ * g_type_children:
+ * @type: the parent type
+ * @n_children: (out) (allow-none): location to store the length of
+ *     the returned array, or %NULL
+ *
+ * Return a newly allocated and 0-terminated array of type IDs, listing
+ * the child types of @type.
+ *
+ * Returns: (array length=n_children) (transfer full): Newly allocated
+ *     and 0-terminated array of child types, free with g_free()
+ */
+GType*
+g_type_children (GType  type,
+		 guint *n_children)
+{
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  if (node)
+    {
+      GType *children;
+      
+      G_READ_LOCK (&type_rw_lock);	/* ->children is relocatable */
+      children = g_new (GType, node->n_children + 1);
+      memcpy (children, node->children, sizeof (GType) * node->n_children);
+      children[node->n_children] = 0;
+      
+      if (n_children)
+	*n_children = node->n_children;
+      G_READ_UNLOCK (&type_rw_lock);
+      
+      return children;
+    }
+  else
+    {
+      if (n_children)
+	*n_children = 0;
+      
+      return NULL;
+    }
+}
+
+/**
+ * g_type_interfaces:
+ * @type: the type to list interface types for
+ * @n_interfaces: (out) (allow-none): location to store the length of
+ *     the returned array, or %NULL
+ *
+ * Return a newly allocated and 0-terminated array of type IDs, listing
+ * the interface types that @type conforms to.
+ *
+ * Returns: (array length=n_interfaces) (transfer full): Newly allocated
+ *     and 0-terminated array of interface types, free with g_free()
+ */
+GType*
+g_type_interfaces (GType  type,
+		   guint *n_interfaces)
+{
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  if (node && node->is_instantiatable)
+    {
+      IFaceEntries *entries;
+      GType *ifaces;
+      guint i;
+      
+      G_READ_LOCK (&type_rw_lock);
+      entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
+      if (entries)
+	{
+	  ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);
+	  for (i = 0; i < IFACE_ENTRIES_N_ENTRIES (entries); i++)
+	    ifaces[i] = entries->entry[i].iface_type;
+	}
+      else
+	{
+	  ifaces = g_new (GType, 1);
+	  i = 0;
+	}
+      ifaces[i] = 0;
+      
+      if (n_interfaces)
+	*n_interfaces = i;
+      G_READ_UNLOCK (&type_rw_lock);
+      
+      return ifaces;
+    }
+  else
+    {
+      if (n_interfaces)
+	*n_interfaces = 0;
+      
+      return NULL;
+    }
+}
+
+typedef struct _QData QData;
+struct _GData
+{
+  guint  n_qdatas;
+  QData *qdatas;
+};
+struct _QData
+{
+  GQuark   quark;
+  gpointer data;
+};
+
+static inline gpointer
+type_get_qdata_L (TypeNode *node,
+		  GQuark    quark)
+{
+  GData *gdata = node->global_gdata;
+  
+  if (quark && gdata && gdata->n_qdatas)
+    {
+      QData *qdatas = gdata->qdatas - 1;
+      guint n_qdatas = gdata->n_qdatas;
+      
+      do
+	{
+	  guint i;
+	  QData *check;
+	  
+	  i = (n_qdatas + 1) / 2;
+	  check = qdatas + i;
+	  if (quark == check->quark)
+	    return check->data;
+	  else if (quark > check->quark)
+	    {
+	      n_qdatas -= i;
+	      qdatas = check;
+	    }
+	  else /* if (quark < check->quark) */
+	    n_qdatas = i - 1;
+	}
+      while (n_qdatas);
+    }
+  return NULL;
+}
+
+/**
+ * g_type_get_qdata:
+ * @type: a #GType
+ * @quark: a #GQuark id to identify the data
+ *
+ * Obtains data which has previously been attached to @type
+ * with g_type_set_qdata().
+ *
+ * Note that this does not take subtyping into account; data
+ * attached to one type with g_type_set_qdata() cannot
+ * be retrieved from a subtype using g_type_get_qdata().
+ *
+ * Returns: (transfer none): the data, or %NULL if no data was found
+ */
+gpointer
+g_type_get_qdata (GType  type,
+		  GQuark quark)
+{
+  TypeNode *node;
+  gpointer data;
+  
+  node = lookup_type_node_I (type);
+  if (node)
+    {
+      G_READ_LOCK (&type_rw_lock);
+      data = type_get_qdata_L (node, quark);
+      G_READ_UNLOCK (&type_rw_lock);
+    }
+  else
+    {
+      g_return_val_if_fail (node != NULL, NULL);
+      data = NULL;
+    }
+  return data;
+}
+
+static inline void
+type_set_qdata_W (TypeNode *node,
+		  GQuark    quark,
+		  gpointer  data)
+{
+  GData *gdata;
+  QData *qdata;
+  guint i;
+  
+  /* setup qdata list if necessary */
+  if (!node->global_gdata)
+    node->global_gdata = g_new0 (GData, 1);
+  gdata = node->global_gdata;
+  
+  /* try resetting old data */
+  qdata = gdata->qdatas;
+  for (i = 0; i < gdata->n_qdatas; i++)
+    if (qdata[i].quark == quark)
+      {
+	qdata[i].data = data;
+	return;
+      }
+  
+  /* add new entry */
+  gdata->n_qdatas++;
+  gdata->qdatas = g_renew (QData, gdata->qdatas, gdata->n_qdatas);
+  qdata = gdata->qdatas;
+  for (i = 0; i < gdata->n_qdatas - 1; i++)
+    if (qdata[i].quark > quark)
+      break;
+  memmove (qdata + i + 1, qdata + i, sizeof (qdata[0]) * (gdata->n_qdatas - i - 1));
+  qdata[i].quark = quark;
+  qdata[i].data = data;
+}
+
+/**
+ * g_type_set_qdata:
+ * @type: a #GType
+ * @quark: a #GQuark id to identify the data
+ * @data: the data
+ *
+ * Attaches arbitrary data to a type.
+ */
+void
+g_type_set_qdata (GType    type,
+		  GQuark   quark,
+		  gpointer data)
+{
+  TypeNode *node;
+  
+  g_return_if_fail (quark != 0);
+  
+  node = lookup_type_node_I (type);
+  if (node)
+    {
+      G_WRITE_LOCK (&type_rw_lock);
+      type_set_qdata_W (node, quark, data);
+      G_WRITE_UNLOCK (&type_rw_lock);
+    }
+  else
+    g_return_if_fail (node != NULL);
+}
+
+static void
+type_add_flags_W (TypeNode  *node,
+		  GTypeFlags flags)
+{
+  guint dflags;
+  
+  g_return_if_fail ((flags & ~TYPE_FLAG_MASK) == 0);
+  g_return_if_fail (node != NULL);
+  
+  if ((flags & TYPE_FLAG_MASK) && node->is_classed && node->data && node->data->class.class)
+    g_warning ("tagging type '%s' as abstract after class initialization", NODE_NAME (node));
+  dflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
+  dflags |= flags;
+  type_set_qdata_W (node, static_quark_type_flags, GUINT_TO_POINTER (dflags));
+}
+
+/**
+ * g_type_query:
+ * @type: #GType of a static, classed type
+ * @query: (out caller-allocates): a user provided structure that is
+ *     filled in with constant values upon success
+ *
+ * Queries the type system for information about a specific type.
+ * This function will fill in a user-provided structure to hold
+ * type-specific information. If an invalid #GType is passed in, the
+ * @type member of the #GTypeQuery is 0. All members filled into the
+ * #GTypeQuery structure should be considered constant and have to be
+ * left untouched.
+ */
+void
+g_type_query (GType       type,
+	      GTypeQuery *query)
+{
+  TypeNode *node;
+  
+  g_return_if_fail (query != NULL);
+  
+  /* if node is not static and classed, we won't allow query */
+  query->type = 0;
+  node = lookup_type_node_I (type);
+  if (node && node->is_classed && !node->plugin)
+    {
+      /* type is classed and probably even instantiatable */
+      G_READ_LOCK (&type_rw_lock);
+      if (node->data)	/* type is static or referenced */
+	{
+	  query->type = NODE_TYPE (node);
+	  query->type_name = NODE_NAME (node);
+	  query->class_size = node->data->class.class_size;
+	  query->instance_size = node->is_instantiatable ? node->data->instance.instance_size : 0;
+	}
+      G_READ_UNLOCK (&type_rw_lock);
+    }
+}
+
+/**
+ * g_type_get_instance_count:
+ * @type: a #GType
+ *
+ * Returns the number of instances allocated of the particular type;
+ * this is only available if GLib is built with debugging support and
+ * the instance_count debug flag is set (by setting the GOBJECT_DEBUG
+ * variable to include instance-count).
+ *
+ * Returns: the number of instances allocated of the given type;
+ *   if instance counts are not available, returns 0.
+ *
+ * Since: 2.44
+ */
+int
+g_type_get_instance_count (GType type)
+{
+#ifdef G_ENABLE_DEBUG
+  TypeNode *node;
+
+  node = lookup_type_node_I (type);
+  g_return_val_if_fail (node != NULL, 0);
+
+  return g_atomic_int_get (&node->instance_count);
+#else
+  return 0;
+#endif
+}
+
+/* --- implementation details --- */
+gboolean
+g_type_test_flags (GType type,
+		   guint flags)
+{
+  TypeNode *node;
+  gboolean result = FALSE;
+  
+  node = lookup_type_node_I (type);
+  if (node)
+    {
+      guint fflags = flags & TYPE_FUNDAMENTAL_FLAG_MASK;
+      guint tflags = flags & TYPE_FLAG_MASK;
+      
+      if (fflags)
+	{
+	  GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);
+	  
+	  fflags = (finfo->type_flags & fflags) == fflags;
+	}
+      else
+	fflags = TRUE;
+      
+      if (tflags)
+	{
+	  G_READ_LOCK (&type_rw_lock);
+	  tflags = (tflags & GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;
+	  G_READ_UNLOCK (&type_rw_lock);
+	}
+      else
+	tflags = TRUE;
+      
+      result = tflags && fflags;
+    }
+  
+  return result;
+}
+
+/**
+ * g_type_get_plugin:
+ * @type: #GType to retrieve the plugin for
+ *
+ * Returns the #GTypePlugin structure for @type.
+ *
+ * Returns: (transfer none): the corresponding plugin
+ *     if @type is a dynamic type, %NULL otherwise
+ */
+GTypePlugin*
+g_type_get_plugin (GType type)
+{
+  TypeNode *node;
+  
+  node = lookup_type_node_I (type);
+  
+  return node ? node->plugin : NULL;
+}
+
+/**
+ * g_type_interface_get_plugin:
+ * @instance_type: #GType of an instantiatable type
+ * @interface_type: #GType of an interface type
+ *
+ * Returns the #GTypePlugin structure for the dynamic interface
+ * @interface_type which has been added to @instance_type, or %NULL
+ * if @interface_type has not been added to @instance_type or does
+ * not have a #GTypePlugin structure. See g_type_add_interface_dynamic().
+ *
+ * Returns: (transfer none): the #GTypePlugin for the dynamic
+ *     interface @interface_type of @instance_type
+ */
+GTypePlugin*
+g_type_interface_get_plugin (GType instance_type,
+			     GType interface_type)
+{
+  TypeNode *node;
+  TypeNode *iface;
+  
+  g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);	/* G_TYPE_IS_INTERFACE() is an external call: _U */
+  
+  node = lookup_type_node_I (instance_type);  
+  iface = lookup_type_node_I (interface_type);
+  if (node && iface)
+    {
+      IFaceHolder *iholder;
+      GTypePlugin *plugin;
+      
+      G_READ_LOCK (&type_rw_lock);
+      
+      iholder = iface_node_get_holders_L (iface);
+      while (iholder && iholder->instance_type != instance_type)
+	iholder = iholder->next;
+      plugin = iholder ? iholder->plugin : NULL;
+      
+      G_READ_UNLOCK (&type_rw_lock);
+      
+      return plugin;
+    }
+  
+  g_return_val_if_fail (node == NULL, NULL);
+  g_return_val_if_fail (iface == NULL, NULL);
+  
+  g_warning (G_STRLOC ": attempt to look up plugin for invalid instance/interface type pair.");
+  
+  return NULL;
+}
+
+/**
+ * g_type_fundamental_next:
+ *
+ * Returns the next free fundamental type id which can be used to
+ * register a new fundamental type with g_type_register_fundamental().
+ * The returned type ID represents the highest currently registered
+ * fundamental type identifier.
+ *
+ * Returns: the next available fundamental type ID to be registered,
+ *     or 0 if the type system ran out of fundamental type IDs
+ */
+GType
+g_type_fundamental_next (void)
+{
+  GType type;
+  
+  G_READ_LOCK (&type_rw_lock);
+  type = static_fundamental_next;
+  G_READ_UNLOCK (&type_rw_lock);
+  type = G_TYPE_MAKE_FUNDAMENTAL (type);
+  return type <= G_TYPE_FUNDAMENTAL_MAX ? type : 0;
+}
+
+/**
+ * g_type_fundamental:
+ * @type_id: valid type ID
+ * 
+ * Internal function, used to extract the fundamental type ID portion.
+ * Use G_TYPE_FUNDAMENTAL() instead.
+ * 
+ * Returns: fundamental type ID
+ */
+GType
+g_type_fundamental (GType type_id)
+{
+  TypeNode *node = lookup_type_node_I (type_id);
+  
+  return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
+}
+
+gboolean
+g_type_check_instance_is_a (GTypeInstance *type_instance,
+			    GType          iface_type)
+{
+  TypeNode *node, *iface;
+  gboolean check;
+  
+  if (!type_instance || !type_instance->g_class)
+    return FALSE;
+  
+  node = lookup_type_node_I (type_instance->g_class->g_type);
+  iface = lookup_type_node_I (iface_type);
+  check = node && node->is_instantiatable && iface && type_node_conforms_to_U (node, iface, TRUE, FALSE);
+  
+  return check;
+}
+
+gboolean
+g_type_check_instance_is_fundamentally_a (GTypeInstance *type_instance,
+                                          GType          fundamental_type)
+{
+  TypeNode *node;
+  if (!type_instance || !type_instance->g_class)
+    return FALSE;
+  node = lookup_type_node_I (type_instance->g_class->g_type);
+  return node && (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
+}
+
+gboolean
+g_type_check_class_is_a (GTypeClass *type_class,
+			 GType       is_a_type)
+{
+  TypeNode *node, *iface;
+  gboolean check;
+  
+  if (!type_class)
+    return FALSE;
+  
+  node = lookup_type_node_I (type_class->g_type);
+  iface = lookup_type_node_I (is_a_type);
+  check = node && node->is_classed && iface && type_node_conforms_to_U (node, iface, FALSE, FALSE);
+  
+  return check;
+}
+
+GTypeInstance*
+g_type_check_instance_cast (GTypeInstance *type_instance,
+			    GType          iface_type)
+{
+  if (type_instance)
+    {
+      if (type_instance->g_class)
+	{
+	  TypeNode *node, *iface;
+	  gboolean is_instantiatable, check;
+	  
+	  node = lookup_type_node_I (type_instance->g_class->g_type);
+	  is_instantiatable = node && node->is_instantiatable;
+	  iface = lookup_type_node_I (iface_type);
+	  check = is_instantiatable && iface && type_node_conforms_to_U (node, iface, TRUE, FALSE);
+	  if (check)
+	    return type_instance;
+	  
+	  if (is_instantiatable)
+	    g_warning ("invalid cast from '%s' to '%s'",
+		       type_descriptive_name_I (type_instance->g_class->g_type),
+		       type_descriptive_name_I (iface_type));
+	  else
+	    g_warning ("invalid uninstantiatable type '%s' in cast to '%s'",
+		       type_descriptive_name_I (type_instance->g_class->g_type),
+		       type_descriptive_name_I (iface_type));
+	}
+      else
+	g_warning ("invalid unclassed pointer in cast to '%s'",
+		   type_descriptive_name_I (iface_type));
+    }
+  
+  return type_instance;
+}
+
+GTypeClass*
+g_type_check_class_cast (GTypeClass *type_class,
+			 GType       is_a_type)
+{
+  if (type_class)
+    {
+      TypeNode *node, *iface;
+      gboolean is_classed, check;
+      
+      node = lookup_type_node_I (type_class->g_type);
+      is_classed = node && node->is_classed;
+      iface = lookup_type_node_I (is_a_type);
+      check = is_classed && iface && type_node_conforms_to_U (node, iface, FALSE, FALSE);
+      if (check)
+	return type_class;
+      
+      if (is_classed)
+	g_warning ("invalid class cast from '%s' to '%s'",
+		   type_descriptive_name_I (type_class->g_type),
+		   type_descriptive_name_I (is_a_type));
+      else
+	g_warning ("invalid unclassed type '%s' in class cast to '%s'",
+		   type_descriptive_name_I (type_class->g_type),
+		   type_descriptive_name_I (is_a_type));
+    }
+  else
+    g_warning ("invalid class cast from (NULL) pointer to '%s'",
+	       type_descriptive_name_I (is_a_type));
+  return type_class;
+}
+
+/**
+ * g_type_check_instance:
+ * @instance: a valid #GTypeInstance structure
+ *
+ * Private helper function to aid implementation of the
+ * G_TYPE_CHECK_INSTANCE() macro.
+ *
+ * Returns: %TRUE if @instance is valid, %FALSE otherwise
+ */
+gboolean
+g_type_check_instance (GTypeInstance *type_instance)
+{
+  /* this function is just here to make the signal system
+   * conveniently elaborated on instance checks
+   */
+  if (type_instance)
+    {
+      if (type_instance->g_class)
+	{
+	  TypeNode *node = lookup_type_node_I (type_instance->g_class->g_type);
+	  
+	  if (node && node->is_instantiatable)
+	    return TRUE;
+	  
+	  g_warning ("instance of invalid non-instantiatable type '%s'",
+		     type_descriptive_name_I (type_instance->g_class->g_type));
+	}
+      else
+	g_warning ("instance with invalid (NULL) class pointer");
+    }
+  else
+    g_warning ("invalid (NULL) pointer instance");
+  
+  return FALSE;
+}
+
+static inline gboolean
+type_check_is_value_type_U (GType type)
+{
+  GTypeFlags tflags = G_TYPE_FLAG_VALUE_ABSTRACT;
+  TypeNode *node;
+  
+  /* common path speed up */
+  node = lookup_type_node_I (type);
+  if (node && node->mutatable_check_cache)
+    return TRUE;
+  
+  G_READ_LOCK (&type_rw_lock);
+ restart_check:
+  if (node)
+    {
+      if (node->data && NODE_REFCOUNT (node) > 0 &&
+	  node->data->common.value_table->value_init)
+	tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
+      else if (NODE_IS_IFACE (node))
+	{
+	  guint i;
+	  
+	  for (i = 0; i < IFACE_NODE_N_PREREQUISITES (node); i++)
+	    {
+	      GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
+	      TypeNode *prnode = lookup_type_node_I (prtype);
+	      
+	      if (prnode->is_instantiatable)
+		{
+		  type = prtype;
+		  node = lookup_type_node_I (type);
+		  goto restart_check;
+		}
+	    }
+	}
+    }
+  G_READ_UNLOCK (&type_rw_lock);
+  
+  return !(tflags & G_TYPE_FLAG_VALUE_ABSTRACT);
+}
+
+gboolean
+g_type_check_is_value_type (GType type)
+{
+  return type_check_is_value_type_U (type);
+}
+
+gboolean
+g_type_check_value (GValue *value)
+{
+  return value && type_check_is_value_type_U (value->g_type);
+}
+
+gboolean
+g_type_check_value_holds (GValue *value,
+			  GType   type)
+{
+  return value && type_check_is_value_type_U (value->g_type) && g_type_is_a (value->g_type, type);
+}
+
+/**
+ * g_type_value_table_peek: (skip)
+ * @type: a #GType
+ *
+ * Returns the location of the #GTypeValueTable associated with @type.
+ *
+ * Note that this function should only be used from source code
+ * that implements or has internal knowledge of the implementation of
+ * @type.
+ *
+ * Returns: location of the #GTypeValueTable associated with @type or
+ *     %NULL if there is no #GTypeValueTable associated with @type
+ */
+GTypeValueTable*
+g_type_value_table_peek (GType type)
+{
+  GTypeValueTable *vtable = NULL;
+  TypeNode *node = lookup_type_node_I (type);
+  gboolean has_refed_data, has_table;
+
+  if (node && NODE_REFCOUNT (node) && node->mutatable_check_cache)
+    return node->data->common.value_table;
+
+  G_READ_LOCK (&type_rw_lock);
+  
+ restart_table_peek:
+  has_refed_data = node && node->data && NODE_REFCOUNT (node) > 0;
+  has_table = has_refed_data && node->data->common.value_table->value_init;
+  if (has_refed_data)
+    {
+      if (has_table)
+	vtable = node->data->common.value_table;
+      else if (NODE_IS_IFACE (node))
+	{
+	  guint i;
+	  
+	  for (i = 0; i < IFACE_NODE_N_PREREQUISITES (node); i++)
+	    {
+	      GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
+	      TypeNode *prnode = lookup_type_node_I (prtype);
+	      
+	      if (prnode->is_instantiatable)
+		{
+		  type = prtype;
+		  node = lookup_type_node_I (type);
+		  goto restart_table_peek;
+		}
+	    }
+	}
+    }
+  
+  G_READ_UNLOCK (&type_rw_lock);
+  
+  if (vtable)
+    return vtable;
+  
+  if (!node)
+    g_warning (G_STRLOC ": type id '%" G_GSIZE_FORMAT "' is invalid", type);
+  if (!has_refed_data)
+    g_warning ("can't peek value table for type '%s' which is not currently referenced",
+	       type_descriptive_name_I (type));
+  
+  return NULL;
+}
+
+const gchar *
+g_type_name_from_instance (GTypeInstance *instance)
+{
+  if (!instance)
+    return "<NULL-instance>";
+  else
+    return g_type_name_from_class (instance->g_class);
+}
+
+const gchar *
+g_type_name_from_class (GTypeClass *g_class)
+{
+  if (!g_class)
+    return "<NULL-class>";
+  else
+    return g_type_name (g_class->g_type);
+}
+
+
+/* --- private api for gboxed.c --- */
+gpointer
+_g_type_boxed_copy (GType type, gpointer value)
+{
+  TypeNode *node = lookup_type_node_I (type);
+
+  return node->data->boxed.copy_func (value);
+}
+
+void
+_g_type_boxed_free (GType type, gpointer value)
+{
+  TypeNode *node = lookup_type_node_I (type);
+
+  node->data->boxed.free_func (value);
+}
+
+void
+_g_type_boxed_init (GType          type,
+                    GBoxedCopyFunc copy_func,
+                    GBoxedFreeFunc free_func)
+{
+  TypeNode *node = lookup_type_node_I (type);
+
+  node->data->boxed.copy_func = copy_func;
+  node->data->boxed.free_func = free_func;
+}
+
+/* --- initialization --- */
+/**
+ * g_type_init_with_debug_flags:
+ * @debug_flags: bitwise combination of #GTypeDebugFlags values for
+ *     debugging purposes
+ *
+ * This function used to initialise the type system with debugging
+ * flags.  Since GLib 2.36, the type system is initialised automatically
+ * and this function does nothing.
+ *
+ * If you need to enable debugging features, use the GOBJECT_DEBUG
+ * environment variable.
+ *
+ * Deprecated: 2.36: the type system is now initialised automatically
+ */
+void
+g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
+{
+  g_assert_type_system_initialized ();
+
+  if (debug_flags)
+    g_message ("g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.");
+}
+
+/**
+ * g_type_init:
+ *
+ * This function used to initialise the type system.  Since GLib 2.36,
+ * the type system is initialised automatically and this function does
+ * nothing.
+ *
+ * Deprecated: 2.36: the type system is now initialised automatically
+ */
+void
+g_type_init (void)
+{
+  g_assert_type_system_initialized ();
+}
+
+static void
+gobject_init (void)
+{
+  const gchar *env_string;
+  GTypeInfo info;
+  TypeNode *node;
+  GType type;
+
+  /* Ensure GLib is initialized first, see
+   * https://bugzilla.gnome.org/show_bug.cgi?id=756139
+   */
+  GLIB_PRIVATE_CALL (glib_init) ();
+
+  G_WRITE_LOCK (&type_rw_lock);
+
+  /* setup GObject library wide debugging flags */
+  env_string = g_getenv ("GOBJECT_DEBUG");
+  if (env_string != NULL)
+    {
+      GDebugKey debug_keys[] = {
+        { "objects", G_TYPE_DEBUG_OBJECTS },
+        { "instance-count", G_TYPE_DEBUG_INSTANCE_COUNT },
+        { "signals", G_TYPE_DEBUG_SIGNALS },
+      };
+
+      _g_type_debug_flags = g_parse_debug_string (env_string, debug_keys, G_N_ELEMENTS (debug_keys));
+    }
+
+  /* quarks */
+  static_quark_type_flags = g_quark_from_static_string ("-g-type-private--GTypeFlags");
+  static_quark_iface_holder = g_quark_from_static_string ("-g-type-private--IFaceHolder");
+  static_quark_dependants_array = g_quark_from_static_string ("-g-type-private--dependants-array");
+
+  /* type qname hash table */
+  static_type_nodes_ht = g_hash_table_new (g_str_hash, g_str_equal);
+
+  /* invalid type G_TYPE_INVALID (0)
+   */
+  static_fundamental_type_nodes[0] = NULL;
+
+  /* void type G_TYPE_NONE
+   */
+  node = type_node_fundamental_new_W (G_TYPE_NONE, g_intern_static_string ("void"), 0);
+  type = NODE_TYPE (node);
+  g_assert (type == G_TYPE_NONE);
+
+  /* interface fundamental type G_TYPE_INTERFACE (!classed)
+   */
+  memset (&info, 0, sizeof (info));
+  node = type_node_fundamental_new_W (G_TYPE_INTERFACE, g_intern_static_string ("GInterface"), G_TYPE_FLAG_DERIVABLE);
+  type = NODE_TYPE (node);
+  type_data_make_W (node, &info, NULL);
+  g_assert (type == G_TYPE_INTERFACE);
+
+  G_WRITE_UNLOCK (&type_rw_lock);
+
+  _g_value_c_init ();
+
+  /* G_TYPE_TYPE_PLUGIN
+   */
+  g_type_ensure (g_type_plugin_get_type ());
+
+  /* G_TYPE_* value types
+   */
+  _g_value_types_init ();
+
+  /* G_TYPE_ENUM & G_TYPE_FLAGS
+   */
+  _g_enum_types_init ();
+
+  /* G_TYPE_BOXED
+   */
+  _g_boxed_type_init ();
+
+  /* G_TYPE_PARAM
+   */
+  _g_param_type_init ();
+
+  /* G_TYPE_OBJECT
+   */
+  _g_object_type_init ();
+
+  /* G_TYPE_PARAM_* pspec types
+   */
+  _g_param_spec_types_init ();
+
+  /* Value Transformations
+   */
+  _g_value_transforms_init ();
+
+  /* Signal system
+   */
+  _g_signal_init ();
+}
+
+#if defined (G_OS_WIN32)
+
+BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+                     DWORD     fdwReason,
+                     LPVOID    lpvReserved);
+
+BOOL WINAPI
+DllMain (HINSTANCE hinstDLL,
+         DWORD     fdwReason,
+         LPVOID    lpvReserved)
+{
+  switch (fdwReason)
+    {
+    case DLL_PROCESS_ATTACH:
+      gobject_init ();
+      break;
+
+    default:
+      /* do nothing */
+      ;
+    }
+
+  return TRUE;
+}
+
+#elif defined (G_HAS_CONSTRUCTORS)
+#ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
+#pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(gobject_init_ctor)
+#endif
+G_DEFINE_CONSTRUCTOR(gobject_init_ctor)
+
+static void
+gobject_init_ctor (void)
+{
+  gobject_init ();
+}
+
+#else
+# error Your platform/compiler is missing constructor support
+#endif
+
+/**
+ * g_type_class_add_private:
+ * @g_class: (type GObject.TypeClass): class structure for an instantiatable
+ *    type
+ * @private_size: size of private structure
+ *
+ * Registers a private structure for an instantiatable type.
+ *
+ * When an object is allocated, the private structures for
+ * the type and all of its parent types are allocated
+ * sequentially in the same memory block as the public
+ * structures, and are zero-filled.
+ *
+ * Note that the accumulated size of the private structures of
+ * a type and all its parent types cannot exceed 64 KiB.
+ *
+ * This function should be called in the type's class_init() function.
+ * The private structure can be retrieved using the
+ * G_TYPE_INSTANCE_GET_PRIVATE() macro.
+ *
+ * The following example shows attaching a private structure
+ * MyObjectPrivate to an object MyObject defined in the standard
+ * GObject fashion in the type's class_init() function.
+ *
+ * Note the use of a structure member "priv" to avoid the overhead
+ * of repeatedly calling MY_OBJECT_GET_PRIVATE().
+ *
+ * |[<!-- language="C" --> 
+ * typedef struct _MyObject        MyObject;
+ * typedef struct _MyObjectPrivate MyObjectPrivate;
+ *
+ * struct _MyObject {
+ *  GObject parent;
+ *
+ *  MyObjectPrivate *priv;
+ * };
+ *
+ * struct _MyObjectPrivate {
+ *   int some_field;
+ * };
+ *
+ * static void
+ * my_object_class_init (MyObjectClass *klass)
+ * {
+ *   g_type_class_add_private (klass, sizeof (MyObjectPrivate));
+ * }
+ *
+ * static void
+ * my_object_init (MyObject *my_object)
+ * {
+ *   my_object->priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
+ *                                                  MY_TYPE_OBJECT,
+ *                                                  MyObjectPrivate);
+ *   // my_object->priv->some_field will be automatically initialised to 0
+ * }
+ *
+ * static int
+ * my_object_get_some_field (MyObject *my_object)
+ * {
+ *   MyObjectPrivate *priv;
+ *
+ *   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
+ *
+ *   priv = my_object->priv;
+ *
+ *   return priv->some_field;
+ * }
+ * ]|
+ *
+ * Since: 2.4
+ */
+void
+g_type_class_add_private (gpointer g_class,
+			  gsize    private_size)
+{
+  GType instance_type = ((GTypeClass *)g_class)->g_type;
+  TypeNode *node = lookup_type_node_I (instance_type);
+
+  g_return_if_fail (private_size > 0);
+  g_return_if_fail (private_size <= 0xffff);
+
+  if (!node || !node->is_instantiatable || !node->data || node->data->class.class != g_class)
+    {
+      g_warning ("cannot add private field to invalid (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (instance_type));
+      return;
+    }
+
+  if (NODE_PARENT_TYPE (node))
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+      if (node->data->instance.private_size != pnode->data->instance.private_size)
+	{
+	  g_warning ("g_type_class_add_private() called multiple times for the same type");
+	  return;
+	}
+    }
+  
+  G_WRITE_LOCK (&type_rw_lock);
+
+  private_size = ALIGN_STRUCT (node->data->instance.private_size + private_size);
+  g_assert (private_size <= 0xffff);
+  node->data->instance.private_size = private_size;
+  
+  G_WRITE_UNLOCK (&type_rw_lock);
+}
+
+/* semi-private, called only by the G_ADD_PRIVATE macro */
+gint
+g_type_add_instance_private (GType class_gtype,
+                             gsize private_size)
+{
+  TypeNode *node = lookup_type_node_I (class_gtype);
+
+  g_return_val_if_fail (private_size > 0, 0);
+  g_return_val_if_fail (private_size <= 0xffff, 0);
+
+  if (!node || !node->is_classed || !node->is_instantiatable || !node->data)
+    {
+      g_warning ("cannot add private field to invalid (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (class_gtype));
+      return 0;
+    }
+
+  if (node->plugin != NULL)
+    {
+      g_warning ("cannot use g_type_add_instance_private() with dynamic type '%s'",
+                 type_descriptive_name_I (class_gtype));
+      return 0;
+    }
+
+  /* in the future, we want to register the private data size of a type
+   * directly from the get_type() implementation so that we can take full
+   * advantage of the type definition macros that we already have.
+   *
+   * unfortunately, this does not behave correctly if a class in the middle
+   * of the type hierarchy uses the "old style" of private data registration
+   * from the class_init() implementation, as the private data offset is not
+   * going to be known until the full class hierarchy is initialized.
+   *
+   * in order to transition our code to the Glorious New Future, we proceed
+   * with a two-step implementation: first, we provide this new function to
+   * register the private data size in the get_type() implementation and we
+   * hide it behind a macro. the function will return the private size, instead
+   * of the offset, which will be stored inside a static variable defined by
+   * the G_DEFINE_TYPE_EXTENDED macro. the G_DEFINE_TYPE_EXTENDED macro will
+   * check the variable and call g_type_class_add_instance_private(), which
+   * will use the data size and actually register the private data, then
+   * return the computed offset of the private data, which will be stored
+   * inside the static variable, so we can use it to retrieve the pointer
+   * to the private data structure.
+   *
+   * once all our code has been migrated to the new idiomatic form of private
+   * data registration, we will change the g_type_add_instance_private()
+   * function to actually perform the registration and return the offset
+   * of the private data; g_type_class_add_instance_private() already checks
+   * if the passed argument is negative (meaning that it's an offset in the
+   * GTypeInstance allocation) and becomes a no-op if that's the case. this
+   * should make the migration fully transparent even if we're effectively
+   * copying this macro into everybody's code.
+   */
+  return private_size;
+}
+
+/* semi-private function, should only be used by G_DEFINE_TYPE_EXTENDED */
+void
+g_type_class_adjust_private_offset (gpointer  g_class,
+                                    gint     *private_size_or_offset)
+{
+  GType class_gtype = ((GTypeClass *) g_class)->g_type;
+  TypeNode *node = lookup_type_node_I (class_gtype);
+  gssize private_size;
+
+  g_return_if_fail (private_size_or_offset != NULL);
+
+  /* if we have been passed the offset instead of the private data size,
+   * then we consider this as a no-op, and just return the value. see the
+   * comment in g_type_add_instance_private() for the full explanation.
+   */
+  if (*private_size_or_offset > 0)
+    g_return_if_fail (*private_size_or_offset <= 0xffff);
+  else
+    return;
+
+  if (!node || !node->is_classed || !node->is_instantiatable || !node->data)
+    {
+      g_warning ("cannot add private field to invalid (non-instantiatable) type '%s'",
+		 type_descriptive_name_I (class_gtype));
+      *private_size_or_offset = 0;
+      return;
+    }
+
+  if (NODE_PARENT_TYPE (node))
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+      if (node->data->instance.private_size != pnode->data->instance.private_size)
+	{
+	  g_warning ("g_type_add_instance_private() called multiple times for the same type");
+          *private_size_or_offset = 0;
+	  return;
+	}
+    }
+
+  G_WRITE_LOCK (&type_rw_lock);
+
+  private_size = ALIGN_STRUCT (node->data->instance.private_size + *private_size_or_offset);
+  g_assert (private_size <= 0xffff);
+  node->data->instance.private_size = private_size;
+
+  *private_size_or_offset = -(gint) node->data->instance.private_size;
+
+  G_WRITE_UNLOCK (&type_rw_lock);
+}
+
+gpointer
+g_type_instance_get_private (GTypeInstance *instance,
+			     GType          private_type)
+{
+  TypeNode *node;
+
+  g_return_val_if_fail (instance != NULL && instance->g_class != NULL, NULL);
+
+  node = lookup_type_node_I (private_type);
+  if (G_UNLIKELY (!node || !node->is_instantiatable))
+    {
+      g_warning ("instance of invalid non-instantiatable type '%s'",
+                 type_descriptive_name_I (instance->g_class->g_type));
+      return NULL;
+    }
+
+  return ((gchar *) instance) - node->data->instance.private_size;
+}
+
+/**
+ * g_type_class_get_instance_private_offset: (skip)
+ * @g_class: (type GObject.TypeClass): a #GTypeClass
+ *
+ * Gets the offset of the private data for instances of @g_class.
+ *
+ * This is how many bytes you should add to the instance pointer of a
+ * class in order to get the private data for the type represented by
+ * @g_class.
+ *
+ * You can only call this function after you have registered a private
+ * data area for @g_class using g_type_class_add_private().
+ *
+ * Returns: the offset, in bytes
+ *
+ * Since: 2.38
+ **/
+gint
+g_type_class_get_instance_private_offset (gpointer g_class)
+{
+  GType instance_type;
+  guint16 parent_size;
+  TypeNode *node;
+
+  g_assert (g_class != NULL);
+
+  instance_type = ((GTypeClass *) g_class)->g_type;
+  node = lookup_type_node_I (instance_type);
+
+  g_assert (node != NULL);
+  g_assert (node->is_instantiatable);
+
+  if (NODE_PARENT_TYPE (node))
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+
+      parent_size = pnode->data->instance.private_size;
+    }
+  else
+    parent_size = 0;
+
+  if (node->data->instance.private_size == parent_size)
+    g_error ("g_type_class_get_instance_private_offset() called on class %s but it has no private data",
+             g_type_name (instance_type));
+
+  return -(gint) node->data->instance.private_size;
+}
+
+/**
+ * g_type_add_class_private:
+ * @class_type: GType of an classed type
+ * @private_size: size of private structure
+ *
+ * Registers a private class structure for a classed type;
+ * when the class is allocated, the private structures for
+ * the class and all of its parent types are allocated
+ * sequentially in the same memory block as the public
+ * structures, and are zero-filled.
+ *
+ * This function should be called in the
+ * type's get_type() function after the type is registered.
+ * The private structure can be retrieved using the
+ * G_TYPE_CLASS_GET_PRIVATE() macro.
+ *
+ * Since: 2.24
+ */
+void
+g_type_add_class_private (GType    class_type,
+			  gsize    private_size)
+{
+  TypeNode *node = lookup_type_node_I (class_type);
+  gsize offset;
+
+  g_return_if_fail (private_size > 0);
+
+  if (!node || !node->is_classed || !node->data)
+    {
+      g_warning ("cannot add class private field to invalid type '%s'",
+		 type_descriptive_name_I (class_type));
+      return;
+    }
+
+  if (NODE_PARENT_TYPE (node))
+    {
+      TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
+      if (node->data->class.class_private_size != pnode->data->class.class_private_size)
+	{
+	  g_warning ("g_type_add_class_private() called multiple times for the same type");
+	  return;
+	}
+    }
+  
+  G_WRITE_LOCK (&type_rw_lock);
+
+  offset = ALIGN_STRUCT (node->data->class.class_private_size);
+  node->data->class.class_private_size = offset + private_size;
+
+  G_WRITE_UNLOCK (&type_rw_lock);
+}
+
+gpointer
+g_type_class_get_private (GTypeClass *klass,
+			  GType       private_type)
+{
+  TypeNode *class_node;
+  TypeNode *private_node;
+  TypeNode *parent_node;
+  gsize offset;
+
+  g_return_val_if_fail (klass != NULL, NULL);
+
+  class_node = lookup_type_node_I (klass->g_type);
+  if (G_UNLIKELY (!class_node || !class_node->is_classed))
+    {
+      g_warning ("class of invalid type '%s'",
+		 type_descriptive_name_I (klass->g_type));
+      return NULL;
+    }
+
+  private_node = lookup_type_node_I (private_type);
+  if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
+    {
+      g_warning ("attempt to retrieve private data for invalid type '%s'",
+		 type_descriptive_name_I (private_type));
+      return NULL;
+    }
+
+  offset = ALIGN_STRUCT (class_node->data->class.class_size);
+
+  if (NODE_PARENT_TYPE (private_node))
+    {
+      parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
+      g_assert (parent_node->data && NODE_REFCOUNT (parent_node) > 0);
+
+      if (G_UNLIKELY (private_node->data->class.class_private_size == parent_node->data->class.class_private_size))
+	{
+	  g_warning ("g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()");
+	  return NULL;
+	}
+
+      offset += ALIGN_STRUCT (parent_node->data->class.class_private_size);
+    }
+
+  return G_STRUCT_MEMBER_P (klass, offset);
+}
+
+/**
+ * g_type_ensure:
+ * @type: a #GType
+ *
+ * Ensures that the indicated @type has been registered with the
+ * type system, and its _class_init() method has been run.
+ *
+ * In theory, simply calling the type's _get_type() method (or using
+ * the corresponding macro) is supposed take care of this. However,
+ * _get_type() methods are often marked %G_GNUC_CONST for performance
+ * reasons, even though this is technically incorrect (since
+ * %G_GNUC_CONST requires that the function not have side effects,
+ * which _get_type() methods do on the first call). As a result, if
+ * you write a bare call to a _get_type() macro, it may get optimized
+ * out by the compiler. Using g_type_ensure() guarantees that the
+ * type's _get_type() method is called.
+ *
+ * Since: 2.34
+ */
+void
+g_type_ensure (GType type)
+{
+  /* In theory, @type has already been resolved and so there's nothing
+   * to do here. But this protects us in the case where the function
+   * gets inlined (as it might in gobject_init_ctor() above).
+   */
+  if (G_UNLIKELY (type == (GType)-1))
+    g_error ("can't happen");
+}
+
